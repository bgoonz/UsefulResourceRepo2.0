[
  {
    "path": "docs_algorithm_02-dynamics-programming.md",
    "slug": "02-dynamics-programming",
    "topic": "algorithm",
    "title": "Recurrence",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/algorithm/02-dynamics-programming.md",
    "front": "What is dynamic programming",
    "back": "A method for solving an optimization problems where the constraints \nare not necessarily linear and optimal solutions are defined recursively"
  },
  {
    "path": "docs_algorithm_03-greedy-programming.md",
    "slug": "03-greedy-programming",
    "topic": "algorithm",
    "title": "Recurrence",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/algorithm/03-greedy-programming.md",
    "front": "What is greedy programming",
    "back": "To make a locally optimal choice in hope of getting a globally optimal solution"
  },
  {
    "path": "docs_algorithm_04-divide-and-conquer.md",
    "slug": "04-divide-and-conquer",
    "topic": "algorithm",
    "title": "Recurrence",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/algorithm/04-divide-and-conquer.md",
    "front": "What is divide and conquer",
    "back": "Split the problem in sub-problems and solve the sub-problems recursively, working your way to the main problem"
  },
  {
    "path": "docs_algorithm_01-recurrence.md",
    "slug": "01-recurrence",
    "topic": "algorithm",
    "title": "Recurrence",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/algorithm/01-recurrence.md",
    "front": "What is recurrence",
    "back": "An equation or inequality that describes a function in terms of its value on previous/smaller values"
  },
  {
    "path": "docs_dynamic-programming_01-climb-stairs.md",
    "slug": "01-climb-stairs",
    "topic": "dynamic-programming",
    "title": "70 Climb stairs",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/dynamic-programming/01-climb-stairs.md",
    "front": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct\nways can you climb to the top?",
    "back": "Algorithm: fibonacci (number of stairs + 1)\n\nDP equation: array[ i ] = array[i - 1] + array[i - 2]\n\nTime complexity: O(n)\nSpace complexity: O(1)"
  },
  {
    "path": "docs_array_03-first-missing-positive.md",
    "slug": "03-first-missing-positive",
    "topic": "array",
    "title": "Two sum",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/03-first-missing-positive.md",
    "front": "Given an unsorted integer array nums, find the smallest missing positive integer.\n\nInput: nums = [1,2,0]\nOutput: 3",
    "back": "Data Structure:\n- hashtable: maintain a mapping of each element in the array to its index\n\nAlgorithm: Two-pass Hash Table\n1. In the first iteration, add each element's value and its index to the table.\n2. In the second iteration, check if each element's complement (target - nums[i]) exists in the table.\n3. Beware that the complement must not be nums[i] itself.\n\nTime complexity: O(n)\nSpace complexity: O(n)"
  },
  {
    "path": "docs_array_02-container-with-most-water.md",
    "slug": "02-container-with-most-water",
    "topic": "array",
    "title": "Container with most water",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/02-container-with-most-water.md",
    "front": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.",
    "back": "Initially we can assume the result is 0. Then we scan from both sides. If leftHeight < rightHeight, move right and find a value that is greater than leftHeight. Similarily, if leftHeight > rightHeight, move left and find a value that is greater than rightHeight. Additionally, keep tracking the max value."
  },
  {
    "path": "docs_array_01-two-sum.md",
    "slug": "01-two-sum",
    "topic": "array",
    "title": "Two sum",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/01-two-sum.md",
    "front": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n\n[2, 7, 11, 15], 9 => [0, 1]",
    "back": "Data Structure:\n- hashtable: maintain a mapping of each element in the array to its index\n\nAlgorithm: Two-pass Hash Table\n1. In the first iteration, add each element's value and its index to the table.\n2. In the second iteration, check if each element's complement (target - nums[i]) exists in the table.\n3. Beware that the complement must not be nums[i] itself.\n\nTime complexity: O(n)\nSpace complexity: O(n)"
  },
  {
    "path": "docs_array_04-spiral-matrix.md",
    "slug": "04-spiral-matrix",
    "topic": "array",
    "title": "Two sum",
    "url": "https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/04-spiral-matrix.md",
    "front": "Given an m x n matrix, return all elements of the matrix in spiral order.\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]",
    "back": "Data Structure:\n- hashtable: maintain a mapping of each element in the array to its index\n\nAlgorithm: Two-pass Hash Table\n1. In the first iteration, add each element's value and its index to the table.\n2. In the second iteration, check if each element's complement (target - nums[i]) exists in the table.\n3. Beware that the complement must not be nums[i] itself.\n\nTime complexity: O(n)\nSpace complexity: O(n)"
  }
]
