<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>fast-refresh</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="fast-refresh">Fast Refresh</h1>
    <details open>
      <summary><b>Examples</b></summary>
      <ul>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/fast-refresh-demo"
            >Fast Refresh Demo</a
          >
        </li>
      </ul>
    </details>
    <p>
      Fast Refresh is a Next.js feature that gives you instantaneous feedback on
      edits made to your React components. Fast Refresh is enabled by default in
      all Next.js applications on <strong>9.4 or newer</strong>. With Next.js
      Fast Refresh enabled, most edits should be visible within a second,
      <strong>without losing component state</strong>.
    </p>
    <h2 id="how-it-works">How It Works</h2>
    <ul>
      <li>
        If you edit a file that
        <strong>only exports React component(s)</strong>, Fast Refresh will
        update the code only for that file, and re-render your component. You
        can edit anything in that file, including styles, rendering logic, event
        handlers, or effects.
      </li>
      <li>
        If you edit a file with exports that <em>aren’t</em> React components,
        Fast Refresh will re-run both that file, and the other files importing
        it. So if both <code>Button.js</code> and <code>Modal.js</code> import
        <code>theme.js</code>, editing <code>theme.js</code> will update both
        components.
      </li>
      <li>
        Finally, if you <strong>edit a file</strong> that’s
        <strong>imported by files outside of the React tree</strong>, Fast
        Refresh <strong>will fall back to doing a full reload</strong>. You
        might have a file which renders a React component but also exports a
        value that is imported by a <strong>non-React component</strong>. For
        example, maybe your component also exports a constant, and a non-React
        utility file imports it. In that case, consider migrating the constant
        to a separate file and importing it into both files. This will re-enable
        Fast Refresh to work. Other cases can usually be solved in a similar
        way.
      </li>
    </ul>
    <h2 id="error-resilience">Error Resilience</h2>
    <h3 id="syntax-errors">Syntax Errors</h3>
    <p>
      If you make a syntax error during development, you can fix it and save the
      file again. The error will disappear automatically, so you won’t need to
      reload the app. <strong>You will not lose component state</strong>.
    </p>
    <h3 id="runtime-errors">Runtime Errors</h3>
    <p>
      If you make a mistake that leads to a runtime error inside your component,
      you’ll be greeted with a contextual overlay. Fixing the error will
      automatically dismiss the overlay, without reloading the app.
    </p>
    <p>
      Component state will be retained if the error did not occur during
      rendering. If the error did occur during rendering, React will remount
      your application using the updated code.
    </p>
    <p>
      If you have
      <a href="https://reactjs.org/docs/error-boundaries.html"
        >error boundaries</a
      >
      in your app (which is a good idea for graceful failures in production),
      they will retry rendering on the next edit after a rendering error. This
      means having an error boundary can prevent you from always getting reset
      to the root app state. However, keep in mind that error boundaries
      shouldn’t be <em>too</em> granular. They are used by React in production,
      and should always be designed intentionally.
    </p>
    <h2 id="limitations">Limitations</h2>
    <p>
      Fast Refresh tries to preserve local React state in the component you’re
      editing, but only if it’s safe to do so. Here’s a few reasons why you
      might see local state being reset on every edit to a file:
    </p>
    <ul>
      <li>
        Local state is not preserved for class components (only function
        components and Hooks preserve state).
      </li>
      <li>
        The file you’re editing might have <em>other</em> exports in addition to
        a React component.
      </li>
      <li>
        Sometimes, a file would export the result of calling higher-order
        component like <code>HOC(WrappedComponent)</code>. If the returned
        component is a class, state will be reset.
      </li>
      <li>
        Anonymous arrow functions like
        <code>export default () =&gt; &lt;div /&gt;;</code> cause Fast Refresh
        to not preserve local component state. For large codebases you can use
        our
        <a href="/docs/advanced-features/codemods.md#name-default-component"
          ><code>name-default-component</code> codemod</a
        >.
      </li>
    </ul>
    <p>
      As more of your codebase moves to function components and Hooks, you can
      expect state to be preserved in more cases.
    </p>
    <h2 id="tips">Tips</h2>
    <ul>
      <li>
        Fast Refresh preserves React local state in function components (and
        Hooks) by default.
      </li>
      <li>
        Sometimes you might want to <em>force</em> the state to be reset, and a
        component to be remounted. For example, this can be handy if you’re
        tweaking an animation that only happens on mount. To do this, you can
        add <code>// @refresh reset</code> anywhere in the file you’re editing.
        This directive is local to the file, and instructs Fast Refresh to
        remount components defined in that file on every edit.
      </li>
      <li>
        You can put <code>console.log</code> or <code>debugger;</code> into the
        components you edit during development.
      </li>
    </ul>
    <h2 id="fast-refresh-and-hooks">Fast Refresh and Hooks</h2>
    <p>
      When possible, Fast Refresh attempts to preserve the state of your
      component between edits. In particular, <code>useState</code> and
      <code>useRef</code> preserve their previous values as long as you don’t
      change their arguments or the order of the Hook calls.
    </p>
    <p>
      Hooks with dependencies—such as <code>useEffect</code>,
      <code>useMemo</code>, and <code>useCallback</code>—will
      <em>always</em> update during Fast Refresh. Their list of dependencies
      will be ignored while Fast Refresh is happening.
    </p>
    <p>
      For example, when you edit <code>useMemo(() =&gt; x * 2, [x])</code> to
      <code>useMemo(() =&gt; x * 10, [x])</code>, it will re-run even though
      <code>x</code> (the dependency) has not changed. If React didn’t do that,
      your edit wouldn’t reflect on the screen!
    </p>
    <p>
      Sometimes, this can lead to unexpected results. For example, even a
      <code>useEffect</code> with an empty array of dependencies would still
      re-run once during Fast Refresh.
    </p>
    <p>
      However, writing code resilient to occasional re-running of
      <code>useEffect</code> is a good practice even without Fast Refresh. It
      will make it easier for you to introduce new dependencies to it later on
      and it’s enforced by
      <a href="/docs/api-reference/next.config.js/react-strict-mode.md"
        >React Strict Mode</a
      >, which we highly recommend enabling.
    </p>
  </body>
</html>
