<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>pages</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="pages">Pages</h1>
    <blockquote>
      <p>
        This document is for Next.js versions 9.3 and up. If you’re using older
        versions of Next.js, refer to our
        <a href="https://nextjs.org/docs/tag/v9.2.2/basic-features/pages"
          >previous documentation</a
        >.
      </p>
    </blockquote>
    <p>
      In Next.js, a <strong>page</strong> is a
      <a href="https://reactjs.org/docs/components-and-props.html"
        >React Component</a
      >
      exported from a <code>.js</code>, <code>.jsx</code>, <code>.ts</code>, or
      <code>.tsx</code> file in the <code>pages</code> directory. Each page is
      associated with a route based on its file name.
    </p>
    <p>
      <strong>Example</strong>: If you create <code>pages/about.js</code> that
      exports a React component like below, it will be accessible at
      <code>/about</code>.
    </p>
    <pre class="jsx"><code>function About() {
  return &lt;div&gt;About&lt;/div&gt;
}

export default About</code></pre>
    <h3 id="pages-with-dynamic-routes">Pages with Dynamic Routes</h3>
    <p>
      Next.js supports pages with dynamic routes. For example, if you create a
      file called <code>pages/posts/[id].js</code>, then it will be accessible
      at <code>posts/1</code>, <code>posts/2</code>, etc.
    </p>
    <blockquote>
      <p>
        To learn more about dynamic routing, check the
        <a href="/docs/routing/dynamic-routes.md"
          >Dynamic Routing documentation</a
        >.
      </p>
    </blockquote>
    <h2 id="pre-rendering">Pre-rendering</h2>
    <p>
      By default, Next.js <strong>pre-renders</strong> every page. This means
      that Next.js generates HTML for each page in advance, instead of having it
      all done by client-side JavaScript. Pre-rendering can result in better
      performance and SEO.
    </p>
    <p>
      Each generated HTML is associated with minimal JavaScript code necessary
      for that page. When a page is loaded by the browser, its JavaScript code
      runs and makes the page fully interactive. (This process is called
      <em>hydration</em>.)
    </p>
    <h3 id="two-forms-of-pre-rendering">Two forms of Pre-rendering</h3>
    <p>
      Next.js has two forms of pre-rendering:
      <strong>Static Generation</strong> and
      <strong>Server-side Rendering</strong>. The difference is in
      <strong>when</strong> it generates the HTML for a page.
    </p>
    <ul>
      <li>
        <a href="#static-generation-recommended"
          ><strong>Static Generation (Recommended)</strong></a
        >: The HTML is generated at <strong>build time</strong> and will be
        reused on each request.
      </li>
      <li>
        <a href="#server-side-rendering"
          ><strong>Server-side Rendering</strong></a
        >: The HTML is generated on <strong>each request</strong>.
      </li>
    </ul>
    <p>
      Importantly, Next.js lets you <strong>choose</strong> which pre-rendering
      form you’d like to use for each page. You can create a “hybrid” Next.js
      app by using Static Generation for most pages and using Server-side
      Rendering for others.
    </p>
    <p>
      We <strong>recommend</strong> using
      <strong>Static Generation</strong> over Server-side Rendering for
      performance reasons. Statically generated pages can be cached by CDN with
      no extra configuration to boost performance. However, in some cases,
      Server-side Rendering might be the only option.
    </p>
    <p>
      You can also use <strong>Client-side Rendering</strong> along with Static
      Generation or Server-side Rendering. That means some parts of a page can
      be rendered entirely by client side JavaScript. To learn more, take a look
      at the
      <a
        href="/docs/basic-features/data-fetching.md#fetching-data-on-the-client-side"
        >Data Fetching</a
      >
      documentation.
    </p>
    <h2 id="static-generation-recommended">Static Generation (Recommended)</h2>
    <details open>
      <summary><b>Examples</b></summary>
      <ul>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-wordpress"
            >WordPress Example</a
          >
          (<a href="https://next-blog-wordpress.vercel.app">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/blog-starter"
            >Blog Starter using markdown files</a
          >
          (<a href="https://next-blog-starter.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-datocms"
            >DatoCMS Example</a
          >
          (<a href="https://next-blog-datocms.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape"
            >TakeShape Example</a
          >
          (<a href="https://next-blog-takeshape.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-sanity"
            >Sanity Example</a
          >
          (<a href="https://next-blog-sanity.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-prismic"
            >Prismic Example</a
          >
          (<a href="https://next-blog-prismic.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-contentful"
            >Contentful Example</a
          >
          (<a href="https://next-blog-contentful.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-strapi"
            >Strapi Example</a
          >
          (<a href="https://next-blog-strapi.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-prepr"
            >Prepr Example</a
          >
          (<a href="https://next-blog-prepr.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-agilitycms"
            >Agility CMS Example</a
          >
          (<a href="https://next-blog-agilitycms.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-cosmic"
            >Cosmic Example</a
          >
          (<a href="https://next-blog-cosmic.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-buttercms"
            >ButterCMS Example</a
          >
          (<a href="https://next-blog-buttercms.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-storyblok"
            >Storyblok Example</a
          >
          (<a href="https://next-blog-storyblok.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-graphcms"
            >GraphCMS Example</a
          >
          (<a href="https://next-blog-graphcms.vercel.app/">Demo</a>)
        </li>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/cms-kontent"
            >Kontent Example</a
          >
          (<a href="https://next-blog-kontent.vercel.app/">Demo</a>)
        </li>
        <li>
          <a href="https://static-tweet.vercel.app/">Static Tweet Demo</a>
        </li>
      </ul>
    </details>
    <p>
      If a page uses <strong>Static Generation</strong>, the page HTML is
      generated at <strong>build time</strong>. That means in production, the
      page HTML is generated when you run <code>next build</code> . This HTML
      will then be reused on each request. It can be cached by a CDN.
    </p>
    <p>
      In Next.js, you can statically generate pages
      <strong>with or without data</strong>. Let’s take a look at each case.
    </p>
    <h3 id="static-generation-without-data">Static Generation without data</h3>
    <p>
      By default, Next.js pre-renders pages using Static Generation without
      fetching data. Here’s an example:
    </p>
    <pre class="jsx"><code>function About() {
  return &lt;div&gt;About&lt;/div&gt;
}

export default About</code></pre>
    <p>
      Note that this page does not need to fetch any external data to be
      pre-rendered. In cases like this, Next.js generates a single HTML file per
      page during build time.
    </p>
    <h3 id="static-generation-with-data">Static Generation with data</h3>
    <p>
      Some pages require fetching external data for pre-rendering. There are two
      scenarios, and one or both might apply. In each case, you can use these
      functions that Next.js provides:
    </p>
    <ol type="1">
      <li>
        Your page <strong>content</strong> depends on external data: Use
        <code>getStaticProps</code>.
      </li>
      <li>
        Your page <strong>paths</strong> depend on external data: Use
        <code>getStaticPaths</code> (usually in addition to
        <code>getStaticProps</code>).
      </li>
    </ol>
    <h4 id="scenario-1-your-page-content-depends-on-external-data">
      Scenario 1: Your page <strong>content</strong> depends on external data
    </h4>
    <p>
      <strong>Example</strong>: Your blog page might need to fetch the list of
      blog posts from a CMS (content management system).
    </p>
    <pre
      class="jsx"
    ><code>// TODO: Need to fetch `posts` (by calling some API endpoint)
//       before this page can be pre-rendered.
function Blog({ posts }) {
  return (
    &lt;ul&gt;
      {posts.map((post) =&gt; (
        &lt;li&gt;{post.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}

export default Blog</code></pre>
    <p>
      To fetch this data on pre-render, Next.js allows you to
      <code>export</code> an <code>async</code> function called
      <code>getStaticProps</code> from the same file. This function gets called
      at build time and lets you pass fetched data to the page’s
      <code>props</code> on pre-render.
    </p>
    <pre class="jsx"><code>function Blog({ posts }) {
  // Render posts...
}

// This function gets called at build time
export async function getStaticProps() {
  // Call an external API endpoint to get posts
  const res = await fetch(&#39;https://.../posts&#39;)
  const posts = await res.json()

  // By returning { props: { posts } }, the Blog component
  // will receive `posts` as a prop at build time
  return {
    props: {
      posts,
    },
  }
}

export default Blog</code></pre>
    <p>
      To learn more about how <code>getStaticProps</code> works, check out the
      <a
        href="/docs/basic-features/data-fetching.md#getstaticprops-static-generation"
        >Data Fetching documentation</a
      >.
    </p>
    <h4 id="scenario-2-your-page-paths-depend-on-external-data">
      Scenario 2: Your page paths depend on external data
    </h4>
    <p>
      Next.js allows you to create pages with <strong>dynamic routes</strong>.
      For example, you can create a file called
      <code>pages/posts/[id].js</code> to show a single blog post based on
      <code>id</code>. This will allow you to show a blog post with
      <code>id: 1</code> when you access <code>posts/1</code>.
    </p>
    <blockquote>
      <p>
        To learn more about dynamic routing, check the
        <a href="/docs/routing/dynamic-routes.md"
          >Dynamic Routing documentation</a
        >.
      </p>
    </blockquote>
    <p>
      However, which <code>id</code> you want to pre-render at build time might
      depend on external data.
    </p>
    <p>
      <strong>Example</strong>: suppose that you’ve only added one blog post
      (with <code>id: 1</code>) to the database. In this case, you’d only want
      to pre-render <code>posts/1</code> at build time.
    </p>
    <p>
      Later, you might add the second post with <code>id: 2</code>. Then you’d
      want to pre-render <code>posts/2</code> as well.
    </p>
    <p>
      So your page <strong>paths</strong> that are pre-rendered depend on
      external data<strong>.</strong> To handle this, Next.js lets you
      <code>export</code> an <code>async</code> function called
      <code>getStaticPaths</code> from a dynamic page (<code
        >pages/posts/[id].js</code
      >
      in this case). This function gets called at build time and lets you
      specify which paths you want to pre-render.
    </p>
    <pre class="jsx"><code>// This function gets called at build time
export async function getStaticPaths() {
  // Call an external API endpoint to get posts
  const res = await fetch(&#39;https://.../posts&#39;)
  const posts = await res.json()

  // Get the paths we want to pre-render based on posts
  const paths = posts.map((post) =&gt; ({
    params: { id: post.id },
  }))

  // We&#39;ll pre-render only these paths at build time.
  // { fallback: false } means other routes should 404.
  return { paths, fallback: false }
}</code></pre>
    <p>
      Also in <code>pages/posts/[id].js</code>, you need to export
      <code>getStaticProps</code> so that you can fetch the data about the post
      with this <code>id</code> and use it to pre-render the page:
    </p>
    <pre class="jsx"><code>function Post({ post }) {
  // Render post...
}

export async function getStaticPaths() {
  // ...
}

// This also gets called at build time
export async function getStaticProps({ params }) {
  // params contains the post `id`.
  // If the route is like /posts/1, then params.id is 1
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  // Pass post data to the page via props
  return { props: { post } }
}

export default Post</code></pre>
    <p>
      To learn more about how <code>getStaticPaths</code> works, check out the
      <a
        href="/docs/basic-features/data-fetching.md#getstaticpaths-static-generation"
        >Data Fetching documentation</a
      >.
    </p>
    <h3 id="when-should-i-use-static-generation">
      When should I use Static Generation?
    </h3>
    <p>
      We recommend using <strong>Static Generation</strong> (with and without
      data) whenever possible because your page can be built once and served by
      CDN, which makes it much faster than having a server render the page on
      every request.
    </p>
    <p>You can use Static Generation for many types of pages, including:</p>
    <ul>
      <li>Marketing pages</li>
      <li>Blog posts</li>
      <li>E-commerce product listings</li>
      <li>Help and documentation</li>
    </ul>
    <p>
      You should ask yourself: “Can I pre-render this page
      <strong>ahead</strong> of a user’s request?” If the answer is yes, then
      you should choose Static Generation.
    </p>
    <p>
      On the other hand, Static Generation is <strong>not</strong> a good idea
      if you cannot pre-render a page ahead of a user’s request. Maybe your page
      shows frequently updated data, and the page content changes on every
      request.
    </p>
    <p>In cases like this, you can do one of the following:</p>
    <ul>
      <li>
        Use Static Generation with <strong>Client-side Rendering:</strong> You
        can skip pre-rendering some parts of a page and then use client-side
        JavaScript to populate them. To learn more about this approach, check
        out the
        <a
          href="/docs/basic-features/data-fetching.md#fetching-data-on-the-client-side"
          >Data Fetching documentation</a
        >.
      </li>
      <li>
        Use <strong>Server-Side Rendering:</strong> Next.js pre-renders a page
        on each request. It will be slower because the page cannot be cached by
        a CDN, but the pre-rendered page will always be up-to-date. We’ll talk
        about this approach below.
      </li>
    </ul>
    <h2 id="server-side-rendering">Server-side Rendering</h2>
    <blockquote>
      <p>Also referred to as “SSR” or “Dynamic Rendering”.</p>
    </blockquote>
    <p>
      If a page uses <strong>Server-side Rendering</strong>, the page HTML is
      generated on <strong>each request</strong>.
    </p>
    <p>
      To use Server-side Rendering for a page, you need to
      <code>export</code> an <code>async</code> function called
      <code>getServerSideProps</code>. This function will be called by the
      server on every request.
    </p>
    <p>
      For example, suppose that your page needs to pre-render frequently updated
      data (fetched from an external API). You can write
      <code>getServerSideProps</code> which fetches this data and passes it to
      <code>Page</code> like below:
    </p>
    <pre class="jsx"><code>function Page({ data }) {
  // Render data...
}

// This gets called on every request
export async function getServerSideProps() {
  // Fetch data from external API
  const res = await fetch(`https://.../data`)
  const data = await res.json()

  // Pass data to the page via props
  return { props: { data } }
}

export default Page</code></pre>
    <p>
      As you can see, <code>getServerSideProps</code> is similar to
      <code>getStaticProps</code>, but the difference is that
      <code>getServerSideProps</code> is run on every request instead of on
      build time.
    </p>
    <p>
      To learn more about how <code>getServerSideProps</code> works, check out
      our
      <a
        href="/docs/basic-features/data-fetching.md#getserversideprops-server-side-rendering"
        >Data Fetching documentation</a
      >
    </p>
    <h2 id="summary">Summary</h2>
    <p>We’ve discussed two forms of pre-rendering for Next.js.</p>
    <ul>
      <li>
        <strong>Static Generation (Recommended):</strong> The HTML is generated
        at <strong>build time</strong> and will be reused on each request. To
        make a page use Static Generation, either export the page component, or
        export <code>getStaticProps</code> (and <code>getStaticPaths</code> if
        necessary). It’s great for pages that can be pre-rendered ahead of a
        user’s request. You can also use it with Client-side Rendering to bring
        in additional data.
      </li>
      <li>
        <strong>Server-side Rendering:</strong> The HTML is generated on
        <strong>each request</strong>. To make a page use Server-side Rendering,
        export <code>getServerSideProps</code>. Because Server-side Rendering
        results in slower performance than Static Generation, use this only if
        absolutely necessary.
      </li>
    </ul>
    <h2 id="learn-more">Learn more</h2>
    <p>We recommend you to read the following sections next:</p>
    <div class="card">
      <p>
        <a href="/docs/basic-features/data-fetching.md">
          <b>Data Fetching:</b>
          <small>Learn more about data fetching in Next.js.</small>
        </a>
      </p>
    </div>
    <div class="card">
      <p>
        <a href="/docs/advanced-features/preview-mode.md">
          <b>Preview Mode:</b>
          <small>Learn more about the preview mode in Next.js.</small>
        </a>
      </p>
    </div>
    <div class="card">
      <p>
        <a href="/docs/routing/introduction.md">
          <b>Routing:</b> <small>Learn more about routing in Next.js.</small>
        </a>
      </p>
    </div>
    <div class="card">
      <p>
        <a href="/docs/basic-features/typescript.md#pages">
          <b>TypeScript:</b> <small>Add TypeScript to your pages.</small>
        </a>
      </p>
    </div>
  </body>
</html>
