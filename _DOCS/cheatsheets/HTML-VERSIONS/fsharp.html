<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>fsharp.html</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <p>
      F# is a general purpose functional/OO programming language. Itâ€™s free and
      open source, and runs on Linux, Mac, Windows and more.
    </p>
    <p>
      It has a powerful type system that traps many errors at compile time, but
      it uses type inference so that it reads more like a dynamic language.
    </p>
    <p>The syntax of F# is different from C-style languages:</p>
    <ul>
      <li>
        Curly braces are not used to delimit blocks of code. Instead,
        indentation is used (like Python).
      </li>
      <li>Whitespace is used to separate parameters rather than commas.</li>
    </ul>
    <p>
      If you want to try out the code below, you can go to
      <a href="https://try.fsharp.org">https://try.fsharp.org</a> and paste it
      into an interactive REPL.
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode csharp"
      ><code class="sourceCode cs"><a class="sourceLine" id="cb1-1" title="1"></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">// single line comments use a double slash</span></a>
<a class="sourceLine" id="cb1-3" title="3">(* multi line comments <span class="fu">use</span> (* . . . *) pair</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">-end of multi line comment- *)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">// Basic Syntax</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">// ------ &quot;Variables&quot; (but not really) ------</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">// The &quot;let&quot; keyword defines an (immutable) value</span></a>
<a class="sourceLine" id="cb1-13" title="13">let myInt = <span class="dv">5</span></a>
<a class="sourceLine" id="cb1-14" title="14">let myFloat = <span class="fl">3.14</span></a>
<a class="sourceLine" id="cb1-15" title="15">let myString = <span class="st">&quot;hello&quot;</span>           <span class="co">// note that no types needed</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">// ------ Lists ------</span></a>
<a class="sourceLine" id="cb1-18" title="18">let twoToFive = [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>]     <span class="co">// Square brackets create a list with</span></a>
<a class="sourceLine" id="cb1-19" title="19">                                 <span class="co">// semicolon delimiters.</span></a>
<a class="sourceLine" id="cb1-20" title="20">let oneToFive = <span class="dv">1</span> :: twoToFive   <span class="co">// :: creates list with new 1st element</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co">// The result is [1; 2; 3; 4; 5]</span></a>
<a class="sourceLine" id="cb1-22" title="22">let zeroToFive = [<span class="dv">0</span>; <span class="dv">1</span>] @ twoToFive   <span class="co">// @ concats two lists</span></a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="co">// IMPORTANT: commas are never used as delimiters, only semicolons!</span></a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co">// ------ Functions ------</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">// The &quot;let&quot; keyword also defines a named function.</span></a>
<a class="sourceLine" id="cb1-28" title="28">let square x = x * x          <span class="co">// Note that no parens are used.</span></a>
<a class="sourceLine" id="cb1-29" title="29">square <span class="dv">3</span>                      <span class="co">// Now run the function. Again, no parens.</span></a>
<a class="sourceLine" id="cb1-30" title="30"></a>
<a class="sourceLine" id="cb1-31" title="31">let add x y = x + y           <span class="co">// don&#39;t use add (x,y)! It means something</span></a>
<a class="sourceLine" id="cb1-32" title="32">                              <span class="co">// completely different.</span></a>
<a class="sourceLine" id="cb1-33" title="33">add <span class="dv">2</span> <span class="dv">3</span>                       <span class="co">// Now run the function.</span></a>
<a class="sourceLine" id="cb1-34" title="34"></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="co">// to define a multiline function, just use indents. No semicolons needed.</span></a>
<a class="sourceLine" id="cb1-36" title="36">let evens list =</a>
<a class="sourceLine" id="cb1-37" title="37">   let isEven x = x % <span class="dv">2</span> = <span class="dv">0</span>   <span class="co">// Define &quot;isEven&quot; as a sub function. Note</span></a>
<a class="sourceLine" id="cb1-38" title="38">                              <span class="co">// that equality operator is single char &quot;=&quot;.</span></a>
<a class="sourceLine" id="cb1-39" title="39">   List.<span class="fu">filter</span> isEven list    <span class="co">// List.filter is a library function</span></a>
<a class="sourceLine" id="cb1-40" title="40">                              <span class="co">// with two parameters: a boolean function</span></a>
<a class="sourceLine" id="cb1-41" title="41">                              <span class="co">// and a list to work on</span></a>
<a class="sourceLine" id="cb1-42" title="42"></a>
<a class="sourceLine" id="cb1-43" title="43">evens oneToFive               <span class="co">// Now run the function</span></a>
<a class="sourceLine" id="cb1-44" title="44"></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="co">// You can use parens to clarify precedence. In this example,</span></a>
<a class="sourceLine" id="cb1-46" title="46"><span class="co">// do &quot;map&quot; first, with two args, then do &quot;sum&quot; on the result.</span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">// Without the parens, &quot;List.map&quot; would be passed as an arg to List.sum</span></a>
<a class="sourceLine" id="cb1-48" title="48">let sumOfSquaresTo100 =</a>
<a class="sourceLine" id="cb1-49" title="49">   List.<span class="fu">sum</span> ( List.<span class="fu">map</span> square [<span class="dv">1</span>..<span class="fu">100</span>] )</a>
<a class="sourceLine" id="cb1-50" title="50"></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="co">// You can pipe the output of one operation to the next using &quot;|&gt;&quot;</span></a>
<a class="sourceLine" id="cb1-52" title="52"><span class="co">// Piping data around is very common in F#, similar to UNIX pipes.</span></a>
<a class="sourceLine" id="cb1-53" title="53"></a>
<a class="sourceLine" id="cb1-54" title="54"><span class="co">// Here is the same sumOfSquares function written using pipes</span></a>
<a class="sourceLine" id="cb1-55" title="55">let sumOfSquaresTo100piped =</a>
<a class="sourceLine" id="cb1-56" title="56">   [<span class="dv">1</span>..<span class="fu">100</span>] |&gt; List.<span class="fu">map</span> square |&gt; List.<span class="fu">sum</span>  <span class="co">// &quot;square&quot; was defined earlier</span></a>
<a class="sourceLine" id="cb1-57" title="57"></a>
<a class="sourceLine" id="cb1-58" title="58"><span class="co">// you can define lambdas (anonymous functions) using the &quot;fun&quot; keyword</span></a>
<a class="sourceLine" id="cb1-59" title="59">let sumOfSquaresTo100withFun =</a>
<a class="sourceLine" id="cb1-60" title="60">   [<span class="dv">1</span>..<span class="fu">100</span>] |&gt; List.<span class="fu">map</span> (fun x -&gt; x * x) |&gt; List.<span class="fu">sum</span></a>
<a class="sourceLine" id="cb1-61" title="61"></a>
<a class="sourceLine" id="cb1-62" title="62"><span class="co">// In F# there is no &quot;return&quot; keyword. A function always</span></a>
<a class="sourceLine" id="cb1-63" title="63"><span class="co">// returns the value of the last expression used.</span></a>
<a class="sourceLine" id="cb1-64" title="64"></a>
<a class="sourceLine" id="cb1-65" title="65"><span class="co">// ------ Pattern Matching ------</span></a>
<a class="sourceLine" id="cb1-66" title="66"><span class="co">// Match..with.. is a supercharged case/switch statement.</span></a>
<a class="sourceLine" id="cb1-67" title="67">let simplePatternMatch =</a>
<a class="sourceLine" id="cb1-68" title="68">   let x = <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb1-69" title="69">   match x with</a>
<a class="sourceLine" id="cb1-70" title="70">    | <span class="st">&quot;a&quot;</span> -&gt; printfn <span class="st">&quot;x is a&quot;</span></a>
<a class="sourceLine" id="cb1-71" title="71">    | <span class="st">&quot;b&quot;</span> -&gt; printfn <span class="st">&quot;x is b&quot;</span></a>
<a class="sourceLine" id="cb1-72" title="72">    | _ -&gt; printfn <span class="st">&quot;x is something else&quot;</span>   <span class="co">// underscore matches anything</span></a>
<a class="sourceLine" id="cb1-73" title="73"></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="co">// F# doesn&#39;t allow nulls by default -- you must use an Option type</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">// and then pattern match.</span></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="co">// Some(..) and None are roughly analogous to Nullable wrappers</span></a>
<a class="sourceLine" id="cb1-77" title="77">let validValue = <span class="fu">Some</span>(<span class="dv">99</span>)</a>
<a class="sourceLine" id="cb1-78" title="78">let invalidValue = None</a>
<a class="sourceLine" id="cb1-79" title="79"></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">// In this example, match..with matches the &quot;Some&quot; and the &quot;None&quot;,</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="co">// and also unpacks the value in the &quot;Some&quot; at the same time.</span></a>
<a class="sourceLine" id="cb1-82" title="82">let optionPatternMatch input =</a>
<a class="sourceLine" id="cb1-83" title="83">   match input with</a>
<a class="sourceLine" id="cb1-84" title="84">    | Some i -&gt; printfn <span class="st">&quot;input is an int=%d&quot;</span> i</a>
<a class="sourceLine" id="cb1-85" title="85">    | None -&gt; printfn <span class="st">&quot;input is missing&quot;</span></a>
<a class="sourceLine" id="cb1-86" title="86"></a>
<a class="sourceLine" id="cb1-87" title="87">optionPatternMatch validValue</a>
<a class="sourceLine" id="cb1-88" title="88">optionPatternMatch invalidValue</a>
<a class="sourceLine" id="cb1-89" title="89"></a>
<a class="sourceLine" id="cb1-90" title="90"><span class="co">// ------ Printing ------</span></a>
<a class="sourceLine" id="cb1-91" title="91"><span class="co">// The printf/printfn functions are similar to the</span></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="co">// Console.Write/WriteLine functions in C#.</span></a>
<a class="sourceLine" id="cb1-93" title="93">printfn <span class="st">&quot;Printing an int %i, a float %f, a bool %b&quot;</span> <span class="dv">1</span> <span class="fl">2.0</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-94" title="94">printfn <span class="st">&quot;A string %s, and something generic %A&quot;</span> <span class="st">&quot;hello&quot;</span> [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb1-95" title="95"></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="co">// There are also sprintf/sprintfn functions for formatting data</span></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="co">// into a string, similar to String.Format in C#.</span></a>
<a class="sourceLine" id="cb1-98" title="98"></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-100" title="100"><span class="co">// More on functions</span></a>
<a class="sourceLine" id="cb1-101" title="101"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-102" title="102"></a>
<a class="sourceLine" id="cb1-103" title="103"><span class="co">// F# is a true functional language -- functions are first</span></a>
<a class="sourceLine" id="cb1-104" title="104"><span class="co">// class entities and can be combined easily to make powerful</span></a>
<a class="sourceLine" id="cb1-105" title="105"><span class="co">// constructs</span></a>
<a class="sourceLine" id="cb1-106" title="106"></a>
<a class="sourceLine" id="cb1-107" title="107"><span class="co">// Modules are used to group functions together</span></a>
<a class="sourceLine" id="cb1-108" title="108"><span class="co">// Indentation is needed for each nested module.</span></a>
<a class="sourceLine" id="cb1-109" title="109">module FunctionExamples =</a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111">    <span class="co">// define a simple adding function</span></a>
<a class="sourceLine" id="cb1-112" title="112">    let add x y = x + y</a>
<a class="sourceLine" id="cb1-113" title="113"></a>
<a class="sourceLine" id="cb1-114" title="114">    <span class="co">// basic usage of a function</span></a>
<a class="sourceLine" id="cb1-115" title="115">    let a = add <span class="dv">1</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-116" title="116">    printfn <span class="st">&quot;1 + 2 = %i&quot;</span> a</a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118">    <span class="co">// partial application to &quot;bake in&quot; parameters</span></a>
<a class="sourceLine" id="cb1-119" title="119">    let add42 = add <span class="dv">42</span></a>
<a class="sourceLine" id="cb1-120" title="120">    let b = add42 <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-121" title="121">    printfn <span class="st">&quot;42 + 1 = %i&quot;</span> b</a>
<a class="sourceLine" id="cb1-122" title="122"></a>
<a class="sourceLine" id="cb1-123" title="123">    <span class="co">// composition to combine functions</span></a>
<a class="sourceLine" id="cb1-124" title="124">    let add1 = add <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-125" title="125">    let add2 = add <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-126" title="126">    let add3 = add1 &gt;&gt; add2</a>
<a class="sourceLine" id="cb1-127" title="127">    let c = add3 <span class="dv">7</span></a>
<a class="sourceLine" id="cb1-128" title="128">    printfn <span class="st">&quot;3 + 7 = %i&quot;</span> c</a>
<a class="sourceLine" id="cb1-129" title="129"></a>
<a class="sourceLine" id="cb1-130" title="130">    <span class="co">// higher order functions</span></a>
<a class="sourceLine" id="cb1-131" title="131">    [<span class="dv">1</span>..<span class="fu">10</span>] |&gt; List.<span class="fu">map</span> add3 |&gt; printfn <span class="st">&quot;new list is %A&quot;</span></a>
<a class="sourceLine" id="cb1-132" title="132"></a>
<a class="sourceLine" id="cb1-133" title="133">    <span class="co">// lists of functions, and more</span></a>
<a class="sourceLine" id="cb1-134" title="134">    let add6 = [add1; add2; add3] |&gt; List.<span class="fu">reduce</span> (&gt;&gt;)</a>
<a class="sourceLine" id="cb1-135" title="135">    let d = add6 <span class="dv">7</span></a>
<a class="sourceLine" id="cb1-136" title="136">    printfn <span class="st">&quot;1 + 2 + 3 + 7 = %i&quot;</span> d</a>
<a class="sourceLine" id="cb1-137" title="137"></a>
<a class="sourceLine" id="cb1-138" title="138"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-139" title="139"><span class="co">// Lists and collection</span></a>
<a class="sourceLine" id="cb1-140" title="140"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-141" title="141"></a>
<a class="sourceLine" id="cb1-142" title="142"><span class="co">// There are three types of ordered collection:</span></a>
<a class="sourceLine" id="cb1-143" title="143"><span class="co">// * Lists are most basic immutable collection.</span></a>
<a class="sourceLine" id="cb1-144" title="144"><span class="co">// * Arrays are mutable and more efficient when needed.</span></a>
<a class="sourceLine" id="cb1-145" title="145"><span class="co">// * Sequences are lazy and infinite (e.g. an enumerator).</span></a>
<a class="sourceLine" id="cb1-146" title="146"><span class="co">//</span></a>
<a class="sourceLine" id="cb1-147" title="147"><span class="co">// Other collections include immutable maps and sets</span></a>
<a class="sourceLine" id="cb1-148" title="148"><span class="co">// plus all the standard .NET collections</span></a>
<a class="sourceLine" id="cb1-149" title="149"></a>
<a class="sourceLine" id="cb1-150" title="150">module ListExamples =</a>
<a class="sourceLine" id="cb1-151" title="151"></a>
<a class="sourceLine" id="cb1-152" title="152">    <span class="co">// lists use square brackets</span></a>
<a class="sourceLine" id="cb1-153" title="153">    let list1 = [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>]</a>
<a class="sourceLine" id="cb1-154" title="154">    let list2 = <span class="st">&quot;c&quot;</span> :: list1    <span class="co">// :: is prepending</span></a>
<a class="sourceLine" id="cb1-155" title="155">    let list3 = list1 @ list2   <span class="co">// @ is concat</span></a>
<a class="sourceLine" id="cb1-156" title="156"></a>
<a class="sourceLine" id="cb1-157" title="157">    <span class="co">// list comprehensions (aka generators)</span></a>
<a class="sourceLine" id="cb1-158" title="158">    let squares = [<span class="kw">for</span> i <span class="kw">in</span> <span class="dv">1</span>..<span class="fu">10</span> <span class="kw">do</span> yield i * i]</a>
<a class="sourceLine" id="cb1-159" title="159"></a>
<a class="sourceLine" id="cb1-160" title="160">    <span class="co">// A prime number generator</span></a>
<a class="sourceLine" id="cb1-161" title="161">    <span class="co">// - this is using a short notation for the pattern matching syntax</span></a>
<a class="sourceLine" id="cb1-162" title="162">    <span class="co">// - (p::xs) is &#39;first :: tail&#39; of the list, could also be written as p :: xs</span></a>
<a class="sourceLine" id="cb1-163" title="163">    <span class="co">//   this means this matches &#39;p&#39; (the first item in the list), and xs is the rest of the list</span></a>
<a class="sourceLine" id="cb1-164" title="164">    <span class="co">//   this is called the &#39;cons pattern&#39;</span></a>
<a class="sourceLine" id="cb1-165" title="165">    <span class="co">// - uses &#39;rec&#39; keyword, which is necessary when using recursion</span></a>
<a class="sourceLine" id="cb1-166" title="166">    let rec sieve = function</a>
<a class="sourceLine" id="cb1-167" title="167">        | (p::xs) -&gt; p :: sieve [ <span class="kw">for</span> x <span class="kw">in</span> xs <span class="kw">do</span> <span class="kw">if</span> x % p &gt; <span class="dv">0</span> then yield x ]</a>
<a class="sourceLine" id="cb1-168" title="168">        | []      -&gt; []</a>
<a class="sourceLine" id="cb1-169" title="169">    let primes = sieve [<span class="dv">2</span>..<span class="fu">50</span>]</a>
<a class="sourceLine" id="cb1-170" title="170">    printfn <span class="st">&quot;%A&quot;</span> primes</a>
<a class="sourceLine" id="cb1-171" title="171"></a>
<a class="sourceLine" id="cb1-172" title="172">    <span class="co">// pattern matching for lists</span></a>
<a class="sourceLine" id="cb1-173" title="173">    let listMatcher aList =</a>
<a class="sourceLine" id="cb1-174" title="174">        match aList with</a>
<a class="sourceLine" id="cb1-175" title="175">        | [] -&gt; printfn <span class="st">&quot;the list is empty&quot;</span></a>
<a class="sourceLine" id="cb1-176" title="176">        | [first] -&gt; printfn <span class="st">&quot;the list has one element %A &quot;</span> first</a>
<a class="sourceLine" id="cb1-177" title="177">        | [first; second] -&gt; printfn <span class="st">&quot;list is %A and %A&quot;</span> first second</a>
<a class="sourceLine" id="cb1-178" title="178">        | first :: _ -&gt; printfn <span class="st">&quot;the list has more than two elements, first element %A&quot;</span> first</a>
<a class="sourceLine" id="cb1-179" title="179"></a>
<a class="sourceLine" id="cb1-180" title="180">    listMatcher [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb1-181" title="181">    listMatcher [<span class="dv">1</span>; <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb1-182" title="182">    listMatcher [<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-183" title="183">    listMatcher []</a>
<a class="sourceLine" id="cb1-184" title="184"></a>
<a class="sourceLine" id="cb1-185" title="185">    <span class="co">// recursion using lists</span></a>
<a class="sourceLine" id="cb1-186" title="186">    let rec sum aList =</a>
<a class="sourceLine" id="cb1-187" title="187">        match aList with</a>
<a class="sourceLine" id="cb1-188" title="188">        | [] -&gt; <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-189" title="189">        | x::xs -&gt; x + sum xs</a>
<a class="sourceLine" id="cb1-190" title="190">    sum [<span class="dv">1</span>..<span class="fu">10</span>]</a>
<a class="sourceLine" id="cb1-191" title="191"></a>
<a class="sourceLine" id="cb1-192" title="192">    <span class="co">// -----------------------------------------</span></a>
<a class="sourceLine" id="cb1-193" title="193">    <span class="co">// Standard library functions</span></a>
<a class="sourceLine" id="cb1-194" title="194">    <span class="co">// -----------------------------------------</span></a>
<a class="sourceLine" id="cb1-195" title="195"></a>
<a class="sourceLine" id="cb1-196" title="196">    <span class="co">// map</span></a>
<a class="sourceLine" id="cb1-197" title="197">    let add3 x = x + <span class="dv">3</span></a>
<a class="sourceLine" id="cb1-198" title="198">    [<span class="dv">1</span>..<span class="fu">10</span>] |&gt; List.<span class="fu">map</span> add3</a>
<a class="sourceLine" id="cb1-199" title="199"></a>
<a class="sourceLine" id="cb1-200" title="200">    <span class="co">// filter</span></a>
<a class="sourceLine" id="cb1-201" title="201">    let even x = x % <span class="dv">2</span> = <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-202" title="202">    [<span class="dv">1</span>..<span class="fu">10</span>] |&gt; List.<span class="fu">filter</span> even</a>
<a class="sourceLine" id="cb1-203" title="203"></a>
<a class="sourceLine" id="cb1-204" title="204">    <span class="co">// many more -- see documentation</span></a>
<a class="sourceLine" id="cb1-205" title="205"></a>
<a class="sourceLine" id="cb1-206" title="206">module ArrayExamples =</a>
<a class="sourceLine" id="cb1-207" title="207"></a>
<a class="sourceLine" id="cb1-208" title="208">    <span class="co">// arrays use square brackets with bar</span></a>
<a class="sourceLine" id="cb1-209" title="209">    let array1 = [| <span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span> |]</a>
<a class="sourceLine" id="cb1-210" title="210">    let first = array1.[<span class="dv">0</span>]        <span class="co">// indexed access using dot</span></a>
<a class="sourceLine" id="cb1-211" title="211"></a>
<a class="sourceLine" id="cb1-212" title="212">    <span class="co">// pattern matching for arrays is same as for lists</span></a>
<a class="sourceLine" id="cb1-213" title="213">    let arrayMatcher aList =</a>
<a class="sourceLine" id="cb1-214" title="214">        match aList with</a>
<a class="sourceLine" id="cb1-215" title="215">        | [| |] -&gt; printfn <span class="st">&quot;the array is empty&quot;</span></a>
<a class="sourceLine" id="cb1-216" title="216">        | [| first |] -&gt; printfn <span class="st">&quot;the array has one element %A &quot;</span> first</a>
<a class="sourceLine" id="cb1-217" title="217">        | [| first; second |] -&gt; printfn <span class="st">&quot;array is %A and %A&quot;</span> first second</a>
<a class="sourceLine" id="cb1-218" title="218">        | _ -&gt; printfn <span class="st">&quot;the array has more than two elements&quot;</span></a>
<a class="sourceLine" id="cb1-219" title="219"></a>
<a class="sourceLine" id="cb1-220" title="220">    arrayMatcher [| <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span> |]</a>
<a class="sourceLine" id="cb1-221" title="221"></a>
<a class="sourceLine" id="cb1-222" title="222">    <span class="co">// Standard library functions just as for List</span></a>
<a class="sourceLine" id="cb1-223" title="223"></a>
<a class="sourceLine" id="cb1-224" title="224">    [| <span class="dv">1</span>..<span class="fu">10</span> |]</a>
<a class="sourceLine" id="cb1-225" title="225">    |&gt; Array.<span class="fu">map</span> (fun i -&gt; i + <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-226" title="226">    |&gt; Array.<span class="fu">filter</span> (fun i -&gt; i % <span class="dv">2</span> = <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-227" title="227">    |&gt; Array.<span class="fu">iter</span> (printfn <span class="st">&quot;value is %i. &quot;</span>)</a>
<a class="sourceLine" id="cb1-228" title="228"></a>
<a class="sourceLine" id="cb1-229" title="229"></a>
<a class="sourceLine" id="cb1-230" title="230">module SequenceExamples =</a>
<a class="sourceLine" id="cb1-231" title="231"></a>
<a class="sourceLine" id="cb1-232" title="232">    <span class="co">// sequences use curly braces</span></a>
<a class="sourceLine" id="cb1-233" title="233">    let seq1 = seq { yield <span class="st">&quot;a&quot;</span>; yield <span class="st">&quot;b&quot;</span> }</a>
<a class="sourceLine" id="cb1-234" title="234"></a>
<a class="sourceLine" id="cb1-235" title="235">    <span class="co">// sequences can use yield and</span></a>
<a class="sourceLine" id="cb1-236" title="236">    <span class="co">// can contain subsequences</span></a>
<a class="sourceLine" id="cb1-237" title="237">    let strange = seq {</a>
<a class="sourceLine" id="cb1-238" title="238">        <span class="co">// &quot;yield&quot; adds one element</span></a>
<a class="sourceLine" id="cb1-239" title="239">        yield <span class="dv">1</span>; yield <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-240" title="240"></a>
<a class="sourceLine" id="cb1-241" title="241">        <span class="co">// &quot;yield!&quot; adds a whole subsequence</span></a>
<a class="sourceLine" id="cb1-242" title="242">        yield! [<span class="dv">5</span>..<span class="fu">10</span>]</a>
<a class="sourceLine" id="cb1-243" title="243">        yield! seq {</a>
<a class="sourceLine" id="cb1-244" title="244">            <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">1</span>..<span class="fu">10</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-245" title="245">              <span class="kw">if</span> i % <span class="dv">2</span> = <span class="dv">0</span> then yield i }}</a>
<a class="sourceLine" id="cb1-246" title="246">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-247" title="247">    strange |&gt; Seq.<span class="fu">toList</span></a>
<a class="sourceLine" id="cb1-248" title="248"></a>
<a class="sourceLine" id="cb1-249" title="249"></a>
<a class="sourceLine" id="cb1-250" title="250">    <span class="co">// Sequences can be created using &quot;unfold&quot;</span></a>
<a class="sourceLine" id="cb1-251" title="251">    <span class="co">// Here&#39;s the fibonacci series</span></a>
<a class="sourceLine" id="cb1-252" title="252">    let fib = Seq.<span class="fu">unfold</span> (<span class="fu">fun</span> (fst,snd) -&gt;</a>
<a class="sourceLine" id="cb1-253" title="253">        <span class="fu">Some</span>(fst + snd, (snd, fst + snd))) (<span class="dv">0</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-254" title="254"></a>
<a class="sourceLine" id="cb1-255" title="255">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-256" title="256">    let fib10 = fib |&gt; Seq.<span class="fu">take</span> <span class="dv">10</span> |&gt; Seq.<span class="fu">toList</span></a>
<a class="sourceLine" id="cb1-257" title="257">    printf <span class="st">&quot;first 10 fibs are %A&quot;</span> fib10</a>
<a class="sourceLine" id="cb1-258" title="258"></a>
<a class="sourceLine" id="cb1-259" title="259"></a>
<a class="sourceLine" id="cb1-260" title="260"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-261" title="261"><span class="co">// Data Types</span></a>
<a class="sourceLine" id="cb1-262" title="262"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-263" title="263"></a>
<a class="sourceLine" id="cb1-264" title="264">module DataTypeExamples =</a>
<a class="sourceLine" id="cb1-265" title="265"></a>
<a class="sourceLine" id="cb1-266" title="266">    <span class="co">// All data is immutable by default</span></a>
<a class="sourceLine" id="cb1-267" title="267"></a>
<a class="sourceLine" id="cb1-268" title="268">    <span class="co">// Tuples are quick &#39;n easy anonymous types</span></a>
<a class="sourceLine" id="cb1-269" title="269">    <span class="co">// -- Use a comma to create a tuple</span></a>
<a class="sourceLine" id="cb1-270" title="270">    let twoTuple = <span class="dv">1</span>, <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-271" title="271">    let threeTuple = <span class="st">&quot;a&quot;</span>, <span class="dv">2</span>, <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-272" title="272"></a>
<a class="sourceLine" id="cb1-273" title="273">    <span class="co">// Pattern match to unpack</span></a>
<a class="sourceLine" id="cb1-274" title="274">    let x, y = twoTuple  <span class="co">// sets x = 1, y = 2</span></a>
<a class="sourceLine" id="cb1-275" title="275"></a>
<a class="sourceLine" id="cb1-276" title="276">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-277" title="277">    <span class="co">// Record types have named fields</span></a>
<a class="sourceLine" id="cb1-278" title="278">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-279" title="279"></a>
<a class="sourceLine" id="cb1-280" title="280">    <span class="co">// Use &quot;type&quot; with curly braces to define a record type</span></a>
<a class="sourceLine" id="cb1-281" title="281">    type Person = {First:<span class="dt">string</span>; Last:<span class="dt">string</span>}</a>
<a class="sourceLine" id="cb1-282" title="282"></a>
<a class="sourceLine" id="cb1-283" title="283">    <span class="co">// Use &quot;let&quot; with curly braces to create a record</span></a>
<a class="sourceLine" id="cb1-284" title="284">    let person1 = {First=<span class="st">&quot;John&quot;</span>; Last=<span class="st">&quot;Doe&quot;</span>}</a>
<a class="sourceLine" id="cb1-285" title="285"></a>
<a class="sourceLine" id="cb1-286" title="286">    <span class="co">// Pattern match to unpack</span></a>
<a class="sourceLine" id="cb1-287" title="287">    let {First = first} = person1    <span class="co">// sets first=&quot;John&quot;</span></a>
<a class="sourceLine" id="cb1-288" title="288"></a>
<a class="sourceLine" id="cb1-289" title="289">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-290" title="290">    <span class="co">// Union types (aka variants) have a set of choices</span></a>
<a class="sourceLine" id="cb1-291" title="291">    <span class="co">// Only one case can be valid at a time.</span></a>
<a class="sourceLine" id="cb1-292" title="292">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-293" title="293"></a>
<a class="sourceLine" id="cb1-294" title="294">    <span class="co">// Use &quot;type&quot; with bar/pipe to define a union type</span></a>
<a class="sourceLine" id="cb1-295" title="295">    type Temp =</a>
<a class="sourceLine" id="cb1-296" title="296">        | DegreesC of <span class="dt">float</span></a>
<a class="sourceLine" id="cb1-297" title="297">        | DegreesF of <span class="dt">float</span></a>
<a class="sourceLine" id="cb1-298" title="298"></a>
<a class="sourceLine" id="cb1-299" title="299">    <span class="co">// Use one of the cases to create one</span></a>
<a class="sourceLine" id="cb1-300" title="300">    let temp1 = DegreesF <span class="fl">98.6</span></a>
<a class="sourceLine" id="cb1-301" title="301">    let temp2 = DegreesC <span class="fl">37.0</span></a>
<a class="sourceLine" id="cb1-302" title="302"></a>
<a class="sourceLine" id="cb1-303" title="303">    <span class="co">// Pattern match on all cases to unpack</span></a>
<a class="sourceLine" id="cb1-304" title="304">    let printTemp = function</a>
<a class="sourceLine" id="cb1-305" title="305">       | DegreesC t -&gt; printfn <span class="st">&quot;%f degC&quot;</span> t</a>
<a class="sourceLine" id="cb1-306" title="306">       | DegreesF t -&gt; printfn <span class="st">&quot;%f degF&quot;</span> t</a>
<a class="sourceLine" id="cb1-307" title="307"></a>
<a class="sourceLine" id="cb1-308" title="308">    printTemp temp1</a>
<a class="sourceLine" id="cb1-309" title="309">    printTemp temp2</a>
<a class="sourceLine" id="cb1-310" title="310"></a>
<a class="sourceLine" id="cb1-311" title="311">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-312" title="312">    <span class="co">// Recursive types</span></a>
<a class="sourceLine" id="cb1-313" title="313">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-314" title="314"></a>
<a class="sourceLine" id="cb1-315" title="315">    <span class="co">// Types can be combined recursively in complex ways</span></a>
<a class="sourceLine" id="cb1-316" title="316">    <span class="co">// without having to create subclasses</span></a>
<a class="sourceLine" id="cb1-317" title="317">    type Employee =</a>
<a class="sourceLine" id="cb1-318" title="318">      | Worker of Person</a>
<a class="sourceLine" id="cb1-319" title="319">      | Manager of Employee list</a>
<a class="sourceLine" id="cb1-320" title="320"></a>
<a class="sourceLine" id="cb1-321" title="321">    let jdoe = {First=<span class="st">&quot;John&quot;</span>; Last=<span class="st">&quot;Doe&quot;</span>}</a>
<a class="sourceLine" id="cb1-322" title="322">    let worker = Worker jdoe</a>
<a class="sourceLine" id="cb1-323" title="323"></a>
<a class="sourceLine" id="cb1-324" title="324">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-325" title="325">    <span class="co">// Modeling with types</span></a>
<a class="sourceLine" id="cb1-326" title="326">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-327" title="327"></a>
<a class="sourceLine" id="cb1-328" title="328">    <span class="co">// Union types are great for modeling state without using flags</span></a>
<a class="sourceLine" id="cb1-329" title="329">    type EmailAddress =</a>
<a class="sourceLine" id="cb1-330" title="330">        | ValidEmailAddress of <span class="dt">string</span></a>
<a class="sourceLine" id="cb1-331" title="331">        | InvalidEmailAddress of <span class="dt">string</span></a>
<a class="sourceLine" id="cb1-332" title="332"></a>
<a class="sourceLine" id="cb1-333" title="333">    let trySendEmail email =</a>
<a class="sourceLine" id="cb1-334" title="334">        match email with <span class="co">// use pattern matching</span></a>
<a class="sourceLine" id="cb1-335" title="335">        | ValidEmailAddress address -&gt; ()   <span class="co">// send</span></a>
<a class="sourceLine" id="cb1-336" title="336">        | InvalidEmailAddress address -&gt; () <span class="co">// don&#39;t send</span></a>
<a class="sourceLine" id="cb1-337" title="337"></a>
<a class="sourceLine" id="cb1-338" title="338">    <span class="co">// The combination of union types and record types together</span></a>
<a class="sourceLine" id="cb1-339" title="339">    <span class="co">// provide a great foundation for domain driven design.</span></a>
<a class="sourceLine" id="cb1-340" title="340">    <span class="co">// You can create hundreds of little types that accurately</span></a>
<a class="sourceLine" id="cb1-341" title="341">    <span class="co">// reflect the domain.</span></a>
<a class="sourceLine" id="cb1-342" title="342"></a>
<a class="sourceLine" id="cb1-343" title="343">    type CartItem = { ProductCode: <span class="dt">string</span>; Qty: <span class="dt">int</span> }</a>
<a class="sourceLine" id="cb1-344" title="344">    type Payment = Payment of <span class="dt">float</span></a>
<a class="sourceLine" id="cb1-345" title="345">    type ActiveCartData = { UnpaidItems: CartItem list }</a>
<a class="sourceLine" id="cb1-346" title="346">    type PaidCartData = { PaidItems: CartItem list; Payment: Payment}</a>
<a class="sourceLine" id="cb1-347" title="347"></a>
<a class="sourceLine" id="cb1-348" title="348">    type ShoppingCart =</a>
<a class="sourceLine" id="cb1-349" title="349">        | EmptyCart  <span class="co">// no data</span></a>
<a class="sourceLine" id="cb1-350" title="350">        | ActiveCart of ActiveCartData</a>
<a class="sourceLine" id="cb1-351" title="351">        | PaidCart of PaidCartData</a>
<a class="sourceLine" id="cb1-352" title="352"></a>
<a class="sourceLine" id="cb1-353" title="353">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-354" title="354">    <span class="co">// Built in behavior for types</span></a>
<a class="sourceLine" id="cb1-355" title="355">    <span class="co">// ------------------------------------</span></a>
<a class="sourceLine" id="cb1-356" title="356"></a>
<a class="sourceLine" id="cb1-357" title="357">    <span class="co">// Core types have useful &quot;out-of-the-box&quot; behavior, no coding needed.</span></a>
<a class="sourceLine" id="cb1-358" title="358">    <span class="co">// * Immutability</span></a>
<a class="sourceLine" id="cb1-359" title="359">    <span class="co">// * Pretty printing when debugging</span></a>
<a class="sourceLine" id="cb1-360" title="360">    <span class="co">// * Equality and comparison</span></a>
<a class="sourceLine" id="cb1-361" title="361">    <span class="co">// * Serialization</span></a>
<a class="sourceLine" id="cb1-362" title="362"></a>
<a class="sourceLine" id="cb1-363" title="363">    <span class="co">// Pretty printing using %A</span></a>
<a class="sourceLine" id="cb1-364" title="364">    printfn <span class="st">&quot;twoTuple=%A,</span><span class="sc">\n</span><span class="st">Person=%A,</span><span class="sc">\n</span><span class="st">Temp=%A,</span><span class="sc">\n</span><span class="st">Employee=%A&quot;</span></a>
<a class="sourceLine" id="cb1-365" title="365">             twoTuple person1 temp1 worker</a>
<a class="sourceLine" id="cb1-366" title="366"></a>
<a class="sourceLine" id="cb1-367" title="367">    <span class="co">// Equality and comparison built in.</span></a>
<a class="sourceLine" id="cb1-368" title="368">    <span class="co">// Here&#39;s an example with cards.</span></a>
<a class="sourceLine" id="cb1-369" title="369">    type Suit = Club | Diamond | Spade | Heart</a>
<a class="sourceLine" id="cb1-370" title="370">    type Rank = Two | Three | Four | Five | Six | Seven | Eight</a>
<a class="sourceLine" id="cb1-371" title="371">                | Nine | Ten | Jack | Queen | King | Ace</a>
<a class="sourceLine" id="cb1-372" title="372"></a>
<a class="sourceLine" id="cb1-373" title="373">    let hand = [ Club, Ace; Heart, Three; Heart, Ace;</a>
<a class="sourceLine" id="cb1-374" title="374">                 Spade, Jack; Diamond, Two; Diamond, Ace ]</a>
<a class="sourceLine" id="cb1-375" title="375"></a>
<a class="sourceLine" id="cb1-376" title="376">    <span class="co">// sorting</span></a>
<a class="sourceLine" id="cb1-377" title="377">    List.<span class="fu">sort</span> hand |&gt; printfn <span class="st">&quot;sorted hand is (low to high) %A&quot;</span></a>
<a class="sourceLine" id="cb1-378" title="378">    List.<span class="fu">max</span> hand |&gt; printfn <span class="st">&quot;high card is %A&quot;</span></a>
<a class="sourceLine" id="cb1-379" title="379">    List.<span class="fu">min</span> hand |&gt; printfn <span class="st">&quot;low card is %A&quot;</span></a>
<a class="sourceLine" id="cb1-380" title="380"></a>
<a class="sourceLine" id="cb1-381" title="381"></a>
<a class="sourceLine" id="cb1-382" title="382"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-383" title="383"><span class="co">// Active patterns</span></a>
<a class="sourceLine" id="cb1-384" title="384"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-385" title="385"></a>
<a class="sourceLine" id="cb1-386" title="386">module ActivePatternExamples =</a>
<a class="sourceLine" id="cb1-387" title="387"></a>
<a class="sourceLine" id="cb1-388" title="388">    <span class="co">// F# has a special type of pattern matching called &quot;active patterns&quot;</span></a>
<a class="sourceLine" id="cb1-389" title="389">    <span class="co">// where the pattern can be parsed or detected dynamically.</span></a>
<a class="sourceLine" id="cb1-390" title="390"></a>
<a class="sourceLine" id="cb1-391" title="391">    <span class="co">// &quot;banana clips&quot; are the syntax for active patterns</span></a>
<a class="sourceLine" id="cb1-392" title="392"></a>
<a class="sourceLine" id="cb1-393" title="393">    <span class="co">// You can use &quot;elif&quot; instead of &quot;else if&quot; in conditional expressions.</span></a>
<a class="sourceLine" id="cb1-394" title="394">    <span class="co">// They are equivalent in F#</span></a>
<a class="sourceLine" id="cb1-395" title="395"></a>
<a class="sourceLine" id="cb1-396" title="396">    <span class="co">// for example, define an &quot;active&quot; pattern to match character types...</span></a>
<a class="sourceLine" id="cb1-397" title="397">    <span class="fu">let</span> (|Digit|Letter|Whitespace|Other|) ch =</a>
<a class="sourceLine" id="cb1-398" title="398">       <span class="kw">if</span> System.<span class="fu">Char</span>.<span class="fu">IsDigit</span>(ch) then Digit</a>
<a class="sourceLine" id="cb1-399" title="399">       elif System.<span class="fu">Char</span>.<span class="fu">IsLetter</span>(ch) then Letter</a>
<a class="sourceLine" id="cb1-400" title="400">       elif System.<span class="fu">Char</span>.<span class="fu">IsWhiteSpace</span>(ch) then Whitespace</a>
<a class="sourceLine" id="cb1-401" title="401">       <span class="kw">else</span> Other</a>
<a class="sourceLine" id="cb1-402" title="402"></a>
<a class="sourceLine" id="cb1-403" title="403">    <span class="co">// ... and then use it to make parsing logic much clearer</span></a>
<a class="sourceLine" id="cb1-404" title="404">    let printChar ch =</a>
<a class="sourceLine" id="cb1-405" title="405">      match ch with</a>
<a class="sourceLine" id="cb1-406" title="406">      | Digit -&gt; printfn <span class="st">&quot;%c is a Digit&quot;</span> ch</a>
<a class="sourceLine" id="cb1-407" title="407">      | Letter -&gt; printfn <span class="st">&quot;%c is a Letter&quot;</span> ch</a>
<a class="sourceLine" id="cb1-408" title="408">      | Whitespace -&gt; printfn <span class="st">&quot;%c is a Whitespace&quot;</span> ch</a>
<a class="sourceLine" id="cb1-409" title="409">      | _ -&gt; printfn <span class="st">&quot;%c is something else&quot;</span> ch</a>
<a class="sourceLine" id="cb1-410" title="410"></a>
<a class="sourceLine" id="cb1-411" title="411">    <span class="co">// print a list</span></a>
<a class="sourceLine" id="cb1-412" title="412">    [<span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;1&#39;</span>; <span class="ch">&#39; &#39;</span>; <span class="ch">&#39;-&#39;</span>; <span class="ch">&#39;c&#39;</span>] |&gt; List.<span class="fu">iter</span> printChar</a>
<a class="sourceLine" id="cb1-413" title="413"></a>
<a class="sourceLine" id="cb1-414" title="414">    <span class="co">// -----------------------------------</span></a>
<a class="sourceLine" id="cb1-415" title="415">    <span class="co">// FizzBuzz using active patterns</span></a>
<a class="sourceLine" id="cb1-416" title="416">    <span class="co">// -----------------------------------</span></a>
<a class="sourceLine" id="cb1-417" title="417"></a>
<a class="sourceLine" id="cb1-418" title="418">    <span class="co">// You can create partial matching patterns as well</span></a>
<a class="sourceLine" id="cb1-419" title="419">    <span class="co">// Just use underscore in the definition, and return Some if matched.</span></a>
<a class="sourceLine" id="cb1-420" title="420">    <span class="fu">let</span> (|MultOf3|_|) i = <span class="kw">if</span> i % <span class="dv">3</span> = <span class="dv">0</span> then Some MultOf3 <span class="kw">else</span> None</a>
<a class="sourceLine" id="cb1-421" title="421">    <span class="fu">let</span> (|MultOf5|_|) i = <span class="kw">if</span> i % <span class="dv">5</span> = <span class="dv">0</span> then Some MultOf5 <span class="kw">else</span> None</a>
<a class="sourceLine" id="cb1-422" title="422"></a>
<a class="sourceLine" id="cb1-423" title="423">    <span class="co">// the main function</span></a>
<a class="sourceLine" id="cb1-424" title="424">    let fizzBuzz i =</a>
<a class="sourceLine" id="cb1-425" title="425">      match i with</a>
<a class="sourceLine" id="cb1-426" title="426">      | MultOf3 &amp; MultOf5 -&gt; printf <span class="st">&quot;FizzBuzz, &quot;</span></a>
<a class="sourceLine" id="cb1-427" title="427">      | MultOf3 -&gt; printf <span class="st">&quot;Fizz, &quot;</span></a>
<a class="sourceLine" id="cb1-428" title="428">      | MultOf5 -&gt; printf <span class="st">&quot;Buzz, &quot;</span></a>
<a class="sourceLine" id="cb1-429" title="429">      | _ -&gt; printf <span class="st">&quot;%i, &quot;</span> i</a>
<a class="sourceLine" id="cb1-430" title="430"></a>
<a class="sourceLine" id="cb1-431" title="431">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-432" title="432">    [<span class="dv">1</span>..<span class="fu">20</span>] |&gt; List.<span class="fu">iter</span> fizzBuzz</a>
<a class="sourceLine" id="cb1-433" title="433"></a>
<a class="sourceLine" id="cb1-434" title="434"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-435" title="435"><span class="co">// Conciseness</span></a>
<a class="sourceLine" id="cb1-436" title="436"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-437" title="437"></a>
<a class="sourceLine" id="cb1-438" title="438">module AlgorithmExamples =</a>
<a class="sourceLine" id="cb1-439" title="439"></a>
<a class="sourceLine" id="cb1-440" title="440">    <span class="co">// F# has a high signal/noise ratio, so code reads</span></a>
<a class="sourceLine" id="cb1-441" title="441">    <span class="co">// almost like the actual algorithm</span></a>
<a class="sourceLine" id="cb1-442" title="442"></a>
<a class="sourceLine" id="cb1-443" title="443">    <span class="co">// ------ Example: define sumOfSquares function ------</span></a>
<a class="sourceLine" id="cb1-444" title="444">    let sumOfSquares n =</a>
<a class="sourceLine" id="cb1-445" title="445">       [<span class="dv">1</span>..<span class="fu">n</span>]              <span class="co">// 1) take all the numbers from 1 to n</span></a>
<a class="sourceLine" id="cb1-446" title="446">       |&gt; List.<span class="fu">map</span> square  <span class="co">// 2) square each one</span></a>
<a class="sourceLine" id="cb1-447" title="447">       |&gt; List.<span class="fu">sum</span>         <span class="co">// 3) sum the results</span></a>
<a class="sourceLine" id="cb1-448" title="448"></a>
<a class="sourceLine" id="cb1-449" title="449">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-450" title="450">    sumOfSquares <span class="dv">100</span> |&gt; printfn <span class="st">&quot;Sum of squares = %A&quot;</span></a>
<a class="sourceLine" id="cb1-451" title="451"></a>
<a class="sourceLine" id="cb1-452" title="452">    <span class="co">// ------ Example: define a sort function ------</span></a>
<a class="sourceLine" id="cb1-453" title="453">    let rec sort list =</a>
<a class="sourceLine" id="cb1-454" title="454">       match list with</a>
<a class="sourceLine" id="cb1-455" title="455">       <span class="co">// If the list is empty</span></a>
<a class="sourceLine" id="cb1-456" title="456">       | [] -&gt;</a>
<a class="sourceLine" id="cb1-457" title="457">            []                            <span class="co">// return an empty list</span></a>
<a class="sourceLine" id="cb1-458" title="458">       <span class="co">// If the list is not empty</span></a>
<a class="sourceLine" id="cb1-459" title="459">       | firstElem::otherElements -&gt;      <span class="co">// take the first element</span></a>
<a class="sourceLine" id="cb1-460" title="460">            let smallerElements =         <span class="co">// extract the smaller elements</span></a>
<a class="sourceLine" id="cb1-461" title="461">                otherElements             <span class="co">// from the remaining ones</span></a>
<a class="sourceLine" id="cb1-462" title="462">                |&gt; List.<span class="fu">filter</span> (fun e -&gt; e &lt; firstElem)</a>
<a class="sourceLine" id="cb1-463" title="463">                |&gt; sort                   <span class="co">// and sort them</span></a>
<a class="sourceLine" id="cb1-464" title="464">            let largerElements =          <span class="co">// extract the larger ones</span></a>
<a class="sourceLine" id="cb1-465" title="465">                otherElements             <span class="co">// from the remaining ones</span></a>
<a class="sourceLine" id="cb1-466" title="466">                |&gt; List.<span class="fu">filter</span> (fun e -&gt; e &gt;= firstElem)</a>
<a class="sourceLine" id="cb1-467" title="467">                |&gt; sort                   <span class="co">// and sort them</span></a>
<a class="sourceLine" id="cb1-468" title="468">            <span class="co">// Combine the 3 parts into a new list and return it</span></a>
<a class="sourceLine" id="cb1-469" title="469">            List.<span class="fu">concat</span> [smallerElements; [firstElem]; largerElements]</a>
<a class="sourceLine" id="cb1-470" title="470"></a>
<a class="sourceLine" id="cb1-471" title="471">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-472" title="472">    sort [<span class="dv">1</span>; <span class="dv">5</span>; <span class="dv">23</span>; <span class="dv">18</span>; <span class="dv">9</span>; <span class="dv">1</span>; <span class="dv">3</span>] |&gt; printfn <span class="st">&quot;Sorted = %A&quot;</span></a>
<a class="sourceLine" id="cb1-473" title="473"></a>
<a class="sourceLine" id="cb1-474" title="474"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-475" title="475"><span class="co">// Asynchronous Code</span></a>
<a class="sourceLine" id="cb1-476" title="476"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-477" title="477"></a>
<a class="sourceLine" id="cb1-478" title="478">module AsyncExample =</a>
<a class="sourceLine" id="cb1-479" title="479"></a>
<a class="sourceLine" id="cb1-480" title="480">    <span class="co">// F# has built-in features to help with async code</span></a>
<a class="sourceLine" id="cb1-481" title="481">    <span class="co">// without encountering the &quot;pyramid of doom&quot;</span></a>
<a class="sourceLine" id="cb1-482" title="482">    <span class="co">//</span></a>
<a class="sourceLine" id="cb1-483" title="483">    <span class="co">// The following example downloads a set of web pages in parallel.</span></a>
<a class="sourceLine" id="cb1-484" title="484"></a>
<a class="sourceLine" id="cb1-485" title="485">    open System.<span class="fu">Net</span></a>
<a class="sourceLine" id="cb1-486" title="486">    open System</a>
<a class="sourceLine" id="cb1-487" title="487">    open System.<span class="fu">IO</span></a>
<a class="sourceLine" id="cb1-488" title="488">    open Microsoft.<span class="fu">FSharp</span>.<span class="fu">Control</span>.<span class="fu">CommonExtensions</span></a>
<a class="sourceLine" id="cb1-489" title="489"></a>
<a class="sourceLine" id="cb1-490" title="490">    <span class="co">// Fetch the contents of a URL asynchronously</span></a>
<a class="sourceLine" id="cb1-491" title="491">    let fetchUrlAsync url =</a>
<a class="sourceLine" id="cb1-492" title="492">        async {   <span class="co">// &quot;async&quot; keyword and curly braces</span></a>
<a class="sourceLine" id="cb1-493" title="493">                  <span class="co">// creates an &quot;async&quot; object</span></a>
<a class="sourceLine" id="cb1-494" title="494">            let req = WebRequest.<span class="fu">Create</span>(<span class="fu">Uri</span>(url))</a>
<a class="sourceLine" id="cb1-495" title="495">            use! resp = req.<span class="fu">AsyncGetResponse</span>()</a>
<a class="sourceLine" id="cb1-496" title="496">                <span class="co">// use! is async assignment</span></a>
<a class="sourceLine" id="cb1-497" title="497">            use stream = resp.<span class="fu">GetResponseStream</span>()</a>
<a class="sourceLine" id="cb1-498" title="498">                <span class="co">// &quot;use&quot; triggers automatic close()</span></a>
<a class="sourceLine" id="cb1-499" title="499">                <span class="co">// on resource at end of scope</span></a>
<a class="sourceLine" id="cb1-500" title="500">            use reader = <span class="kw">new</span> IO.<span class="fu">StreamReader</span>(stream)</a>
<a class="sourceLine" id="cb1-501" title="501">            let html = reader.<span class="fu">ReadToEnd</span>()</a>
<a class="sourceLine" id="cb1-502" title="502">            printfn <span class="st">&quot;finished downloading %s&quot;</span> url</a>
<a class="sourceLine" id="cb1-503" title="503">            }</a>
<a class="sourceLine" id="cb1-504" title="504"></a>
<a class="sourceLine" id="cb1-505" title="505">    <span class="co">// a list of sites to fetch</span></a>
<a class="sourceLine" id="cb1-506" title="506">    let sites = [<span class="st">&quot;http://www.bing.com&quot;</span>;</a>
<a class="sourceLine" id="cb1-507" title="507">                 <span class="st">&quot;http://www.google.com&quot;</span>;</a>
<a class="sourceLine" id="cb1-508" title="508">                 <span class="st">&quot;http://www.microsoft.com&quot;</span>;</a>
<a class="sourceLine" id="cb1-509" title="509">                 <span class="st">&quot;http://www.amazon.com&quot;</span>;</a>
<a class="sourceLine" id="cb1-510" title="510">                 <span class="st">&quot;http://www.yahoo.com&quot;</span>]</a>
<a class="sourceLine" id="cb1-511" title="511"></a>
<a class="sourceLine" id="cb1-512" title="512">    <span class="co">// do it</span></a>
<a class="sourceLine" id="cb1-513" title="513">    sites</a>
<a class="sourceLine" id="cb1-514" title="514">    |&gt; List.<span class="fu">map</span> fetchUrlAsync  <span class="co">// make a list of async tasks</span></a>
<a class="sourceLine" id="cb1-515" title="515">    |&gt; Async.<span class="fu">Parallel</span>          <span class="co">// set up the tasks to run in parallel</span></a>
<a class="sourceLine" id="cb1-516" title="516">    |&gt; Async.<span class="fu">RunSynchronously</span>  <span class="co">// start them off</span></a>
<a class="sourceLine" id="cb1-517" title="517"></a>
<a class="sourceLine" id="cb1-518" title="518"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-519" title="519"><span class="co">// .NET compatibility</span></a>
<a class="sourceLine" id="cb1-520" title="520"><span class="co">// ================================================</span></a>
<a class="sourceLine" id="cb1-521" title="521"></a>
<a class="sourceLine" id="cb1-522" title="522">module NetCompatibilityExamples =</a>
<a class="sourceLine" id="cb1-523" title="523"></a>
<a class="sourceLine" id="cb1-524" title="524">    <span class="co">// F# can do almost everything C# can do, and it integrates</span></a>
<a class="sourceLine" id="cb1-525" title="525">    <span class="co">// seamlessly with .NET or Mono libraries.</span></a>
<a class="sourceLine" id="cb1-526" title="526"></a>
<a class="sourceLine" id="cb1-527" title="527">    <span class="co">// ------- work with existing library functions  -------</span></a>
<a class="sourceLine" id="cb1-528" title="528"></a>
<a class="sourceLine" id="cb1-529" title="529">    <span class="fu">let</span> (i1success, i1) = System.<span class="fu">Int32</span>.<span class="fu">TryParse</span>(<span class="st">&quot;123&quot;</span>);</a>
<a class="sourceLine" id="cb1-530" title="530">    <span class="kw">if</span> i1success then printfn <span class="st">&quot;parsed as %i&quot;</span> i1 <span class="kw">else</span> printfn <span class="st">&quot;parse failed&quot;</span></a>
<a class="sourceLine" id="cb1-531" title="531"></a>
<a class="sourceLine" id="cb1-532" title="532">    <span class="co">// ------- Implement interfaces on the fly! -------</span></a>
<a class="sourceLine" id="cb1-533" title="533"></a>
<a class="sourceLine" id="cb1-534" title="534">    <span class="co">// create a new object that implements IDisposable</span></a>
<a class="sourceLine" id="cb1-535" title="535">    let makeResource name =</a>
<a class="sourceLine" id="cb1-536" title="536">       { <span class="kw">new</span> System.<span class="fu">IDisposable</span></a>
<a class="sourceLine" id="cb1-537" title="537">         with member <span class="kw">this</span>.<span class="fu">Dispose</span>() = printfn <span class="st">&quot;%s disposed&quot;</span> name }</a>
<a class="sourceLine" id="cb1-538" title="538"></a>
<a class="sourceLine" id="cb1-539" title="539">    let useAndDisposeResources =</a>
<a class="sourceLine" id="cb1-540" title="540">        use r1 = makeResource <span class="st">&quot;first resource&quot;</span></a>
<a class="sourceLine" id="cb1-541" title="541">        printfn <span class="st">&quot;using first resource&quot;</span></a>
<a class="sourceLine" id="cb1-542" title="542">        <span class="kw">for</span> i <span class="kw">in</span> [<span class="dv">1</span>..<span class="fu">3</span>] <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-543" title="543">            let resourceName = sprintf <span class="st">&quot;</span><span class="sc">\t</span><span class="st">inner resource %d&quot;</span> i</a>
<a class="sourceLine" id="cb1-544" title="544">            use temp = makeResource resourceName</a>
<a class="sourceLine" id="cb1-545" title="545">            printfn <span class="st">&quot;</span><span class="sc">\t</span><span class="st">do something with %s&quot;</span> resourceName</a>
<a class="sourceLine" id="cb1-546" title="546">        use r2 = makeResource <span class="st">&quot;second resource&quot;</span></a>
<a class="sourceLine" id="cb1-547" title="547">        printfn <span class="st">&quot;using second resource&quot;</span></a>
<a class="sourceLine" id="cb1-548" title="548">        printfn <span class="st">&quot;done.&quot;</span></a>
<a class="sourceLine" id="cb1-549" title="549"></a>
<a class="sourceLine" id="cb1-550" title="550">    <span class="co">// ------- Object oriented code -------</span></a>
<a class="sourceLine" id="cb1-551" title="551"></a>
<a class="sourceLine" id="cb1-552" title="552">    <span class="co">// F# is also a fully fledged OO language.</span></a>
<a class="sourceLine" id="cb1-553" title="553">    <span class="co">// It supports classes, inheritance, virtual methods, etc.</span></a>
<a class="sourceLine" id="cb1-554" title="554"></a>
<a class="sourceLine" id="cb1-555" title="555">    <span class="co">// interface with generic type</span></a>
<a class="sourceLine" id="cb1-556" title="556">    type IEnumerator&lt;&#39;a&gt; =</a>
<a class="sourceLine" id="cb1-557" title="557">        <span class="kw">abstract</span> member Current : &#39;a</a>
<a class="sourceLine" id="cb1-558" title="558">        <span class="kw">abstract</span> MoveNext : unit -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb1-559" title="559"></a>
<a class="sourceLine" id="cb1-560" title="560">    <span class="co">// abstract base class with virtual methods</span></a>
<a class="sourceLine" id="cb1-561" title="561">    [&lt;AbstractClass&gt;]</a>
<a class="sourceLine" id="cb1-562" title="562">    type <span class="fu">Shape</span>() =</a>
<a class="sourceLine" id="cb1-563" title="563">        <span class="co">// readonly properties</span></a>
<a class="sourceLine" id="cb1-564" title="564">        <span class="kw">abstract</span> member Width : <span class="dt">int</span> with get</a>
<a class="sourceLine" id="cb1-565" title="565">        <span class="kw">abstract</span> member Height : <span class="dt">int</span> with get</a>
<a class="sourceLine" id="cb1-566" title="566">        <span class="co">// non-virtual method</span></a>
<a class="sourceLine" id="cb1-567" title="567">        member <span class="kw">this</span>.<span class="fu">BoundingArea</span> = <span class="kw">this</span>.<span class="fu">Height</span> * <span class="kw">this</span>.<span class="fu">Width</span></a>
<a class="sourceLine" id="cb1-568" title="568">        <span class="co">// virtual method with base implementation</span></a>
<a class="sourceLine" id="cb1-569" title="569">        <span class="kw">abstract</span> member Print : unit -&gt; unit</a>
<a class="sourceLine" id="cb1-570" title="570">        <span class="kw">default</span> <span class="kw">this</span>.<span class="fu">Print</span> () = printfn <span class="st">&quot;I&#39;m a shape&quot;</span></a>
<a class="sourceLine" id="cb1-571" title="571"></a>
<a class="sourceLine" id="cb1-572" title="572">    <span class="co">// concrete class that inherits from base class and overrides</span></a>
<a class="sourceLine" id="cb1-573" title="573">    type <span class="fu">Rectangle</span>(x:<span class="dt">int</span>, y:<span class="dt">int</span>) =</a>
<a class="sourceLine" id="cb1-574" title="574">        inherit <span class="fu">Shape</span>()</a>
<a class="sourceLine" id="cb1-575" title="575">        <span class="kw">override</span> <span class="kw">this</span>.<span class="fu">Width</span> = x</a>
<a class="sourceLine" id="cb1-576" title="576">        <span class="kw">override</span> <span class="kw">this</span>.<span class="fu">Height</span> = y</a>
<a class="sourceLine" id="cb1-577" title="577">        <span class="kw">override</span> <span class="kw">this</span>.<span class="fu">Print</span> ()  = printfn <span class="st">&quot;I&#39;m a Rectangle&quot;</span></a>
<a class="sourceLine" id="cb1-578" title="578"></a>
<a class="sourceLine" id="cb1-579" title="579">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-580" title="580">    let r = <span class="fu">Rectangle</span>(<span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-581" title="581">    printfn <span class="st">&quot;The width is %i&quot;</span> r.<span class="fu">Width</span></a>
<a class="sourceLine" id="cb1-582" title="582">    printfn <span class="st">&quot;The area is %i&quot;</span> r.<span class="fu">BoundingArea</span></a>
<a class="sourceLine" id="cb1-583" title="583">    r.<span class="fu">Print</span>()</a>
<a class="sourceLine" id="cb1-584" title="584"></a>
<a class="sourceLine" id="cb1-585" title="585">    <span class="co">// ------- extension methods  -------</span></a>
<a class="sourceLine" id="cb1-586" title="586"></a>
<a class="sourceLine" id="cb1-587" title="587">    <span class="co">// Just as in C#, F# can extend existing classes with extension methods.</span></a>
<a class="sourceLine" id="cb1-588" title="588">    type System.<span class="fu">String</span> with</a>
<a class="sourceLine" id="cb1-589" title="589">       member <span class="kw">this</span>.<span class="fu">StartsWithA</span> = <span class="kw">this</span>.<span class="fu">StartsWith</span> <span class="st">&quot;A&quot;</span></a>
<a class="sourceLine" id="cb1-590" title="590"></a>
<a class="sourceLine" id="cb1-591" title="591">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-592" title="592">    let s = <span class="st">&quot;Alice&quot;</span></a>
<a class="sourceLine" id="cb1-593" title="593">    printfn <span class="st">&quot;&#39;%s&#39; starts with an &#39;A&#39; = %A&quot;</span> s s.<span class="fu">StartsWithA</span></a>
<a class="sourceLine" id="cb1-594" title="594"></a>
<a class="sourceLine" id="cb1-595" title="595">    <span class="co">// ------- events  -------</span></a>
<a class="sourceLine" id="cb1-596" title="596"></a>
<a class="sourceLine" id="cb1-597" title="597">    type <span class="fu">MyButton</span>() =</a>
<a class="sourceLine" id="cb1-598" title="598">        let clickEvent = <span class="kw">new</span> Event&lt;_&gt;()</a>
<a class="sourceLine" id="cb1-599" title="599"></a>
<a class="sourceLine" id="cb1-600" title="600">        [&lt;CLIEvent&gt;]</a>
<a class="sourceLine" id="cb1-601" title="601">        member <span class="kw">this</span>.<span class="fu">OnClick</span> = clickEvent.<span class="fu">Publish</span></a>
<a class="sourceLine" id="cb1-602" title="602"></a>
<a class="sourceLine" id="cb1-603" title="603">        member <span class="kw">this</span>.<span class="fu">TestEvent</span>(arg) =</a>
<a class="sourceLine" id="cb1-604" title="604">            clickEvent.<span class="fu">Trigger</span>(<span class="kw">this</span>, arg)</a>
<a class="sourceLine" id="cb1-605" title="605"></a>
<a class="sourceLine" id="cb1-606" title="606">    <span class="co">// test</span></a>
<a class="sourceLine" id="cb1-607" title="607">    let myButton = <span class="kw">new</span> <span class="fu">MyButton</span>()</a>
<a class="sourceLine" id="cb1-608" title="608">    myButton.<span class="fu">OnClick</span>.<span class="fu">Add</span>(<span class="fu">fun</span> (sender, arg) -&gt;</a>
<a class="sourceLine" id="cb1-609" title="609">            printfn <span class="st">&quot;Click event with arg=%O&quot;</span> arg)</a>
<a class="sourceLine" id="cb1-610" title="610"></a>
<a class="sourceLine" id="cb1-611" title="611">    myButton.<span class="fu">TestEvent</span>(<span class="st">&quot;Hello World!&quot;</span>)</a></code></pre>
    </div>
    <h2 id="more-information">More Information</h2>
    <p>
      For more demonstrations of F#, go to my
      <a href="http://fsharpforfunandprofit.com/why-use-fsharp/">why use F#</a>
      series.
    </p>
    <p>
      Read more about F# at <a href="http://fsharp.org/">fsharp.org</a> and
      <a href="https://dotnet.microsoft.com/languages/fsharp"
        >dotnetâ€™s F# page</a
      >.
    </p>
  </body>
</html>
