<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>ocaml.html</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <p>
      OCaml is a strictly evaluated functional language with some imperative
      features.
    </p>
    <p>
      Along with StandardML and its dialects it belongs to ML language family.
      F# is also heavily influenced by OCaml.
    </p>
    <p>
      Just like StandardML, OCaml features both an interpreter, that can be used
      interactively, and a compiler. The interpreter binary is normally called
      “ocaml” and the compiler is “ocamlopt”. There is also a bytecode compiler,
      “ocamlc”, but there are few reasons to use it.
    </p>
    <p>
      It is strongly and statically typed, but instead of using manually written
      type annotations, it infers types of expressions using Hindley-Milner
      algorithm. It makes type annotations unnecessary in most cases, but can be
      a major source of confusion for beginners.
    </p>
    <p>
      When you are in the top level loop, OCaml will print the inferred type
      after you enter an expression.
    </p>
    <pre><code># let inc x = x + 1 ;;
val inc : int -&gt; int = &lt;fun&gt;
# let a = 99 ;;
val a : int = 99</code></pre>
    <p>
      For a source file you can use “ocamlc -i /path/to/file.ml” command to
      print all names and type signatures.
    </p>
    <pre><code>$ cat sigtest.ml
let inc x = x + 1
let add x y = x + y

let a = 1

$ ocamlc -i ./sigtest.ml
val inc : int -&gt; int
val add : int -&gt; int -&gt; int
val a : int</code></pre>
    <p>
      Note that type signatures of functions of multiple arguments are written
      in curried form. A function that takes multiple arguments can be
      represented as a composition of functions that take only one argument. The
      “f(x,y) = x + y” function from the example above applied to arguments 2
      and 3 is equivalent to the “f0(y) = 2 + y” function applied to 3. Hence
      the “int -&gt; int -&gt; int” signature.
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode ocaml"
      ><code class="sourceCode ocaml"><a class="sourceLine" id="cb3-1" title="1"><span class="co">(*** Comments ***)</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">(* Comments are enclosed in (* and *). It&#39;s fine to nest comments. *)</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">(* There are no single-line comments. *)</span></a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">(*** Variables and functions ***)</span></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="co">(* Expressions can be separated by a double semicolon symbol, &quot;;;&quot;.</span></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="co">   In many cases it&#39;s redundant, but in this tutorial we use it after</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="co">   every expression for easy pasting into the interpreter shell.</span></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="co">   Unnecessary use of expression separators in source code files</span></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="co">   is often considered to be a bad style. *)</span></a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16"><span class="co">(* Variable and function declarations use &quot;let&quot; keyword. *)</span></a>
<a class="sourceLine" id="cb3-17" title="17"><span class="kw">let</span> x = <span class="dv">10</span> ;;</a>
<a class="sourceLine" id="cb3-18" title="18"></a>
<a class="sourceLine" id="cb3-19" title="19"><span class="co">(* OCaml allows single quote characters in identifiers.</span></a>
<a class="sourceLine" id="cb3-20" title="20"><span class="co">   Single quote doesn&#39;t have a special meaning in this case, it&#39;s often used</span></a>
<a class="sourceLine" id="cb3-21" title="21"><span class="co">   in cases when in other languages one would use names like &quot;foo_tmp&quot;. *)</span></a>
<a class="sourceLine" id="cb3-22" title="22"><span class="kw">let</span> foo = <span class="dv">1</span> ;;</a>
<a class="sourceLine" id="cb3-23" title="23"><span class="kw">let</span> foo&#39; = foo * <span class="dv">2</span> ;;</a>
<a class="sourceLine" id="cb3-24" title="24"></a>
<a class="sourceLine" id="cb3-25" title="25"><span class="co">(* Since OCaml compiler infers types automatically, you normally don&#39;t need to</span></a>
<a class="sourceLine" id="cb3-26" title="26"><span class="co">   specify argument types explicitly. However, you can do it if</span></a>
<a class="sourceLine" id="cb3-27" title="27"><span class="co">   you want or need to. *)</span></a>
<a class="sourceLine" id="cb3-28" title="28"><span class="kw">let</span> inc_int (x: <span class="dt">int</span>) : <span class="dt">int</span> = x + <span class="dv">1</span> ;;</a>
<a class="sourceLine" id="cb3-29" title="29"></a>
<a class="sourceLine" id="cb3-30" title="30"><span class="co">(* One of the cases when explicit type annotations may be needed is</span></a>
<a class="sourceLine" id="cb3-31" title="31"><span class="co">   resolving ambiguity between two record types that have fields with</span></a>
<a class="sourceLine" id="cb3-32" title="32"><span class="co">   the same name. The alternative is to encapsulate those types in</span></a>
<a class="sourceLine" id="cb3-33" title="33"><span class="co">   modules, but both topics are a bit out of scope of this</span></a>
<a class="sourceLine" id="cb3-34" title="34"><span class="co">   tutorial. *)</span></a>
<a class="sourceLine" id="cb3-35" title="35"></a>
<a class="sourceLine" id="cb3-36" title="36"><span class="co">(* You need to mark recursive function definitions as such with &quot;rec&quot; keyword. *)</span></a>
<a class="sourceLine" id="cb3-37" title="37"><span class="kw">let</span> <span class="kw">rec</span> factorial n =</a>
<a class="sourceLine" id="cb3-38" title="38">    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-39" title="39">    <span class="kw">else</span> n * factorial (n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb3-40" title="40">;;</a>
<a class="sourceLine" id="cb3-41" title="41"></a>
<a class="sourceLine" id="cb3-42" title="42"><span class="co">(* Function application usually doesn&#39;t need parentheses around arguments *)</span></a>
<a class="sourceLine" id="cb3-43" title="43"><span class="kw">let</span> fact_5 = factorial <span class="dv">5</span> ;;</a>
<a class="sourceLine" id="cb3-44" title="44"></a>
<a class="sourceLine" id="cb3-45" title="45"><span class="co">(* ...unless the argument is an expression. *)</span></a>
<a class="sourceLine" id="cb3-46" title="46"><span class="kw">let</span> fact_4 = factorial (<span class="dv">5-1</span>) ;;</a>
<a class="sourceLine" id="cb3-47" title="47"><span class="kw">let</span> sqr2 = sqr (<span class="dv">-2</span>) ;;</a>
<a class="sourceLine" id="cb3-48" title="48"></a>
<a class="sourceLine" id="cb3-49" title="49"><span class="co">(* Every function must have at least one argument.</span></a>
<a class="sourceLine" id="cb3-50" title="50"><span class="co">   Since some functions naturally don&#39;t take any arguments, there&#39;s</span></a>
<a class="sourceLine" id="cb3-51" title="51"><span class="co">   &quot;unit&quot; type for it that has the only one value written as &quot;()&quot; *)</span></a>
<a class="sourceLine" id="cb3-52" title="52"><span class="kw">let</span> print_hello () = <span class="dt">print_endline</span> <span class="st">&quot;hello world&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-53" title="53"></a>
<a class="sourceLine" id="cb3-54" title="54"><span class="co">(* Note that you must specify &quot;()&quot; as argument when calling it. *)</span></a>
<a class="sourceLine" id="cb3-55" title="55">print_hello () ;;</a>
<a class="sourceLine" id="cb3-56" title="56"></a>
<a class="sourceLine" id="cb3-57" title="57"><span class="co">(* Calling a function with insufficient number of arguments</span></a>
<a class="sourceLine" id="cb3-58" title="58"><span class="co">   does not cause an error, it produces a new function. *)</span></a>
<a class="sourceLine" id="cb3-59" title="59"><span class="kw">let</span> make_inc x y = x + y ;; <span class="co">(* make_inc is int -&gt; int -&gt; int *)</span></a>
<a class="sourceLine" id="cb3-60" title="60"><span class="kw">let</span> inc_2 = make_inc <span class="dv">2</span> ;;   <span class="co">(* inc_2 is int -&gt; int *)</span></a>
<a class="sourceLine" id="cb3-61" title="61">inc_2 <span class="dv">3</span> ;; <span class="co">(* Evaluates to 5 *)</span></a>
<a class="sourceLine" id="cb3-62" title="62"></a>
<a class="sourceLine" id="cb3-63" title="63"><span class="co">(* You can use multiple expressions in function body.</span></a>
<a class="sourceLine" id="cb3-64" title="64"><span class="co">   The last expression becomes the return value. All other</span></a>
<a class="sourceLine" id="cb3-65" title="65"><span class="co">   expressions must be of the &quot;unit&quot; type.</span></a>
<a class="sourceLine" id="cb3-66" title="66"><span class="co">   This is useful when writing in imperative style, the simplest</span></a>
<a class="sourceLine" id="cb3-67" title="67"><span class="co">   form of it is inserting a debug print. *)</span></a>
<a class="sourceLine" id="cb3-68" title="68"><span class="kw">let</span> print_and_return x =</a>
<a class="sourceLine" id="cb3-69" title="69">    <span class="dt">print_endline</span> (<span class="dt">string_of_int</span> x);</a>
<a class="sourceLine" id="cb3-70" title="70">    x</a>
<a class="sourceLine" id="cb3-71" title="71">;;</a>
<a class="sourceLine" id="cb3-72" title="72"></a>
<a class="sourceLine" id="cb3-73" title="73"><span class="co">(* Since OCaml is a functional language, it lacks &quot;procedures&quot;.</span></a>
<a class="sourceLine" id="cb3-74" title="74"><span class="co">   Every function must return something. So functions that</span></a>
<a class="sourceLine" id="cb3-75" title="75"><span class="co">   do not really return anything and are called solely for their</span></a>
<a class="sourceLine" id="cb3-76" title="76"><span class="co">   side effects, like print_endline, return value of &quot;unit&quot; type. *)</span></a>
<a class="sourceLine" id="cb3-77" title="77"></a>
<a class="sourceLine" id="cb3-78" title="78"></a>
<a class="sourceLine" id="cb3-79" title="79"><span class="co">(* Definitions can be chained with &quot;let ... in&quot; construct.</span></a>
<a class="sourceLine" id="cb3-80" title="80"><span class="co">   This is roughly the same to assigning values to multiple</span></a>
<a class="sourceLine" id="cb3-81" title="81"><span class="co">   variables before using them in expressions in imperative</span></a>
<a class="sourceLine" id="cb3-82" title="82"><span class="co">   languages. *)</span></a>
<a class="sourceLine" id="cb3-83" title="83"><span class="kw">let</span> x = <span class="dv">10</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb3-84" title="84"><span class="kw">let</span> y = <span class="dv">20</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb3-85" title="85">x + y ;;</a>
<a class="sourceLine" id="cb3-86" title="86"></a>
<a class="sourceLine" id="cb3-87" title="87"><span class="co">(* Alternatively you can use &quot;let ... and ... in&quot; construct.</span></a>
<a class="sourceLine" id="cb3-88" title="88"><span class="co">   This is especially useful for mutually recursive functions,</span></a>
<a class="sourceLine" id="cb3-89" title="89"><span class="co">   with ordinary &quot;let .. in&quot; the compiler will complain about</span></a>
<a class="sourceLine" id="cb3-90" title="90"><span class="co">   unbound values. *)</span></a>
<a class="sourceLine" id="cb3-91" title="91"><span class="kw">let</span> <span class="kw">rec</span></a>
<a class="sourceLine" id="cb3-92" title="92">  is_even = <span class="kw">function</span></a>
<a class="sourceLine" id="cb3-93" title="93">  | <span class="dv">0</span> -&gt; <span class="kw">true</span></a>
<a class="sourceLine" id="cb3-94" title="94">  | n -&gt; is_odd (n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb3-95" title="95"><span class="kw">and</span></a>
<a class="sourceLine" id="cb3-96" title="96">  is_odd = <span class="kw">function</span></a>
<a class="sourceLine" id="cb3-97" title="97">  | <span class="dv">0</span> -&gt; <span class="kw">false</span></a>
<a class="sourceLine" id="cb3-98" title="98">  | n -&gt; is_even (n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb3-99" title="99">;;</a>
<a class="sourceLine" id="cb3-100" title="100"></a>
<a class="sourceLine" id="cb3-101" title="101"><span class="co">(* Anonymous functions use the following syntax: *)</span></a>
<a class="sourceLine" id="cb3-102" title="102"><span class="kw">let</span> my_lambda = <span class="kw">fun</span> x -&gt; x * x ;;</a>
<a class="sourceLine" id="cb3-103" title="103"></a>
<a class="sourceLine" id="cb3-104" title="104"><span class="co">(*** Operators ***)</span></a>
<a class="sourceLine" id="cb3-105" title="105"></a>
<a class="sourceLine" id="cb3-106" title="106"><span class="co">(* There is little distinction between operators and functions.</span></a>
<a class="sourceLine" id="cb3-107" title="107"><span class="co">   Every operator can be called as a function. *)</span></a>
<a class="sourceLine" id="cb3-108" title="108"></a>
<a class="sourceLine" id="cb3-109" title="109">(+) <span class="dv">3</span> <span class="dv">4</span>  <span class="co">(* Same as 3 + 4 *)</span></a>
<a class="sourceLine" id="cb3-110" title="110"></a>
<a class="sourceLine" id="cb3-111" title="111"><span class="co">(* There&#39;s a number of built-in operators. One unusual feature is</span></a>
<a class="sourceLine" id="cb3-112" title="112"><span class="co">   that OCaml doesn&#39;t just refrain from any implicit conversions</span></a>
<a class="sourceLine" id="cb3-113" title="113"><span class="co">   between integers and floats, it also uses different operators</span></a>
<a class="sourceLine" id="cb3-114" title="114"><span class="co">   for floats. *)</span></a>
<a class="sourceLine" id="cb3-115" title="115"><span class="dv">12</span> + <span class="dv">3</span> ;; <span class="co">(* Integer addition. *)</span></a>
<a class="sourceLine" id="cb3-116" title="116"><span class="fl">12.0</span> +. <span class="fl">3.0</span> ;; <span class="co">(* Floating point addition. *)</span></a>
<a class="sourceLine" id="cb3-117" title="117"></a>
<a class="sourceLine" id="cb3-118" title="118"><span class="dv">12</span> / <span class="dv">3</span> ;; <span class="co">(* Integer division. *)</span></a>
<a class="sourceLine" id="cb3-119" title="119"><span class="fl">12.0</span> /. <span class="fl">3.0</span> ;; <span class="co">(* Floating point division. *)</span></a>
<a class="sourceLine" id="cb3-120" title="120"><span class="dv">5</span> <span class="kw">mod</span> <span class="dv">2</span> ;; <span class="co">(* Remainder. *)</span></a>
<a class="sourceLine" id="cb3-121" title="121"></a>
<a class="sourceLine" id="cb3-122" title="122"><span class="co">(* Unary minus is a notable exception, it&#39;s polymorphic.</span></a>
<a class="sourceLine" id="cb3-123" title="123"><span class="co">   However, it also has &quot;pure&quot; integer and float forms. *)</span></a>
<a class="sourceLine" id="cb3-124" title="124">- <span class="dv">3</span> ;; <span class="co">(* Polymorphic, integer *)</span></a>
<a class="sourceLine" id="cb3-125" title="125">- <span class="fl">4.5</span> ;; <span class="co">(* Polymorphic, float *)</span></a>
<a class="sourceLine" id="cb3-126" title="126">~- <span class="dv">3</span> <span class="co">(* Integer only *)</span></a>
<a class="sourceLine" id="cb3-127" title="127">~- <span class="fl">3.4</span> <span class="co">(* Type error *)</span></a>
<a class="sourceLine" id="cb3-128" title="128">~-. <span class="fl">3.4</span> <span class="co">(* Float only *)</span></a>
<a class="sourceLine" id="cb3-129" title="129"></a>
<a class="sourceLine" id="cb3-130" title="130"><span class="co">(* You can define your own operators or redefine existing ones.</span></a>
<a class="sourceLine" id="cb3-131" title="131"><span class="co">   Unlike SML or Haskell, only selected symbols can be used</span></a>
<a class="sourceLine" id="cb3-132" title="132"><span class="co">   for operator names and first symbol defines associativity</span></a>
<a class="sourceLine" id="cb3-133" title="133"><span class="co">   and precedence rules. *)</span></a>
<a class="sourceLine" id="cb3-134" title="134"><span class="kw">let</span> (+) a b = a - b ;; <span class="co">(* Surprise maintenance programmers. *)</span></a>
<a class="sourceLine" id="cb3-135" title="135"></a>
<a class="sourceLine" id="cb3-136" title="136"><span class="co">(* More useful: a reciprocal operator for floats.</span></a>
<a class="sourceLine" id="cb3-137" title="137"><span class="co">   Unary operators must start with &quot;~&quot;. *)</span></a>
<a class="sourceLine" id="cb3-138" title="138"><span class="kw">let</span> (~/) x = <span class="fl">1.0</span> /. x ;;</a>
<a class="sourceLine" id="cb3-139" title="139">~/<span class="fl">4.0</span> <span class="co">(* = 0.25 *)</span></a>
<a class="sourceLine" id="cb3-140" title="140"></a>
<a class="sourceLine" id="cb3-141" title="141"></a>
<a class="sourceLine" id="cb3-142" title="142"><span class="co">(*** Built-in data structures ***)</span></a>
<a class="sourceLine" id="cb3-143" title="143"></a>
<a class="sourceLine" id="cb3-144" title="144"><span class="co">(* Lists are enclosed in square brackets, items are separated by</span></a>
<a class="sourceLine" id="cb3-145" title="145"><span class="co">   semicolons. *)</span></a>
<a class="sourceLine" id="cb3-146" title="146"><span class="kw">let</span> my_list = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] ;;</a>
<a class="sourceLine" id="cb3-147" title="147"></a>
<a class="sourceLine" id="cb3-148" title="148"><span class="co">(* Tuples are (optionally) enclosed in parentheses, items are separated</span></a>
<a class="sourceLine" id="cb3-149" title="149"><span class="co">   by commas. *)</span></a>
<a class="sourceLine" id="cb3-150" title="150"><span class="kw">let</span> first_tuple = <span class="dv">3</span>, <span class="dv">4</span> ;; <span class="co">(* Has type &quot;int * int&quot;. *)</span></a>
<a class="sourceLine" id="cb3-151" title="151"><span class="kw">let</span> second_tuple = (<span class="dv">4</span>, <span class="dv">5</span>) ;;</a>
<a class="sourceLine" id="cb3-152" title="152"></a>
<a class="sourceLine" id="cb3-153" title="153"><span class="co">(* Corollary: if you try to separate list items by commas, you get a list</span></a>
<a class="sourceLine" id="cb3-154" title="154"><span class="co">   with a tuple inside, probably not what you want. *)</span></a>
<a class="sourceLine" id="cb3-155" title="155"><span class="kw">let</span> bad_list = [<span class="dv">1</span>, <span class="dv">2</span>] ;; <span class="co">(* Becomes [(1, 2)] *)</span></a>
<a class="sourceLine" id="cb3-156" title="156"></a>
<a class="sourceLine" id="cb3-157" title="157"><span class="co">(* You can access individual list items with the List.nth function. *)</span></a>
<a class="sourceLine" id="cb3-158" title="158"><span class="dt">List</span>.nth my_list <span class="dv">1</span> ;;</a>
<a class="sourceLine" id="cb3-159" title="159"></a>
<a class="sourceLine" id="cb3-160" title="160"><span class="co">(* There are higher-order functions for lists such as map and filter. *)</span></a>
<a class="sourceLine" id="cb3-161" title="161"><span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x * <span class="dv">2</span>) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] ;;</a>
<a class="sourceLine" id="cb3-162" title="162"><span class="dt">List</span>.filter (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span>) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>] ;;</a>
<a class="sourceLine" id="cb3-163" title="163"></a>
<a class="sourceLine" id="cb3-164" title="164"><span class="co">(* You can add an item to the beginning of a list with the &quot;::&quot; constructor</span></a>
<a class="sourceLine" id="cb3-165" title="165"><span class="co">   often referred to as &quot;cons&quot;. *)</span></a>
<a class="sourceLine" id="cb3-166" title="166"><span class="dv">1</span> :: [<span class="dv">2</span>; <span class="dv">3</span>] ;; <span class="co">(* Gives [1; 2; 3] *)</span></a>
<a class="sourceLine" id="cb3-167" title="167"></a>
<a class="sourceLine" id="cb3-168" title="168"><span class="co">(* Arrays are enclosed in [| |] *)</span></a>
<a class="sourceLine" id="cb3-169" title="169"><span class="kw">let</span> my_array = [| <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span> |] ;;</a>
<a class="sourceLine" id="cb3-170" title="170"></a>
<a class="sourceLine" id="cb3-171" title="171"><span class="co">(* You can access array items like this: *)</span></a>
<a class="sourceLine" id="cb3-172" title="172">my_array.(<span class="dv">0</span>) ;;</a>
<a class="sourceLine" id="cb3-173" title="173"></a>
<a class="sourceLine" id="cb3-174" title="174"></a>
<a class="sourceLine" id="cb3-175" title="175"><span class="co">(*** Strings and characters ***)</span></a>
<a class="sourceLine" id="cb3-176" title="176"></a>
<a class="sourceLine" id="cb3-177" title="177"><span class="co">(* Use double quotes for string literals. *)</span></a>
<a class="sourceLine" id="cb3-178" title="178"><span class="kw">let</span> my_str = <span class="st">&quot;Hello world&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-179" title="179"></a>
<a class="sourceLine" id="cb3-180" title="180"><span class="co">(* Use single quotes for character literals. *)</span></a>
<a class="sourceLine" id="cb3-181" title="181"><span class="kw">let</span> my_char = <span class="ch">&#39;a&#39;</span> ;;</a>
<a class="sourceLine" id="cb3-182" title="182"></a>
<a class="sourceLine" id="cb3-183" title="183"><span class="co">(* Single and double quotes are not interchangeable. *)</span></a>
<a class="sourceLine" id="cb3-184" title="184"><span class="kw">let</span> bad_str = &#39;syntax error&#39; ;; <span class="co">(* Syntax error. *)</span></a>
<a class="sourceLine" id="cb3-185" title="185"></a>
<a class="sourceLine" id="cb3-186" title="186"><span class="co">(* This will give you a single character string, not a character. *)</span></a>
<a class="sourceLine" id="cb3-187" title="187"><span class="kw">let</span> single_char_str = <span class="st">&quot;w&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-188" title="188"></a>
<a class="sourceLine" id="cb3-189" title="189"><span class="co">(* Strings can be concatenated with the &quot;^&quot; operator. *)</span></a>
<a class="sourceLine" id="cb3-190" title="190"><span class="kw">let</span> some_str = <span class="st">&quot;hello&quot;</span> ^ <span class="st">&quot;world&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-191" title="191"></a>
<a class="sourceLine" id="cb3-192" title="192"><span class="co">(* Strings are not arrays of characters.</span></a>
<a class="sourceLine" id="cb3-193" title="193"><span class="co">   You can&#39;t mix characters and strings in expressions.</span></a>
<a class="sourceLine" id="cb3-194" title="194"><span class="co">   You can convert a character to a string with &quot;String.make 1 my_char&quot;.</span></a>
<a class="sourceLine" id="cb3-195" title="195"><span class="co">   There are more convenient functions for this purpose in additional</span></a>
<a class="sourceLine" id="cb3-196" title="196"><span class="co">   libraries such as Core.Std that may not be installed and/or loaded</span></a>
<a class="sourceLine" id="cb3-197" title="197"><span class="co">   by default. *)</span></a>
<a class="sourceLine" id="cb3-198" title="198"><span class="kw">let</span> ocaml = (<span class="dt">String</span>.make <span class="dv">1</span> <span class="ch">&#39;O&#39;</span>) ^ <span class="st">&quot;Caml&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-199" title="199"></a>
<a class="sourceLine" id="cb3-200" title="200"><span class="co">(* There is a printf function. *)</span></a>
<a class="sourceLine" id="cb3-201" title="201"><span class="dt">Printf</span>.printf <span class="st">&quot;%d %s&quot;</span> <span class="dv">99</span> <span class="st">&quot;bottles of beer&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-202" title="202"></a>
<a class="sourceLine" id="cb3-203" title="203"><span class="co">(* Unformatted read and write functions are there too. *)</span></a>
<a class="sourceLine" id="cb3-204" title="204"><span class="dt">print_string</span> <span class="st">&quot;hello world</span><span class="ch">\n</span><span class="st">&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-205" title="205"><span class="dt">print_endline</span> <span class="st">&quot;hello world&quot;</span> ;;</a>
<a class="sourceLine" id="cb3-206" title="206"><span class="kw">let</span> line = <span class="dt">read_line</span> () ;;</a>
<a class="sourceLine" id="cb3-207" title="207"></a>
<a class="sourceLine" id="cb3-208" title="208"></a>
<a class="sourceLine" id="cb3-209" title="209"><span class="co">(*** User-defined data types ***)</span></a>
<a class="sourceLine" id="cb3-210" title="210"></a>
<a class="sourceLine" id="cb3-211" title="211"><span class="co">(* You can define types with the &quot;type some_type =&quot; construct. Like in this</span></a>
<a class="sourceLine" id="cb3-212" title="212"><span class="co">   useless type alias: *)</span></a>
<a class="sourceLine" id="cb3-213" title="213"><span class="kw">type</span> my_int = <span class="dt">int</span> ;;</a>
<a class="sourceLine" id="cb3-214" title="214"></a>
<a class="sourceLine" id="cb3-215" title="215"><span class="co">(* More interesting types include so called type constructors.</span></a>
<a class="sourceLine" id="cb3-216" title="216"><span class="co">   Constructors must start with a capital letter. *)</span></a>
<a class="sourceLine" id="cb3-217" title="217"><span class="kw">type</span> ml = OCaml | StandardML ;;</a>
<a class="sourceLine" id="cb3-218" title="218"><span class="kw">let</span> lang = OCaml ;;  <span class="co">(* Has type &quot;ml&quot;. *)</span></a>
<a class="sourceLine" id="cb3-219" title="219"></a>
<a class="sourceLine" id="cb3-220" title="220"><span class="co">(* Type constructors don&#39;t need to be empty. *)</span></a>
<a class="sourceLine" id="cb3-221" title="221"><span class="kw">type</span> my_number = PlusInfinity | MinusInfinity | Real <span class="kw">of</span> <span class="dt">float</span> ;;</a>
<a class="sourceLine" id="cb3-222" title="222"><span class="kw">let</span> r0 = Real (<span class="fl">-3.4</span>) ;; <span class="co">(* Has type &quot;my_number&quot;. *)</span></a>
<a class="sourceLine" id="cb3-223" title="223"></a>
<a class="sourceLine" id="cb3-224" title="224"><span class="co">(* Can be used to implement polymorphic arithmetics. *)</span></a>
<a class="sourceLine" id="cb3-225" title="225"><span class="kw">type</span> number = Int <span class="kw">of</span> <span class="dt">int</span> | Float <span class="kw">of</span> <span class="dt">float</span> ;;</a>
<a class="sourceLine" id="cb3-226" title="226"></a>
<a class="sourceLine" id="cb3-227" title="227"><span class="co">(* Point on a plane, essentially a type-constrained tuple *)</span></a>
<a class="sourceLine" id="cb3-228" title="228"><span class="kw">type</span> point2d = Point <span class="kw">of</span> <span class="dt">float</span> * <span class="dt">float</span> ;;</a>
<a class="sourceLine" id="cb3-229" title="229"><span class="kw">let</span> my_point = Point (<span class="fl">2.0</span>, <span class="fl">3.0</span>) ;;</a>
<a class="sourceLine" id="cb3-230" title="230"></a>
<a class="sourceLine" id="cb3-231" title="231"><span class="co">(* Types can be parameterized, like in this type for &quot;list of lists</span></a>
<a class="sourceLine" id="cb3-232" title="232"><span class="co">   of anything&quot;. &#39;a can be substituted with any type. *)</span></a>
<a class="sourceLine" id="cb3-233" title="233"><span class="kw">type</span> &#39;a list_of_lists = &#39;a <span class="dt">list</span> <span class="dt">list</span> ;;</a>
<a class="sourceLine" id="cb3-234" title="234"><span class="kw">type</span> int_list_list = <span class="dt">int</span> list_of_lists ;;</a>
<a class="sourceLine" id="cb3-235" title="235"></a>
<a class="sourceLine" id="cb3-236" title="236"><span class="co">(* Types can also be recursive. Like in this type analogous to</span></a>
<a class="sourceLine" id="cb3-237" title="237"><span class="co">   built-in list of integers. *)</span></a>
<a class="sourceLine" id="cb3-238" title="238"><span class="kw">type</span> my_int_list = EmptyList | IntList <span class="kw">of</span> <span class="dt">int</span> * my_int_list ;;</a>
<a class="sourceLine" id="cb3-239" title="239"><span class="kw">let</span> l = IntList (<span class="dv">1</span>, EmptyList) ;;</a>
<a class="sourceLine" id="cb3-240" title="240"></a>
<a class="sourceLine" id="cb3-241" title="241"></a>
<a class="sourceLine" id="cb3-242" title="242"><span class="co">(*** Pattern matching ***)</span></a>
<a class="sourceLine" id="cb3-243" title="243"></a>
<a class="sourceLine" id="cb3-244" title="244"><span class="co">(* Pattern matching is somewhat similar to switch statement in imperative</span></a>
<a class="sourceLine" id="cb3-245" title="245"><span class="co">   languages, but offers a lot more expressive power.</span></a>
<a class="sourceLine" id="cb3-246" title="246"></a>
<a class="sourceLine" id="cb3-247" title="247"><span class="co">   Even though it may look complicated, it really boils down to matching</span></a>
<a class="sourceLine" id="cb3-248" title="248"><span class="co">   an argument against an exact value, a predicate, or a type constructor.</span></a>
<a class="sourceLine" id="cb3-249" title="249"><span class="co">   The type system is what makes it so powerful. *)</span></a>
<a class="sourceLine" id="cb3-250" title="250"></a>
<a class="sourceLine" id="cb3-251" title="251"><span class="co">(** Matching exact values.  **)</span></a>
<a class="sourceLine" id="cb3-252" title="252"></a>
<a class="sourceLine" id="cb3-253" title="253"><span class="kw">let</span> is_zero x =</a>
<a class="sourceLine" id="cb3-254" title="254">    <span class="kw">match</span> x <span class="kw">with</span></a>
<a class="sourceLine" id="cb3-255" title="255">    | <span class="dv">0</span> -&gt; <span class="kw">true</span></a>
<a class="sourceLine" id="cb3-256" title="256">    | _ -&gt; <span class="kw">false</span>  <span class="co">(* The &quot;_&quot; pattern means &quot;anything else&quot;. *)</span></a>
<a class="sourceLine" id="cb3-257" title="257">;;</a>
<a class="sourceLine" id="cb3-258" title="258"></a>
<a class="sourceLine" id="cb3-259" title="259"><span class="co">(* Alternatively, you can use the &quot;function&quot; keyword. *)</span></a>
<a class="sourceLine" id="cb3-260" title="260"><span class="kw">let</span> is_one = <span class="kw">function</span></a>
<a class="sourceLine" id="cb3-261" title="261">| <span class="dv">1</span> -&gt; <span class="kw">true</span></a>
<a class="sourceLine" id="cb3-262" title="262">| _ -&gt; <span class="kw">false</span></a>
<a class="sourceLine" id="cb3-263" title="263">;;</a>
<a class="sourceLine" id="cb3-264" title="264"></a>
<a class="sourceLine" id="cb3-265" title="265"><span class="co">(* Matching predicates, aka &quot;guarded pattern matching&quot;. *)</span></a>
<a class="sourceLine" id="cb3-266" title="266"><span class="kw">let</span> <span class="dt">abs</span> x =</a>
<a class="sourceLine" id="cb3-267" title="267">    <span class="kw">match</span> x <span class="kw">with</span></a>
<a class="sourceLine" id="cb3-268" title="268">    | x <span class="kw">when</span> x &lt; <span class="dv">0</span> -&gt; -x</a>
<a class="sourceLine" id="cb3-269" title="269">    | _ -&gt; x</a>
<a class="sourceLine" id="cb3-270" title="270">;;</a>
<a class="sourceLine" id="cb3-271" title="271"></a>
<a class="sourceLine" id="cb3-272" title="272"><span class="dt">abs</span> <span class="dv">5</span> ;; <span class="co">(* 5 *)</span></a>
<a class="sourceLine" id="cb3-273" title="273"><span class="dt">abs</span> (<span class="dv">-5</span>) <span class="co">(* 5 again *)</span></a>
<a class="sourceLine" id="cb3-274" title="274"></a>
<a class="sourceLine" id="cb3-275" title="275"><span class="co">(** Matching type constructors **)</span></a>
<a class="sourceLine" id="cb3-276" title="276"></a>
<a class="sourceLine" id="cb3-277" title="277"><span class="kw">type</span> animal = Dog <span class="kw">of</span> <span class="dt">string</span> | Cat <span class="kw">of</span> <span class="dt">string</span> ;;</a>
<a class="sourceLine" id="cb3-278" title="278"></a>
<a class="sourceLine" id="cb3-279" title="279"><span class="kw">let</span> say x =</a>
<a class="sourceLine" id="cb3-280" title="280">    <span class="kw">match</span> x <span class="kw">with</span></a>
<a class="sourceLine" id="cb3-281" title="281">    | Dog x -&gt; x ^ <span class="st">&quot; says woof&quot;</span></a>
<a class="sourceLine" id="cb3-282" title="282">    | Cat x -&gt; x ^ <span class="st">&quot; says meow&quot;</span></a>
<a class="sourceLine" id="cb3-283" title="283">;;</a>
<a class="sourceLine" id="cb3-284" title="284"></a>
<a class="sourceLine" id="cb3-285" title="285">say (Cat <span class="st">&quot;Fluffy&quot;</span>) ;; <span class="co">(* &quot;Fluffy says meow&quot;. *)</span></a>
<a class="sourceLine" id="cb3-286" title="286"></a>
<a class="sourceLine" id="cb3-287" title="287"><span class="co">(** Traversing data structures with pattern matching **)</span></a>
<a class="sourceLine" id="cb3-288" title="288"></a>
<a class="sourceLine" id="cb3-289" title="289"><span class="co">(* Recursive types can be traversed with pattern matching easily.</span></a>
<a class="sourceLine" id="cb3-290" title="290"><span class="co">   Let&#39;s see how we can traverse a data structure of the built-in list type.</span></a>
<a class="sourceLine" id="cb3-291" title="291"><span class="co">   Even though the built-in cons (&quot;::&quot;) looks like an infix operator,</span></a>
<a class="sourceLine" id="cb3-292" title="292"><span class="co">   it&#39;s actually a type constructor and can be matched like any other. *)</span></a>
<a class="sourceLine" id="cb3-293" title="293"><span class="kw">let</span> <span class="kw">rec</span> sum_list l =</a>
<a class="sourceLine" id="cb3-294" title="294">    <span class="kw">match</span> l <span class="kw">with</span></a>
<a class="sourceLine" id="cb3-295" title="295">    | [] -&gt; <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-296" title="296">    | head :: tail -&gt; head + (sum_list tail)</a>
<a class="sourceLine" id="cb3-297" title="297">;;</a>
<a class="sourceLine" id="cb3-298" title="298"></a>
<a class="sourceLine" id="cb3-299" title="299">sum_list [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] ;; <span class="co">(* Evaluates to 6 *)</span></a>
<a class="sourceLine" id="cb3-300" title="300"></a>
<a class="sourceLine" id="cb3-301" title="301"><span class="co">(* Built-in syntax for cons obscures the structure a bit, so we&#39;ll make</span></a>
<a class="sourceLine" id="cb3-302" title="302"><span class="co">   our own list for demonstration. *)</span></a>
<a class="sourceLine" id="cb3-303" title="303"></a>
<a class="sourceLine" id="cb3-304" title="304"><span class="kw">type</span> int_list = Nil | Cons <span class="kw">of</span> <span class="dt">int</span> * int_list ;;</a>
<a class="sourceLine" id="cb3-305" title="305"><span class="kw">let</span> <span class="kw">rec</span> sum_int_list l =</a>
<a class="sourceLine" id="cb3-306" title="306">  <span class="kw">match</span> l <span class="kw">with</span></a>
<a class="sourceLine" id="cb3-307" title="307">      | Nil -&gt; <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-308" title="308">      | Cons (head, tail) -&gt; head + (sum_int_list tail)</a>
<a class="sourceLine" id="cb3-309" title="309">;;</a>
<a class="sourceLine" id="cb3-310" title="310"></a>
<a class="sourceLine" id="cb3-311" title="311"><span class="kw">let</span> t = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Nil))) ;;</a>
<a class="sourceLine" id="cb3-312" title="312">sum_int_list t ;;</a></code></pre>
    </div>
    <h2 id="further-reading">Further reading</h2>
    <ul>
      <li>
        Visit the official website to get the compiler and read the docs:
        <a href="http://ocaml.org/" class="uri">http://ocaml.org/</a>
      </li>
      <li>
        Try interactive tutorials and a web-based interpreter by OCaml Pro:
        <a href="http://try.ocamlpro.com/" class="uri"
          >http://try.ocamlpro.com/</a
        >
      </li>
    </ul>
  </body>
</html>
