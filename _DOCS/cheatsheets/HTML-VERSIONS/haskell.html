<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>haskell.html</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <p>
      Haskell was designed as a practical, purely functional programming
      language. Itâ€™s famous for its monads and its type system, but I keep
      coming back to it because of its elegance. Haskell makes coding a real joy
      for me.
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode haskell"
      ><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="co">-- Single line comments start with two dashes.</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">{- Multiline comments can be enclosed</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">in a block like this.</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">-}</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">-- 1. Primitive Datatypes and Operators</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">-- You have numbers</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="dv">3</span> <span class="co">-- 3</span></a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">-- Math is what you would expect</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span> <span class="co">-- 2</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="dv">8</span> <span class="op">-</span> <span class="dv">1</span> <span class="co">-- 7</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="dv">10</span> <span class="op">*</span> <span class="dv">2</span> <span class="co">-- 20</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="dv">35</span> <span class="op">/</span> <span class="dv">5</span> <span class="co">-- 7.0</span></a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">-- Division is not integer division by default</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="dv">35</span> <span class="op">/</span> <span class="dv">4</span> <span class="co">-- 8.75</span></a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="co">-- integer division</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="dv">35</span> <span class="ot">`div`</span> <span class="dv">4</span> <span class="co">-- 8</span></a>
<a class="sourceLine" id="cb1-24" title="24"></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co">-- Boolean values are primitives</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="dt">True</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="dt">False</span></a>
<a class="sourceLine" id="cb1-28" title="28"></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">-- Boolean operations</span></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="fu">not</span> <span class="dt">True</span> <span class="co">-- False</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="fu">not</span> <span class="dt">False</span> <span class="co">-- True</span></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="dv">1</span> <span class="op">==</span> <span class="dv">1</span> <span class="co">-- True</span></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="dv">1</span> <span class="op">/=</span> <span class="dv">1</span> <span class="co">-- False</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="dv">1</span> <span class="op">&lt;</span> <span class="dv">10</span> <span class="co">-- True</span></a>
<a class="sourceLine" id="cb1-35" title="35"></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="co">-- In the above examples, `not` is a function that takes one value.</span></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="co">-- Haskell doesn&#39;t need parentheses for function calls...all the arguments</span></a>
<a class="sourceLine" id="cb1-38" title="38"><span class="co">-- are just listed after the function. So the general pattern is:</span></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="co">-- func arg1 arg2 arg3...</span></a>
<a class="sourceLine" id="cb1-40" title="40"><span class="co">-- See the section on functions for information on how to write your own.</span></a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="co">-- Strings and characters</span></a>
<a class="sourceLine" id="cb1-43" title="43"><span class="st">&quot;This is a string.&quot;</span></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="ch">&#39;a&#39;</span> <span class="co">-- character</span></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="dt">&#39;You</span> cant use single quotes for strings<span class="op">.</span>&#39; <span class="co">-- error!</span></a>
<a class="sourceLine" id="cb1-46" title="46"></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">-- Strings can be concatenated</span></a>
<a class="sourceLine" id="cb1-48" title="48"><span class="st">&quot;Hello &quot;</span> <span class="op">++</span> <span class="st">&quot;world!&quot;</span> <span class="co">-- &quot;Hello world!&quot;</span></a>
<a class="sourceLine" id="cb1-49" title="49"></a>
<a class="sourceLine" id="cb1-50" title="50"><span class="co">-- A string is a list of characters</span></a>
<a class="sourceLine" id="cb1-51" title="51">[<span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span>] <span class="co">-- &quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb1-52" title="52"></a>
<a class="sourceLine" id="cb1-53" title="53"><span class="co">-- Lists can be indexed with the `!!` operator followed by an index</span></a>
<a class="sourceLine" id="cb1-54" title="54"><span class="st">&quot;This is a string&quot;</span> <span class="op">!!</span> <span class="dv">0</span> <span class="co">-- &#39;T&#39;</span></a>
<a class="sourceLine" id="cb1-55" title="55"></a>
<a class="sourceLine" id="cb1-56" title="56"></a>
<a class="sourceLine" id="cb1-57" title="57"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-58" title="58"><span class="co">-- 2. Lists and Tuples</span></a>
<a class="sourceLine" id="cb1-59" title="59"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-60" title="60"></a>
<a class="sourceLine" id="cb1-61" title="61"><span class="co">-- Every element in a list must have the same type.</span></a>
<a class="sourceLine" id="cb1-62" title="62"><span class="co">-- These two lists are equal:</span></a>
<a class="sourceLine" id="cb1-63" title="63">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb1-64" title="64">[<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>]</a>
<a class="sourceLine" id="cb1-65" title="65"></a>
<a class="sourceLine" id="cb1-66" title="66"><span class="co">-- Ranges are versatile.</span></a>
<a class="sourceLine" id="cb1-67" title="67">[<span class="ch">&#39;A&#39;</span><span class="op">..</span><span class="ch">&#39;F&#39;</span>] <span class="co">-- &quot;ABCDEF&quot;</span></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69"><span class="co">-- You can create a step in a range.</span></a>
<a class="sourceLine" id="cb1-70" title="70">[<span class="dv">0</span>,<span class="dv">2</span><span class="op">..</span><span class="dv">10</span>] <span class="co">-- [0, 2, 4, 6, 8, 10]</span></a>
<a class="sourceLine" id="cb1-71" title="71">[<span class="dv">5</span><span class="op">..</span><span class="dv">1</span>] <span class="co">-- [] (Haskell defaults to incrementing)</span></a>
<a class="sourceLine" id="cb1-72" title="72">[<span class="dv">5</span>,<span class="dv">4</span><span class="op">..</span><span class="dv">1</span>] <span class="co">-- [5, 4, 3, 2, 1]</span></a>
<a class="sourceLine" id="cb1-73" title="73"></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="co">-- indexing into a list</span></a>
<a class="sourceLine" id="cb1-75" title="75">[<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>] <span class="op">!!</span> <span class="dv">3</span> <span class="co">-- 4 (zero-based indexing)</span></a>
<a class="sourceLine" id="cb1-76" title="76"></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="co">-- You can also have infinite lists in Haskell!</span></a>
<a class="sourceLine" id="cb1-78" title="78">[<span class="dv">1</span><span class="op">..</span>] <span class="co">-- a list of all the natural numbers</span></a>
<a class="sourceLine" id="cb1-79" title="79"></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">-- Infinite lists work because Haskell has &quot;lazy evaluation&quot;. This means</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="co">-- that Haskell only evaluates things when it needs to. So you can ask for</span></a>
<a class="sourceLine" id="cb1-82" title="82"><span class="co">-- the 1000th element of your list and Haskell will give it to you:</span></a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84">[<span class="dv">1</span><span class="op">..</span>] <span class="op">!!</span> <span class="dv">999</span> <span class="co">-- 1000</span></a>
<a class="sourceLine" id="cb1-85" title="85"></a>
<a class="sourceLine" id="cb1-86" title="86"><span class="co">-- And now Haskell has evaluated elements 1 - 1000 of this list...but the</span></a>
<a class="sourceLine" id="cb1-87" title="87"><span class="co">-- rest of the elements of this &quot;infinite&quot; list don&#39;t exist yet! Haskell won&#39;t</span></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="co">-- actually evaluate them until it needs to.</span></a>
<a class="sourceLine" id="cb1-89" title="89"></a>
<a class="sourceLine" id="cb1-90" title="90"><span class="co">-- joining two lists</span></a>
<a class="sourceLine" id="cb1-91" title="91">[<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="op">++</span> [<span class="dv">6</span><span class="op">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb1-92" title="92"></a>
<a class="sourceLine" id="cb1-93" title="93"><span class="co">-- adding to the head of a list</span></a>
<a class="sourceLine" id="cb1-94" title="94"><span class="dv">0</span><span class="op">:</span>[<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- [0, 1, 2, 3, 4, 5]</span></a>
<a class="sourceLine" id="cb1-95" title="95"></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="co">-- more list operations</span></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="fu">head</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- 1</span></a>
<a class="sourceLine" id="cb1-98" title="98"><span class="fu">tail</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- [2, 3, 4, 5]</span></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="fu">init</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- [1, 2, 3, 4]</span></a>
<a class="sourceLine" id="cb1-100" title="100"><span class="fu">last</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- 5</span></a>
<a class="sourceLine" id="cb1-101" title="101"></a>
<a class="sourceLine" id="cb1-102" title="102"><span class="co">-- list comprehensions</span></a>
<a class="sourceLine" id="cb1-103" title="103">[x<span class="op">*</span><span class="dv">2</span> <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>]] <span class="co">-- [2, 4, 6, 8, 10]</span></a>
<a class="sourceLine" id="cb1-104" title="104"></a>
<a class="sourceLine" id="cb1-105" title="105"><span class="co">-- with a conditional</span></a>
<a class="sourceLine" id="cb1-106" title="106">[x<span class="op">*</span><span class="dv">2</span> <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>], x<span class="op">*</span><span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">4</span>] <span class="co">-- [6, 8, 10]</span></a>
<a class="sourceLine" id="cb1-107" title="107"></a>
<a class="sourceLine" id="cb1-108" title="108"><span class="co">-- Every element in a tuple can be a different type, but a tuple has a</span></a>
<a class="sourceLine" id="cb1-109" title="109"><span class="co">-- fixed length.</span></a>
<a class="sourceLine" id="cb1-110" title="110"><span class="co">-- A tuple:</span></a>
<a class="sourceLine" id="cb1-111" title="111">(<span class="st">&quot;haskell&quot;</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-112" title="112"></a>
<a class="sourceLine" id="cb1-113" title="113"><span class="co">-- accessing elements of a pair (i.e. a tuple of length 2)</span></a>
<a class="sourceLine" id="cb1-114" title="114"><span class="fu">fst</span> (<span class="st">&quot;haskell&quot;</span>, <span class="dv">1</span>) <span class="co">-- &quot;haskell&quot;</span></a>
<a class="sourceLine" id="cb1-115" title="115"><span class="fu">snd</span> (<span class="st">&quot;haskell&quot;</span>, <span class="dv">1</span>) <span class="co">-- 1</span></a>
<a class="sourceLine" id="cb1-116" title="116"></a>
<a class="sourceLine" id="cb1-117" title="117"><span class="co">-- pair element accessing does not work on n-tuples (i.e. triple, quadruple, etc)</span></a>
<a class="sourceLine" id="cb1-118" title="118"><span class="fu">snd</span> (<span class="st">&quot;snd&quot;</span>, <span class="st">&quot;can&#39;t touch this&quot;</span>, <span class="st">&quot;da na na na&quot;</span>) <span class="co">-- error! see function below</span></a>
<a class="sourceLine" id="cb1-119" title="119"></a>
<a class="sourceLine" id="cb1-120" title="120"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-121" title="121"><span class="co">-- 3. Functions</span></a>
<a class="sourceLine" id="cb1-122" title="122"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-123" title="123"><span class="co">-- A simple function that takes two variables</span></a>
<a class="sourceLine" id="cb1-124" title="124">add a b <span class="ot">=</span> a <span class="op">+</span> b</a>
<a class="sourceLine" id="cb1-125" title="125"></a>
<a class="sourceLine" id="cb1-126" title="126"><span class="co">-- Note that if you are using ghci (the Haskell interpreter)</span></a>
<a class="sourceLine" id="cb1-127" title="127"><span class="co">-- You&#39;ll need to use `let`, i.e.</span></a>
<a class="sourceLine" id="cb1-128" title="128"><span class="co">-- let add a b = a + b</span></a>
<a class="sourceLine" id="cb1-129" title="129"></a>
<a class="sourceLine" id="cb1-130" title="130"><span class="co">-- Using the function</span></a>
<a class="sourceLine" id="cb1-131" title="131">add <span class="dv">1</span> <span class="dv">2</span> <span class="co">-- 3</span></a>
<a class="sourceLine" id="cb1-132" title="132"></a>
<a class="sourceLine" id="cb1-133" title="133"><span class="co">-- You can also put the function name between the two arguments</span></a>
<a class="sourceLine" id="cb1-134" title="134"><span class="co">-- with backticks:</span></a>
<a class="sourceLine" id="cb1-135" title="135"><span class="dv">1</span> <span class="ot">`add`</span> <span class="dv">2</span> <span class="co">-- 3</span></a>
<a class="sourceLine" id="cb1-136" title="136"></a>
<a class="sourceLine" id="cb1-137" title="137"><span class="co">-- You can also define functions that have no letters! This lets</span></a>
<a class="sourceLine" id="cb1-138" title="138"><span class="co">-- you define your own operators! Here&#39;s an operator that does</span></a>
<a class="sourceLine" id="cb1-139" title="139"><span class="co">-- integer division</span></a>
<a class="sourceLine" id="cb1-140" title="140">(<span class="op">//</span>) a b <span class="ot">=</span> a <span class="ot">`div`</span> b</a>
<a class="sourceLine" id="cb1-141" title="141"><span class="dv">35</span> <span class="op">//</span> <span class="dv">4</span> <span class="co">-- 8</span></a>
<a class="sourceLine" id="cb1-142" title="142"></a>
<a class="sourceLine" id="cb1-143" title="143"><span class="co">-- Guards: an easy way to do branching in functions</span></a>
<a class="sourceLine" id="cb1-144" title="144">fib x</a>
<a class="sourceLine" id="cb1-145" title="145">  <span class="op">|</span> x <span class="op">&lt;</span> <span class="dv">2</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-146" title="146">  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> fib (x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (x <span class="op">-</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-147" title="147"></a>
<a class="sourceLine" id="cb1-148" title="148"><span class="co">-- Pattern matching is similar. Here we have given three different</span></a>
<a class="sourceLine" id="cb1-149" title="149"><span class="co">-- equations that define fib. Haskell will automatically use the first</span></a>
<a class="sourceLine" id="cb1-150" title="150"><span class="co">-- equation whose left hand side pattern matches the value.</span></a>
<a class="sourceLine" id="cb1-151" title="151">fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-152" title="152">fib <span class="dv">2</span> <span class="ot">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-153" title="153">fib x <span class="ot">=</span> fib (x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (x <span class="op">-</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-154" title="154"></a>
<a class="sourceLine" id="cb1-155" title="155"><span class="co">-- Pattern matching on tuples</span></a>
<a class="sourceLine" id="cb1-156" title="156">sndOfTriple (_, y, _) <span class="ot">=</span> y <span class="co">-- use a wild card (_) to bypass naming unused value</span></a>
<a class="sourceLine" id="cb1-157" title="157"></a>
<a class="sourceLine" id="cb1-158" title="158"><span class="co">-- Pattern matching on lists. Here `x` is the first element</span></a>
<a class="sourceLine" id="cb1-159" title="159"><span class="co">-- in the list, and `xs` is the rest of the list. We can write</span></a>
<a class="sourceLine" id="cb1-160" title="160"><span class="co">-- our own map function:</span></a>
<a class="sourceLine" id="cb1-161" title="161">myMap func [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-162" title="162">myMap func (x<span class="op">:</span>xs) <span class="ot">=</span> func x<span class="op">:</span>(myMap func xs)</a>
<a class="sourceLine" id="cb1-163" title="163"></a>
<a class="sourceLine" id="cb1-164" title="164"><span class="co">-- Anonymous functions are created with a backslash followed by</span></a>
<a class="sourceLine" id="cb1-165" title="165"><span class="co">-- all the arguments.</span></a>
<a class="sourceLine" id="cb1-166" title="166">myMap (\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">2</span>) [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- [3, 4, 5, 6, 7]</span></a>
<a class="sourceLine" id="cb1-167" title="167"></a>
<a class="sourceLine" id="cb1-168" title="168"><span class="co">-- using fold (called `inject` in some languages) with an anonymous</span></a>
<a class="sourceLine" id="cb1-169" title="169"><span class="co">-- function. foldl1 means fold left, and use the first value in the</span></a>
<a class="sourceLine" id="cb1-170" title="170"><span class="co">-- list as the initial value for the accumulator.</span></a>
<a class="sourceLine" id="cb1-171" title="171"><span class="fu">foldl1</span> (\acc x <span class="ot">-&gt;</span> acc <span class="op">+</span> x) [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- 15</span></a>
<a class="sourceLine" id="cb1-172" title="172"></a>
<a class="sourceLine" id="cb1-173" title="173"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-174" title="174"><span class="co">-- 4. More functions</span></a>
<a class="sourceLine" id="cb1-175" title="175"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-176" title="176"></a>
<a class="sourceLine" id="cb1-177" title="177"><span class="co">-- partial application: if you don&#39;t pass in all the arguments to a function,</span></a>
<a class="sourceLine" id="cb1-178" title="178"><span class="co">-- it gets &quot;partially applied&quot;. That means it returns a function that takes the</span></a>
<a class="sourceLine" id="cb1-179" title="179"><span class="co">-- rest of the arguments.</span></a>
<a class="sourceLine" id="cb1-180" title="180"></a>
<a class="sourceLine" id="cb1-181" title="181">add a b <span class="ot">=</span> a <span class="op">+</span> b</a>
<a class="sourceLine" id="cb1-182" title="182">foo <span class="ot">=</span> add <span class="dv">10</span> <span class="co">-- foo is now a function that takes a number and adds 10 to it</span></a>
<a class="sourceLine" id="cb1-183" title="183">foo <span class="dv">5</span> <span class="co">-- 15</span></a>
<a class="sourceLine" id="cb1-184" title="184"></a>
<a class="sourceLine" id="cb1-185" title="185"><span class="co">-- Another way to write the same thing</span></a>
<a class="sourceLine" id="cb1-186" title="186">foo <span class="ot">=</span> (<span class="dv">10</span><span class="op">+</span>)</a>
<a class="sourceLine" id="cb1-187" title="187">foo <span class="dv">5</span> <span class="co">-- 15</span></a>
<a class="sourceLine" id="cb1-188" title="188"></a>
<a class="sourceLine" id="cb1-189" title="189"><span class="co">-- function composition</span></a>
<a class="sourceLine" id="cb1-190" title="190"><span class="co">-- the operator `.` chains functions together.</span></a>
<a class="sourceLine" id="cb1-191" title="191"><span class="co">-- For example, here foo is a function that takes a value. It adds 10 to it,</span></a>
<a class="sourceLine" id="cb1-192" title="192"><span class="co">-- multiplies the result of that by 4, and then returns the final value.</span></a>
<a class="sourceLine" id="cb1-193" title="193">foo <span class="ot">=</span> (<span class="dv">4</span><span class="op">*</span>) <span class="op">.</span> (<span class="dv">10</span><span class="op">+</span>)</a>
<a class="sourceLine" id="cb1-194" title="194"></a>
<a class="sourceLine" id="cb1-195" title="195"><span class="co">-- 4*(10+5) = 60</span></a>
<a class="sourceLine" id="cb1-196" title="196">foo <span class="dv">5</span> <span class="co">-- 60</span></a>
<a class="sourceLine" id="cb1-197" title="197"></a>
<a class="sourceLine" id="cb1-198" title="198"><span class="co">-- fixing precedence</span></a>
<a class="sourceLine" id="cb1-199" title="199"><span class="co">-- Haskell has an operator called `$`. This operator applies a function</span></a>
<a class="sourceLine" id="cb1-200" title="200"><span class="co">-- to a given parameter. In contrast to standard function application, which</span></a>
<a class="sourceLine" id="cb1-201" title="201"><span class="co">-- has highest possible priority of 10 and is left-associative, the `$` operator</span></a>
<a class="sourceLine" id="cb1-202" title="202"><span class="co">-- has priority of 0 and is right-associative. Such a low priority means that</span></a>
<a class="sourceLine" id="cb1-203" title="203"><span class="co">-- the expression on its right is applied as a parameter to the function on its left.</span></a>
<a class="sourceLine" id="cb1-204" title="204"></a>
<a class="sourceLine" id="cb1-205" title="205"><span class="co">-- before</span></a>
<a class="sourceLine" id="cb1-206" title="206"><span class="fu">even</span> (fib <span class="dv">7</span>) <span class="co">-- false</span></a>
<a class="sourceLine" id="cb1-207" title="207"></a>
<a class="sourceLine" id="cb1-208" title="208"><span class="co">-- equivalently</span></a>
<a class="sourceLine" id="cb1-209" title="209"><span class="fu">even</span> <span class="op">$</span> fib <span class="dv">7</span> <span class="co">-- false</span></a>
<a class="sourceLine" id="cb1-210" title="210"></a>
<a class="sourceLine" id="cb1-211" title="211"><span class="co">-- composing functions</span></a>
<a class="sourceLine" id="cb1-212" title="212"><span class="fu">even</span> <span class="op">.</span> fib <span class="op">$</span> <span class="dv">7</span> <span class="co">-- false</span></a>
<a class="sourceLine" id="cb1-213" title="213"></a>
<a class="sourceLine" id="cb1-214" title="214"></a>
<a class="sourceLine" id="cb1-215" title="215"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-216" title="216"><span class="co">-- 5. Type signatures</span></a>
<a class="sourceLine" id="cb1-217" title="217"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-218" title="218"></a>
<a class="sourceLine" id="cb1-219" title="219"><span class="co">-- Haskell has a very strong type system, and every valid expression has a type.</span></a>
<a class="sourceLine" id="cb1-220" title="220"></a>
<a class="sourceLine" id="cb1-221" title="221"><span class="co">-- Some basic types:</span></a>
<a class="sourceLine" id="cb1-222" title="222"><span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-223" title="223"><span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-224" title="224"><span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-225" title="225"></a>
<a class="sourceLine" id="cb1-226" title="226"><span class="co">-- Functions have types too.</span></a>
<a class="sourceLine" id="cb1-227" title="227"><span class="co">-- `not` takes a boolean and returns a boolean:</span></a>
<a class="sourceLine" id="cb1-228" title="228"><span class="co">-- not :: Bool -&gt; Bool</span></a>
<a class="sourceLine" id="cb1-229" title="229"></a>
<a class="sourceLine" id="cb1-230" title="230"><span class="co">-- Here&#39;s a function that takes two arguments:</span></a>
<a class="sourceLine" id="cb1-231" title="231"><span class="co">-- add :: Integer -&gt; Integer -&gt; Integer</span></a>
<a class="sourceLine" id="cb1-232" title="232"></a>
<a class="sourceLine" id="cb1-233" title="233"><span class="co">-- When you define a value, it&#39;s good practice to write its type above it:</span></a>
<a class="sourceLine" id="cb1-234" title="234"><span class="ot">double ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-235" title="235">double x <span class="ot">=</span> x <span class="op">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-236" title="236"></a>
<a class="sourceLine" id="cb1-237" title="237"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-238" title="238"><span class="co">-- 6. Control Flow and If Expressions</span></a>
<a class="sourceLine" id="cb1-239" title="239"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-240" title="240"></a>
<a class="sourceLine" id="cb1-241" title="241"><span class="co">-- if-expressions</span></a>
<a class="sourceLine" id="cb1-242" title="242">haskell <span class="ot">=</span> <span class="kw">if</span> <span class="dv">1</span> <span class="op">==</span> <span class="dv">1</span> <span class="kw">then</span> <span class="st">&quot;awesome&quot;</span> <span class="kw">else</span> <span class="st">&quot;awful&quot;</span> <span class="co">-- haskell = &quot;awesome&quot;</span></a>
<a class="sourceLine" id="cb1-243" title="243"></a>
<a class="sourceLine" id="cb1-244" title="244"><span class="co">-- if-expressions can be on multiple lines too, indentation is important</span></a>
<a class="sourceLine" id="cb1-245" title="245">haskell <span class="ot">=</span> <span class="kw">if</span> <span class="dv">1</span> <span class="op">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-246" title="246">            <span class="kw">then</span> <span class="st">&quot;awesome&quot;</span></a>
<a class="sourceLine" id="cb1-247" title="247">            <span class="kw">else</span> <span class="st">&quot;awful&quot;</span></a>
<a class="sourceLine" id="cb1-248" title="248"></a>
<a class="sourceLine" id="cb1-249" title="249"><span class="co">-- case expressions: Here&#39;s how you could parse command line arguments</span></a>
<a class="sourceLine" id="cb1-250" title="250"><span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-251" title="251">  <span class="st">&quot;help&quot;</span> <span class="ot">-&gt;</span> printHelp</a>
<a class="sourceLine" id="cb1-252" title="252">  <span class="st">&quot;start&quot;</span> <span class="ot">-&gt;</span> startProgram</a>
<a class="sourceLine" id="cb1-253" title="253">  _ <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;bad args&quot;</span></a>
<a class="sourceLine" id="cb1-254" title="254"></a>
<a class="sourceLine" id="cb1-255" title="255"><span class="co">-- Haskell doesn&#39;t have loops; it uses recursion instead.</span></a>
<a class="sourceLine" id="cb1-256" title="256"><span class="co">-- map applies a function over every element in a list</span></a>
<a class="sourceLine" id="cb1-257" title="257"></a>
<a class="sourceLine" id="cb1-258" title="258"><span class="fu">map</span> (<span class="op">*</span><span class="dv">2</span>) [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] <span class="co">-- [2, 4, 6, 8, 10]</span></a>
<a class="sourceLine" id="cb1-259" title="259"></a>
<a class="sourceLine" id="cb1-260" title="260"><span class="co">-- you can make a for function using map</span></a>
<a class="sourceLine" id="cb1-261" title="261">for array func <span class="ot">=</span> <span class="fu">map</span> func array</a>
<a class="sourceLine" id="cb1-262" title="262"></a>
<a class="sourceLine" id="cb1-263" title="263"><span class="co">-- and then use it</span></a>
<a class="sourceLine" id="cb1-264" title="264">for [<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>] <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="fu">show</span> i</a>
<a class="sourceLine" id="cb1-265" title="265"></a>
<a class="sourceLine" id="cb1-266" title="266"><span class="co">-- we could&#39;ve written that like this too:</span></a>
<a class="sourceLine" id="cb1-267" title="267">for [<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>] <span class="fu">show</span></a>
<a class="sourceLine" id="cb1-268" title="268"></a>
<a class="sourceLine" id="cb1-269" title="269"><span class="co">-- You can use foldl or foldr to reduce a list</span></a>
<a class="sourceLine" id="cb1-270" title="270"><span class="co">-- foldl &lt;fn&gt; &lt;initial value&gt; &lt;list&gt;</span></a>
<a class="sourceLine" id="cb1-271" title="271"><span class="fu">foldl</span> (\x y <span class="ot">-&gt;</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">+</span> y) <span class="dv">4</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="co">-- 43</span></a>
<a class="sourceLine" id="cb1-272" title="272"></a>
<a class="sourceLine" id="cb1-273" title="273"><span class="co">-- This is the same as</span></a>
<a class="sourceLine" id="cb1-274" title="274">(<span class="dv">2</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">2</span>) <span class="op">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-275" title="275"></a>
<a class="sourceLine" id="cb1-276" title="276"><span class="co">-- foldl is left-handed, foldr is right-handed</span></a>
<a class="sourceLine" id="cb1-277" title="277"><span class="fu">foldr</span> (\x y <span class="ot">-&gt;</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">+</span> y) <span class="dv">4</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="co">-- 16</span></a>
<a class="sourceLine" id="cb1-278" title="278"></a>
<a class="sourceLine" id="cb1-279" title="279"><span class="co">-- This is now the same as</span></a>
<a class="sourceLine" id="cb1-280" title="280">(<span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)))</a>
<a class="sourceLine" id="cb1-281" title="281"></a>
<a class="sourceLine" id="cb1-282" title="282"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-283" title="283"><span class="co">-- 7. Data Types</span></a>
<a class="sourceLine" id="cb1-284" title="284"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-285" title="285"></a>
<a class="sourceLine" id="cb1-286" title="286"><span class="co">-- A data type is declared with a &#39;type constructor&#39; on the left</span></a>
<a class="sourceLine" id="cb1-287" title="287"><span class="co">-- and one or more &#39;data constructors&#39; on the right, separated by</span></a>
<a class="sourceLine" id="cb1-288" title="288"><span class="co">-- the pipe | symbol. This is a sum/union type. Each data constructor</span></a>
<a class="sourceLine" id="cb1-289" title="289"><span class="co">-- is a (possibly nullary) function that creates an object of the type</span></a>
<a class="sourceLine" id="cb1-290" title="290"><span class="co">-- named by the type constructor.</span></a>
<a class="sourceLine" id="cb1-291" title="291"></a>
<a class="sourceLine" id="cb1-292" title="292"><span class="co">-- This is essentially an enum</span></a>
<a class="sourceLine" id="cb1-293" title="293"></a>
<a class="sourceLine" id="cb1-294" title="294"><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Blue</span> <span class="op">|</span> <span class="dt">Green</span></a>
<a class="sourceLine" id="cb1-295" title="295"></a>
<a class="sourceLine" id="cb1-296" title="296"><span class="co">-- Now you can use it in a function:</span></a>
<a class="sourceLine" id="cb1-297" title="297"></a>
<a class="sourceLine" id="cb1-298" title="298"><span class="ot">say ::</span> <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-299" title="299">say <span class="dt">Red</span>   <span class="ot">=</span> <span class="st">&quot;You are Red!&quot;</span></a>
<a class="sourceLine" id="cb1-300" title="300">say <span class="dt">Blue</span>  <span class="ot">=</span> <span class="st">&quot;You are Blue!&quot;</span></a>
<a class="sourceLine" id="cb1-301" title="301">say <span class="dt">Green</span> <span class="ot">=</span> <span class="st">&quot;You are Green!&quot;</span></a>
<a class="sourceLine" id="cb1-302" title="302"></a>
<a class="sourceLine" id="cb1-303" title="303"><span class="co">-- Note that the type constructor is used in the type signature</span></a>
<a class="sourceLine" id="cb1-304" title="304"><span class="co">-- and the data constructors are used in the body of the function</span></a>
<a class="sourceLine" id="cb1-305" title="305"><span class="co">-- Data constructors are primarily pattern-matched against</span></a>
<a class="sourceLine" id="cb1-306" title="306"></a>
<a class="sourceLine" id="cb1-307" title="307"><span class="co">-- This next one is a traditional container type holding two fields</span></a>
<a class="sourceLine" id="cb1-308" title="308"><span class="co">-- In a type declaration, data constructors take types as parameters</span></a>
<a class="sourceLine" id="cb1-309" title="309"><span class="co">-- Data constructors can have the same name as type constructors</span></a>
<a class="sourceLine" id="cb1-310" title="310"><span class="co">-- This is common where the type only has a single data constructor</span></a>
<a class="sourceLine" id="cb1-311" title="311"></a>
<a class="sourceLine" id="cb1-312" title="312"><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> <span class="dt">Float</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb1-313" title="313"></a>
<a class="sourceLine" id="cb1-314" title="314"><span class="co">-- This can be used in a function like:</span></a>
<a class="sourceLine" id="cb1-315" title="315"></a>
<a class="sourceLine" id="cb1-316" title="316"><span class="ot">distance ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb1-317" title="317">distance (<span class="dt">Point</span> x y) (<span class="dt">Point</span> x&#39; y&#39;) <span class="ot">=</span> <span class="fu">sqrt</span> <span class="op">$</span> dx <span class="op">+</span> dy</a>
<a class="sourceLine" id="cb1-318" title="318">    <span class="kw">where</span> dx <span class="ot">=</span> (x <span class="op">-</span> x&#39;) <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-319" title="319">          dy <span class="ot">=</span> (y <span class="op">-</span> y&#39;) <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-320" title="320">          </a>
<a class="sourceLine" id="cb1-321" title="321"><span class="co">-- Types can have multiple data constructors with arguments, too</span></a>
<a class="sourceLine" id="cb1-322" title="322"></a>
<a class="sourceLine" id="cb1-323" title="323"><span class="kw">data</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">Mononym</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-324" title="324">          <span class="op">|</span> <span class="dt">FirstLastName</span> <span class="dt">String</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-325" title="325">          <span class="op">|</span> <span class="dt">FullName</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-326" title="326"></a>
<a class="sourceLine" id="cb1-327" title="327"><span class="co">-- To make things clearer we can use record syntax</span></a>
<a class="sourceLine" id="cb1-328" title="328"></a>
<a class="sourceLine" id="cb1-329" title="329"><span class="kw">data</span> <span class="dt">Point2D</span> <span class="ot">=</span> <span class="dt">CartesianPoint2D</span> {<span class="ot"> x ::</span> <span class="dt">Float</span>,<span class="ot"> y ::</span> <span class="dt">Float</span> } </a>
<a class="sourceLine" id="cb1-330" title="330">             <span class="op">|</span> <span class="dt">PolarPoint2D</span> {<span class="ot"> r ::</span> <span class="dt">Float</span>,<span class="ot"> theta ::</span> <span class="dt">Float</span> }</a>
<a class="sourceLine" id="cb1-331" title="331"></a>
<a class="sourceLine" id="cb1-332" title="332">myPoint <span class="ot">=</span> <span class="dt">CartesianPoint2D</span> { x <span class="ot">=</span> <span class="fl">7.0</span>, y <span class="ot">=</span> <span class="fl">10.0</span> }</a>
<a class="sourceLine" id="cb1-333" title="333"></a>
<a class="sourceLine" id="cb1-334" title="334"><span class="co">-- Using record syntax automatically creates accessor functions</span></a>
<a class="sourceLine" id="cb1-335" title="335"><span class="co">-- (the name of the field)</span></a>
<a class="sourceLine" id="cb1-336" title="336"></a>
<a class="sourceLine" id="cb1-337" title="337">xOfMyPoint <span class="ot">=</span> x myPoint</a>
<a class="sourceLine" id="cb1-338" title="338"></a>
<a class="sourceLine" id="cb1-339" title="339"><span class="co">-- xOfMyPoint is equal to 7.0</span></a>
<a class="sourceLine" id="cb1-340" title="340"></a>
<a class="sourceLine" id="cb1-341" title="341"><span class="co">-- Record syntax also allows a simple form of update</span></a>
<a class="sourceLine" id="cb1-342" title="342"></a>
<a class="sourceLine" id="cb1-343" title="343">myPoint&#39; <span class="ot">=</span> myPoint { x <span class="ot">=</span> <span class="fl">9.0</span> }</a>
<a class="sourceLine" id="cb1-344" title="344"></a>
<a class="sourceLine" id="cb1-345" title="345"><span class="co">-- myPoint&#39; is CartesianPoint2D { x = 9.0, y = 10.0 }</span></a>
<a class="sourceLine" id="cb1-346" title="346"></a>
<a class="sourceLine" id="cb1-347" title="347"><span class="co">-- Even if a type is defined with record syntax, it can be declared like</span></a>
<a class="sourceLine" id="cb1-348" title="348"><span class="co">-- a simple data constructor. This is fine:</span></a>
<a class="sourceLine" id="cb1-349" title="349"></a>
<a class="sourceLine" id="cb1-350" title="350">myPoint&#39;2 <span class="ot">=</span> <span class="dt">CartesianPoint2D</span> <span class="fl">3.3</span> <span class="fl">4.0</span></a>
<a class="sourceLine" id="cb1-351" title="351"></a>
<a class="sourceLine" id="cb1-352" title="352"><span class="co">-- It&#39;s also useful to pattern match data constructors in `case` expressions</span></a>
<a class="sourceLine" id="cb1-353" title="353"></a>
<a class="sourceLine" id="cb1-354" title="354">distanceFromOrigin x <span class="ot">=</span> </a>
<a class="sourceLine" id="cb1-355" title="355">    <span class="kw">case</span> x <span class="kw">of</span> (<span class="dt">CartesianPoint2D</span> x y) <span class="ot">-&gt;</span> <span class="fu">sqrt</span> <span class="op">$</span> x <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> y <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-356" title="356">              (<span class="dt">PolarPoint2D</span> r _) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb1-357" title="357"></a>
<a class="sourceLine" id="cb1-358" title="358"><span class="co">-- Your data types can have type parameters too:</span></a>
<a class="sourceLine" id="cb1-359" title="359"></a>
<a class="sourceLine" id="cb1-360" title="360"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb1-361" title="361"></a>
<a class="sourceLine" id="cb1-362" title="362"><span class="co">-- These are all of type Maybe</span></a>
<a class="sourceLine" id="cb1-363" title="363"><span class="dt">Just</span> <span class="st">&quot;hello&quot;</span>    <span class="co">-- of type `Maybe String`</span></a>
<a class="sourceLine" id="cb1-364" title="364"><span class="dt">Just</span> <span class="dv">1</span>          <span class="co">-- of type `Maybe Int`</span></a>
<a class="sourceLine" id="cb1-365" title="365"><span class="dt">Nothing</span>         <span class="co">-- of type `Maybe a` for any `a`</span></a>
<a class="sourceLine" id="cb1-366" title="366"></a>
<a class="sourceLine" id="cb1-367" title="367"><span class="co">-- For convenience we can also create type synonyms with the &#39;type&#39; keyword</span></a>
<a class="sourceLine" id="cb1-368" title="368"></a>
<a class="sourceLine" id="cb1-369" title="369"><span class="kw">type</span> <span class="dt">String</span> <span class="ot">=</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb1-370" title="370"></a>
<a class="sourceLine" id="cb1-371" title="371"><span class="co">-- Unlike `data` types, type synonyms need no constructor, and can be used </span></a>
<a class="sourceLine" id="cb1-372" title="372"><span class="co">-- anywhere a synonymous data type could be used. Say we have the </span></a>
<a class="sourceLine" id="cb1-373" title="373"><span class="co">-- following type synonyms and items with the following type signatures</span></a>
<a class="sourceLine" id="cb1-374" title="374"></a>
<a class="sourceLine" id="cb1-375" title="375"><span class="kw">type</span> <span class="dt">Weight</span> <span class="ot">=</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb1-376" title="376"><span class="kw">type</span> <span class="dt">Height</span> <span class="ot">=</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb1-377" title="377"><span class="kw">type</span> <span class="dt">Point</span> <span class="ot">=</span> (<span class="dt">Float</span>, <span class="dt">Float</span>)</a>
<a class="sourceLine" id="cb1-378" title="378"><span class="ot">getMyHeightAndWeight ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> (<span class="dt">Height</span>, <span class="dt">Weight</span>)</a>
<a class="sourceLine" id="cb1-379" title="379"><span class="ot">findCenter ::</span> <span class="dt">Circle</span> <span class="ot">-&gt;</span> <span class="dt">Point</span></a>
<a class="sourceLine" id="cb1-380" title="380"><span class="ot">somePerson ::</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb1-381" title="381"><span class="ot">someCircle ::</span> <span class="dt">Circle</span></a>
<a class="sourceLine" id="cb1-382" title="382"><span class="ot">distance ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb1-383" title="383"></a>
<a class="sourceLine" id="cb1-384" title="384"><span class="co">-- The following would compile and run without issue, </span></a>
<a class="sourceLine" id="cb1-385" title="385"><span class="co">-- even though it does not make sense semantically,</span></a>
<a class="sourceLine" id="cb1-386" title="386"><span class="co">-- because the type synonyms reduce to the same base types</span></a>
<a class="sourceLine" id="cb1-387" title="387"></a>
<a class="sourceLine" id="cb1-388" title="388">distance (getMyHeightAndWeight somePerson) (findCenter someCircle)</a>
<a class="sourceLine" id="cb1-389" title="389"></a>
<a class="sourceLine" id="cb1-390" title="390"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-391" title="391"><span class="co">-- 8. Typeclasses</span></a>
<a class="sourceLine" id="cb1-392" title="392"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-393" title="393"></a>
<a class="sourceLine" id="cb1-394" title="394"><span class="co">-- Typeclasses are one way Haskell does polymorphism</span></a>
<a class="sourceLine" id="cb1-395" title="395"><span class="co">-- They are similar to interfaces in other languages</span></a>
<a class="sourceLine" id="cb1-396" title="396"><span class="co">-- A typeclass defines a set of functions that must </span></a>
<a class="sourceLine" id="cb1-397" title="397"><span class="co">-- work on any type that is in that typeclass.</span></a>
<a class="sourceLine" id="cb1-398" title="398"></a>
<a class="sourceLine" id="cb1-399" title="399"><span class="co">-- The Eq typeclass is for types whose instances can </span></a>
<a class="sourceLine" id="cb1-400" title="400"><span class="co">-- be tested for equality with one another.</span></a>
<a class="sourceLine" id="cb1-401" title="401"></a>
<a class="sourceLine" id="cb1-402" title="402"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb1-403" title="403"><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  </a>
<a class="sourceLine" id="cb1-404" title="404"><span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  </a>
<a class="sourceLine" id="cb1-405" title="405">    x <span class="op">==</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">/=</span> y)  </a>
<a class="sourceLine" id="cb1-406" title="406">    x <span class="op">/=</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">==</span> y)</a>
<a class="sourceLine" id="cb1-407" title="407">    </a>
<a class="sourceLine" id="cb1-408" title="408"><span class="co">-- This defines a typeclass that requires two functions, (==) and (/=)</span></a>
<a class="sourceLine" id="cb1-409" title="409"><span class="co">-- It also declares that one function can be declared in terms of another</span></a>
<a class="sourceLine" id="cb1-410" title="410"><span class="co">-- So it is enough that *either* the (==) function or the (/=) is defined</span></a>
<a class="sourceLine" id="cb1-411" title="411"><span class="co">-- And the other will be &#39;filled in&#39; based on the typeclass definition</span></a>
<a class="sourceLine" id="cb1-412" title="412"></a>
<a class="sourceLine" id="cb1-413" title="413"><span class="co">-- To make a type a member of a type class, the instance keyword is used</span></a>
<a class="sourceLine" id="cb1-414" title="414"></a>
<a class="sourceLine" id="cb1-415" title="415"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">TrafficLight</span> <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb1-416" title="416">    <span class="dt">Red</span> <span class="op">==</span> <span class="dt">Red</span> <span class="ot">=</span> <span class="dt">True</span>  </a>
<a class="sourceLine" id="cb1-417" title="417">    <span class="dt">Green</span> <span class="op">==</span> <span class="dt">Green</span> <span class="ot">=</span> <span class="dt">True</span>  </a>
<a class="sourceLine" id="cb1-418" title="418">    <span class="dt">Yellow</span> <span class="op">==</span> <span class="dt">Yellow</span> <span class="ot">=</span> <span class="dt">True</span>  </a>
<a class="sourceLine" id="cb1-419" title="419">    _ <span class="op">==</span> _ <span class="ot">=</span> <span class="dt">False</span> </a>
<a class="sourceLine" id="cb1-420" title="420">    </a>
<a class="sourceLine" id="cb1-421" title="421"><span class="co">-- Now we can use (==) and (/=) with TrafficLight objects</span></a>
<a class="sourceLine" id="cb1-422" title="422"></a>
<a class="sourceLine" id="cb1-423" title="423"><span class="ot">canProceedThrough ::</span> <span class="dt">TrafficLight</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-424" title="424">canProceedThrough t <span class="ot">=</span> t <span class="op">/=</span> <span class="dt">Red</span></a>
<a class="sourceLine" id="cb1-425" title="425"></a>
<a class="sourceLine" id="cb1-426" title="426"><span class="co">-- You can NOT create an instance definition for a type synonym</span></a>
<a class="sourceLine" id="cb1-427" title="427"></a>
<a class="sourceLine" id="cb1-428" title="428"><span class="co">-- Functions can be written to take typeclasses with type parameters, </span></a>
<a class="sourceLine" id="cb1-429" title="429"><span class="co">-- rather than types, assuming that the function only relies on </span></a>
<a class="sourceLine" id="cb1-430" title="430"><span class="co">-- features of the typeclass</span></a>
<a class="sourceLine" id="cb1-431" title="431"></a>
<a class="sourceLine" id="cb1-432" title="432">isEqual (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-433" title="433">isEqual x y <span class="ot">=</span> x <span class="op">==</span> y</a>
<a class="sourceLine" id="cb1-434" title="434"></a>
<a class="sourceLine" id="cb1-435" title="435"><span class="co">-- Note that x and y MUST be the same type, as they are both defined</span></a>
<a class="sourceLine" id="cb1-436" title="436"><span class="co">-- as being of type parameter &#39;a&#39;.</span></a>
<a class="sourceLine" id="cb1-437" title="437"><span class="co">-- A typeclass does not state that different types in the typeclass can </span></a>
<a class="sourceLine" id="cb1-438" title="438"><span class="co">-- be mixed together.</span></a>
<a class="sourceLine" id="cb1-439" title="439"><span class="co">-- So `isEqual Red 2` is invalid, even though 2 is an Int which is an </span></a>
<a class="sourceLine" id="cb1-440" title="440"><span class="co">-- instance of Eq, and Red is a TrafficLight which is also an instance of Eq</span></a>
<a class="sourceLine" id="cb1-441" title="441"></a>
<a class="sourceLine" id="cb1-442" title="442"><span class="co">-- Other common typeclasses are:</span></a>
<a class="sourceLine" id="cb1-443" title="443"><span class="co">-- Ord for types that can be ordered, allowing you to use &gt;, &lt;=, etc.</span></a>
<a class="sourceLine" id="cb1-444" title="444"><span class="co">-- Read for types that can be created from a string representation</span></a>
<a class="sourceLine" id="cb1-445" title="445"><span class="co">-- Show for types that can be converted to a string for display</span></a>
<a class="sourceLine" id="cb1-446" title="446"><span class="co">-- Num, Real, Integral, Fractional for types that can do math</span></a>
<a class="sourceLine" id="cb1-447" title="447"><span class="co">-- Enum for types that can be stepped through</span></a>
<a class="sourceLine" id="cb1-448" title="448"><span class="co">-- Bounded for types with a maximum and minimum</span></a>
<a class="sourceLine" id="cb1-449" title="449"></a>
<a class="sourceLine" id="cb1-450" title="450"><span class="co">-- Haskell can automatically make types part of Eq, Ord, Read, Show, Enum, </span></a>
<a class="sourceLine" id="cb1-451" title="451"><span class="co">-- and Bounded with the `deriving` keyword at the end of the type declaration</span></a>
<a class="sourceLine" id="cb1-452" title="452"></a>
<a class="sourceLine" id="cb1-453" title="453"><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-454" title="454">    </a>
<a class="sourceLine" id="cb1-455" title="455"><span class="co">-- In this case it is NOT necessary to create an &#39;instance&#39; definition</span></a>
<a class="sourceLine" id="cb1-456" title="456"></a>
<a class="sourceLine" id="cb1-457" title="457"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-458" title="458"><span class="co">-- 9. Haskell IO</span></a>
<a class="sourceLine" id="cb1-459" title="459"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-460" title="460"></a>
<a class="sourceLine" id="cb1-461" title="461"><span class="co">-- While IO can&#39;t be explained fully without explaining monads,</span></a>
<a class="sourceLine" id="cb1-462" title="462"><span class="co">-- it is not hard to explain enough to get going.</span></a>
<a class="sourceLine" id="cb1-463" title="463"></a>
<a class="sourceLine" id="cb1-464" title="464"><span class="co">-- When a Haskell program is executed, `main` is</span></a>
<a class="sourceLine" id="cb1-465" title="465"><span class="co">-- called. It must return a value of type `IO a` for some type `a`. For example:</span></a>
<a class="sourceLine" id="cb1-466" title="466"></a>
<a class="sourceLine" id="cb1-467" title="467"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-468" title="468">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Hello, sky! &quot;</span> <span class="op">++</span> (say <span class="dt">Blue</span>)</a>
<a class="sourceLine" id="cb1-469" title="469"><span class="co">-- putStrLn has type String -&gt; IO ()</span></a>
<a class="sourceLine" id="cb1-470" title="470"></a>
<a class="sourceLine" id="cb1-471" title="471"><span class="co">-- It is easiest to do IO if you can implement your program as</span></a>
<a class="sourceLine" id="cb1-472" title="472"><span class="co">-- a function from String to String. The function</span></a>
<a class="sourceLine" id="cb1-473" title="473"><span class="co">--    interact :: (String -&gt; String) -&gt; IO ()</span></a>
<a class="sourceLine" id="cb1-474" title="474"><span class="co">-- inputs some text, runs a function on it, and prints out the</span></a>
<a class="sourceLine" id="cb1-475" title="475"><span class="co">-- output.</span></a>
<a class="sourceLine" id="cb1-476" title="476"></a>
<a class="sourceLine" id="cb1-477" title="477"><span class="ot">countLines ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-478" title="478">countLines <span class="ot">=</span> <span class="fu">show</span> <span class="op">.</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">lines</span></a>
<a class="sourceLine" id="cb1-479" title="479"></a>
<a class="sourceLine" id="cb1-480" title="480">main&#39; <span class="ot">=</span> <span class="fu">interact</span> countLines</a>
<a class="sourceLine" id="cb1-481" title="481"></a>
<a class="sourceLine" id="cb1-482" title="482"><span class="co">-- You can think of a value of type `IO ()` as representing a</span></a>
<a class="sourceLine" id="cb1-483" title="483"><span class="co">-- sequence of actions for the computer to do, much like a</span></a>
<a class="sourceLine" id="cb1-484" title="484"><span class="co">-- computer program written in an imperative language. We can use</span></a>
<a class="sourceLine" id="cb1-485" title="485"><span class="co">-- the `do` notation to chain actions together. For example:</span></a>
<a class="sourceLine" id="cb1-486" title="486"></a>
<a class="sourceLine" id="cb1-487" title="487"><span class="ot">sayHello ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-488" title="488">sayHello <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-489" title="489">   <span class="fu">putStrLn</span> <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb1-490" title="490">   name <span class="ot">&lt;-</span> <span class="fu">getLine</span> <span class="co">-- this gets a line and gives it the name &quot;name&quot;</span></a>
<a class="sourceLine" id="cb1-491" title="491">   <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Hello, &quot;</span> <span class="op">++</span> name</a>
<a class="sourceLine" id="cb1-492" title="492"></a>
<a class="sourceLine" id="cb1-493" title="493"><span class="co">-- Exercise: write your own version of `interact` that only reads</span></a>
<a class="sourceLine" id="cb1-494" title="494"><span class="co">--           one line of input.</span></a>
<a class="sourceLine" id="cb1-495" title="495"></a>
<a class="sourceLine" id="cb1-496" title="496"><span class="co">-- The code in `sayHello` will never be executed, however. The only</span></a>
<a class="sourceLine" id="cb1-497" title="497"><span class="co">-- action that ever gets executed is the value of `main`.</span></a>
<a class="sourceLine" id="cb1-498" title="498"><span class="co">-- To run `sayHello` comment out the above definition of `main`</span></a>
<a class="sourceLine" id="cb1-499" title="499"><span class="co">-- and replace it with:</span></a>
<a class="sourceLine" id="cb1-500" title="500"><span class="co">--   main = sayHello</span></a>
<a class="sourceLine" id="cb1-501" title="501"></a>
<a class="sourceLine" id="cb1-502" title="502"><span class="co">-- Let&#39;s understand better how the function `getLine` we just</span></a>
<a class="sourceLine" id="cb1-503" title="503"><span class="co">-- used works. Its type is:</span></a>
<a class="sourceLine" id="cb1-504" title="504"><span class="co">--    getLine :: IO String</span></a>
<a class="sourceLine" id="cb1-505" title="505"><span class="co">-- You can think of a value of type `IO a` as representing a</span></a>
<a class="sourceLine" id="cb1-506" title="506"><span class="co">-- computer program that will generate a value of type `a`</span></a>
<a class="sourceLine" id="cb1-507" title="507"><span class="co">-- when executed (in addition to anything else it does). We can</span></a>
<a class="sourceLine" id="cb1-508" title="508"><span class="co">-- name and reuse this value using `&lt;-`. We can also</span></a>
<a class="sourceLine" id="cb1-509" title="509"><span class="co">-- make our own action of type `IO String`:</span></a>
<a class="sourceLine" id="cb1-510" title="510"></a>
<a class="sourceLine" id="cb1-511" title="511"><span class="ot">action ::</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-512" title="512">action <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-513" title="513">   <span class="fu">putStrLn</span> <span class="st">&quot;This is a line. Duh&quot;</span></a>
<a class="sourceLine" id="cb1-514" title="514">   input1 <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb1-515" title="515">   input2 <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb1-516" title="516">   <span class="co">-- The type of the `do` statement is that of its last line.</span></a>
<a class="sourceLine" id="cb1-517" title="517">   <span class="co">-- `return` is not a keyword, but merely a function</span></a>
<a class="sourceLine" id="cb1-518" title="518">   <span class="fu">return</span> (input1 <span class="op">++</span> <span class="st">&quot;\n&quot;</span> <span class="op">++</span> input2) <span class="co">-- return :: String -&gt; IO String</span></a>
<a class="sourceLine" id="cb1-519" title="519"></a>
<a class="sourceLine" id="cb1-520" title="520"><span class="co">-- We can use this just like we used `getLine`:</span></a>
<a class="sourceLine" id="cb1-521" title="521"></a>
<a class="sourceLine" id="cb1-522" title="522">main&#39;&#39; <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-523" title="523">    <span class="fu">putStrLn</span> <span class="st">&quot;I will echo two lines!&quot;</span></a>
<a class="sourceLine" id="cb1-524" title="524">    result <span class="ot">&lt;-</span> action</a>
<a class="sourceLine" id="cb1-525" title="525">    <span class="fu">putStrLn</span> result</a>
<a class="sourceLine" id="cb1-526" title="526">    <span class="fu">putStrLn</span> <span class="st">&quot;This was all, folks!&quot;</span></a>
<a class="sourceLine" id="cb1-527" title="527"></a>
<a class="sourceLine" id="cb1-528" title="528"><span class="co">-- The type `IO` is an example of a &quot;monad&quot;. The way Haskell uses a monad to</span></a>
<a class="sourceLine" id="cb1-529" title="529"><span class="co">-- do IO allows it to be a purely functional language. Any function that</span></a>
<a class="sourceLine" id="cb1-530" title="530"><span class="co">-- interacts with the outside world (i.e. does IO) gets marked as `IO` in its</span></a>
<a class="sourceLine" id="cb1-531" title="531"><span class="co">-- type signature. This lets us reason about which functions are &quot;pure&quot; (don&#39;t</span></a>
<a class="sourceLine" id="cb1-532" title="532"><span class="co">-- interact with the outside world or modify state) and which functions aren&#39;t.</span></a>
<a class="sourceLine" id="cb1-533" title="533"></a>
<a class="sourceLine" id="cb1-534" title="534"><span class="co">-- This is a powerful feature, because it&#39;s easy to run pure functions</span></a>
<a class="sourceLine" id="cb1-535" title="535"><span class="co">-- concurrently; so, concurrency in Haskell is very easy.</span></a>
<a class="sourceLine" id="cb1-536" title="536"></a>
<a class="sourceLine" id="cb1-537" title="537"></a>
<a class="sourceLine" id="cb1-538" title="538"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-539" title="539"><span class="co">-- 10. The Haskell REPL</span></a>
<a class="sourceLine" id="cb1-540" title="540"><span class="co">----------------------------------------------------</span></a>
<a class="sourceLine" id="cb1-541" title="541"></a>
<a class="sourceLine" id="cb1-542" title="542"><span class="co">-- Start the repl by typing `ghci`.</span></a>
<a class="sourceLine" id="cb1-543" title="543"><span class="co">-- Now you can type in Haskell code. Any new values</span></a>
<a class="sourceLine" id="cb1-544" title="544"><span class="co">-- need to be created with `let`:</span></a>
<a class="sourceLine" id="cb1-545" title="545"></a>
<a class="sourceLine" id="cb1-546" title="546"><span class="kw">let</span> foo <span class="ot">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb1-547" title="547"></a>
<a class="sourceLine" id="cb1-548" title="548"><span class="co">-- You can see the type of any value or expression with `:t`:</span></a>
<a class="sourceLine" id="cb1-549" title="549"></a>
<a class="sourceLine" id="cb1-550" title="550"><span class="op">&gt;</span> <span class="op">:</span>t foo</a>
<a class="sourceLine" id="cb1-551" title="551"><span class="ot">foo ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-552" title="552"></a>
<a class="sourceLine" id="cb1-553" title="553"><span class="co">-- Operators, such as `+`, `:` and `$`, are functions.</span></a>
<a class="sourceLine" id="cb1-554" title="554"><span class="co">-- Their type can be inspected by putting the operator in parentheses:</span></a>
<a class="sourceLine" id="cb1-555" title="555"></a>
<a class="sourceLine" id="cb1-556" title="556"><span class="op">&gt;</span> <span class="op">:</span>t (<span class="op">:</span>)</a>
<a class="sourceLine" id="cb1-557" title="557"><span class="ot">(:) ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-558" title="558"></a>
<a class="sourceLine" id="cb1-559" title="559"><span class="co">-- You can get additional information on any `name` using `:i`:</span></a>
<a class="sourceLine" id="cb1-560" title="560"></a>
<a class="sourceLine" id="cb1-561" title="561"><span class="op">&gt;</span> <span class="op">:</span>i (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb1-562" title="562"><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-563" title="563"><span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-564" title="564">  <span class="op">...</span></a>
<a class="sourceLine" id="cb1-565" title="565">    <span class="co">-- Defined in â€˜GHC.Numâ€™</span></a>
<a class="sourceLine" id="cb1-566" title="566"><span class="kw">infixl</span> <span class="dv">6</span> <span class="op">+</span></a>
<a class="sourceLine" id="cb1-567" title="567"></a>
<a class="sourceLine" id="cb1-568" title="568"><span class="co">-- You can also run any action of type `IO ()`</span></a>
<a class="sourceLine" id="cb1-569" title="569"></a>
<a class="sourceLine" id="cb1-570" title="570"><span class="op">&gt;</span> sayHello</a>
<a class="sourceLine" id="cb1-571" title="571"><span class="dt">What</span> is your name<span class="op">?</span></a>
<a class="sourceLine" id="cb1-572" title="572"><span class="dt">Friend</span><span class="op">!</span></a>
<a class="sourceLine" id="cb1-573" title="573"><span class="dt">Hello</span>, <span class="dt">Friend</span><span class="op">!</span></a></code></pre>
    </div>
    <p>
      Thereâ€™s a lot more to Haskell, including typeclasses and monads. These are
      the big ideas that make Haskell such fun to code in. Iâ€™ll leave you with
      one final Haskell example: an implementation of a quicksort variant in
      Haskell:
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode haskell"
      ><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">qsort [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb2-2" title="2">qsort (p<span class="op">:</span>xs) <span class="ot">=</span> qsort lesser <span class="op">++</span> [p] <span class="op">++</span> qsort greater</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">where</span> lesser  <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">&lt;</span> p) xs</a>
<a class="sourceLine" id="cb2-4" title="4">          greater <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">&gt;=</span> p) xs</a></code></pre>
    </div>
    <p>
      There are two popular ways to install Haskell: The traditional
      <a href="http://www.haskell.org/platform/">Cabal-based installation</a>,
      and the newer
      <a href="https://www.stackage.org/install">Stack-based process</a>.
    </p>
    <p>
      You can find a much gentler introduction from the excellent
      <a href="http://learnyouahaskell.com/">Learn you a Haskell</a>,
      <a href="http://www.happylearnhaskelltutorial.com/"
        >Happy Learn Haskell Tutorial</a
      >
      or <a href="http://book.realworldhaskell.org/">Real World Haskell</a>.
    </p>
  </body>
</html>
