<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>clojure.html</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <p>
      Clojure is a Lisp family language developed for the Java Virtual Machine.
      It has a much stronger emphasis on pure
      <a href="https://en.wikipedia.org/wiki/Functional_programming"
        >functional programming</a
      >
      than Common Lisp, but includes several
      <a href="https://en.wikipedia.org/wiki/Software_transactional_memory"
        >STM</a
      >
      utilities to handle state as it comes up.
    </p>
    <p>
      This combination allows it to handle concurrent processing very simply,
      and often automatically.
    </p>
    <p>(You need a version of Clojure 1.2 or newer)</p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode clojure"
      ><code class="sourceCode clojure"><a class="sourceLine" id="cb1-1" title="1"><span class="co">; Comments start with semicolons.</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">; Clojure is written in &quot;forms&quot;, which are just</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">; lists of things inside parentheses, separated by whitespace.</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">; The clojure reader assumes that the first thing is a</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">; function or macro to call, and the rest are arguments.</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">; The first call in a file should be ns, to set the namespace</span></a>
<a class="sourceLine" id="cb1-10" title="10">(<span class="kw">ns</span> learnclojure)</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">; More basic examples:</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co">; str will create a string out of all its arguments</span></a>
<a class="sourceLine" id="cb1-15" title="15">(<span class="kw">str</span> <span class="st">&quot;Hello&quot;</span> <span class="st">&quot; &quot;</span> <span class="st">&quot;World&quot;</span>) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">; Math is straightforward</span></a>
<a class="sourceLine" id="cb1-18" title="18">(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-19" title="19">(<span class="kw">-</span> <span class="dv">2</span> <span class="dv">1</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-20" title="20">(<span class="kw">*</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-21" title="21">(<span class="kw">/</span> <span class="dv">2</span> <span class="dv">1</span>) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">; Equality is =</span></a>
<a class="sourceLine" id="cb1-24" title="24">(<span class="kw">=</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-25" title="25">(<span class="kw">=</span> <span class="dv">2</span> <span class="dv">1</span>) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">; You need not for logic, too</span></a>
<a class="sourceLine" id="cb1-28" title="28">(<span class="kw">not</span> <span class="va">true</span>) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="co">; Nesting forms works as you expect</span></a>
<a class="sourceLine" id="cb1-31" title="31">(<span class="kw">+</span> <span class="dv">1</span> (<span class="kw">-</span> <span class="dv">3</span> <span class="dv">2</span>)) <span class="co">; = 1 + (3 - 2) =&gt; 2</span></a>
<a class="sourceLine" id="cb1-32" title="32"></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="co">; Types</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="co">;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-35" title="35"></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="co">; Clojure uses Java&#39;s object types for booleans, strings and numbers.</span></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="co">; Use `class` to inspect them.</span></a>
<a class="sourceLine" id="cb1-38" title="38">(<span class="kw">class</span> <span class="dv">1</span>) <span class="co">; Integer literals are java.lang.Long by default</span></a>
<a class="sourceLine" id="cb1-39" title="39">(<span class="kw">class</span> <span class="fl">1.</span>)<span class="co">; Float literals are java.lang.Double</span></a>
<a class="sourceLine" id="cb1-40" title="40">(<span class="kw">class</span> <span class="st">&quot;&quot;</span>)<span class="co">; Strings always double-quoted, and are java.lang.String</span></a>
<a class="sourceLine" id="cb1-41" title="41">(<span class="kw">class</span> <span class="va">false</span>) <span class="co">; Booleans are java.lang.Boolean</span></a>
<a class="sourceLine" id="cb1-42" title="42">(<span class="kw">class</span> <span class="va">nil</span>)<span class="co">; The &quot;null&quot; value is called nil</span></a>
<a class="sourceLine" id="cb1-43" title="43"></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="co">; If you want to create a literal list of data, use &#39; to stop it from</span></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="co">; being evaluated</span></a>
<a class="sourceLine" id="cb1-46" title="46">&#39;(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">; =&gt; (+ 1 2)</span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">; (shorthand for (quote (+ 1 2)))</span></a>
<a class="sourceLine" id="cb1-48" title="48"></a>
<a class="sourceLine" id="cb1-49" title="49"><span class="co">; You can eval a quoted list</span></a>
<a class="sourceLine" id="cb1-50" title="50">(<span class="kw">eval</span> &#39;(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; =&gt; 3</span></a>
<a class="sourceLine" id="cb1-51" title="51"></a>
<a class="sourceLine" id="cb1-52" title="52"><span class="co">; Collections &amp; Sequences</span></a>
<a class="sourceLine" id="cb1-53" title="53"><span class="co">;;;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-54" title="54"></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="co">; Lists are linked-list data structures, while Vectors are array-backed.</span></a>
<a class="sourceLine" id="cb1-56" title="56"><span class="co">; Vectors and Lists are java classes too!</span></a>
<a class="sourceLine" id="cb1-57" title="57">(<span class="kw">class</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])<span class="co">; =&gt; clojure.lang.PersistentVector</span></a>
<a class="sourceLine" id="cb1-58" title="58">(<span class="kw">class</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))<span class="co">; =&gt; clojure.lang.PersistentList</span></a>
<a class="sourceLine" id="cb1-59" title="59"></a>
<a class="sourceLine" id="cb1-60" title="60"><span class="co">; A list would be written as just (1 2 3), but we have to quote</span></a>
<a class="sourceLine" id="cb1-61" title="61"><span class="co">; it to stop the reader thinking it&#39;s a function.</span></a>
<a class="sourceLine" id="cb1-62" title="62"><span class="co">; Also, (list 1 2 3) is the same as &#39;(1 2 3)</span></a>
<a class="sourceLine" id="cb1-63" title="63"></a>
<a class="sourceLine" id="cb1-64" title="64"><span class="co">; &quot;Collections&quot; are just groups of data</span></a>
<a class="sourceLine" id="cb1-65" title="65"><span class="co">; Both lists and vectors are collections:</span></a>
<a class="sourceLine" id="cb1-66" title="66">(<span class="kw">coll?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-67" title="67">(<span class="kw">coll?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69"><span class="co">; &quot;Sequences&quot; (seqs) are abstract descriptions of lists of data.</span></a>
<a class="sourceLine" id="cb1-70" title="70"><span class="co">; Only lists are seqs.</span></a>
<a class="sourceLine" id="cb1-71" title="71">(<span class="kw">seq?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-72" title="72">(<span class="kw">seq?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-73" title="73"></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="co">; A seq need only provide an entry when it is accessed.</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">; So, seqs which can be lazy -- they can define infinite series:</span></a>
<a class="sourceLine" id="cb1-76" title="76">(<span class="kw">range</span> <span class="dv">4</span>) <span class="co">; =&gt; (0 1 2 3)</span></a>
<a class="sourceLine" id="cb1-77" title="77">(<span class="kw">range</span>) <span class="co">; =&gt; (0 1 2 3 4 ...) (an infinite series)</span></a>
<a class="sourceLine" id="cb1-78" title="78">(<span class="kw">take</span> <span class="dv">4</span> (<span class="kw">range</span>)) <span class="co">;  (0 1 2 3)</span></a>
<a class="sourceLine" id="cb1-79" title="79"></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">; Use cons to add an item to the beginning of a list or vector</span></a>
<a class="sourceLine" id="cb1-81" title="81">(<span class="kw">cons</span> <span class="dv">4</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; (4 1 2 3)</span></a>
<a class="sourceLine" id="cb1-82" title="82">(<span class="kw">cons</span> <span class="dv">4</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; =&gt; (4 1 2 3)</span></a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="co">; Conj will add an item to a collection in the most efficient way.</span></a>
<a class="sourceLine" id="cb1-85" title="85"><span class="co">; For lists, they insert at the beginning. For vectors, they insert at the end.</span></a>
<a class="sourceLine" id="cb1-86" title="86">(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] <span class="dv">4</span>) <span class="co">; =&gt; [1 2 3 4]</span></a>
<a class="sourceLine" id="cb1-87" title="87">(<span class="kw">conj</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="dv">4</span>) <span class="co">; =&gt; (4 1 2 3)</span></a>
<a class="sourceLine" id="cb1-88" title="88"></a>
<a class="sourceLine" id="cb1-89" title="89"><span class="co">; Use concat to add lists or vectors together</span></a>
<a class="sourceLine" id="cb1-90" title="90">(<span class="kw">concat</span> [<span class="dv">1</span> <span class="dv">2</span>] &#39;(<span class="dv">3</span> <span class="dv">4</span>)) <span class="co">; =&gt; (1 2 3 4)</span></a>
<a class="sourceLine" id="cb1-91" title="91"></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="co">; Use filter, map to interact with collections</span></a>
<a class="sourceLine" id="cb1-93" title="93">(<span class="kw">map</span> <span class="kw">inc</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; (2 3 4)</span></a>
<a class="sourceLine" id="cb1-94" title="94">(<span class="kw">filter</span> <span class="kw">even?</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; =&gt; (2)</span></a>
<a class="sourceLine" id="cb1-95" title="95"></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="co">; Use reduce to reduce them</span></a>
<a class="sourceLine" id="cb1-97" title="97">(<span class="kw">reduce</span> <span class="kw">+</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])</a>
<a class="sourceLine" id="cb1-98" title="98"><span class="co">; = (+ (+ (+ 1 2) 3) 4)</span></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="co">; =&gt; 10</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101"><span class="co">; Reduce can take an initial-value argument too</span></a>
<a class="sourceLine" id="cb1-102" title="102">(<span class="kw">reduce</span> <span class="kw">conj</span> [] &#39;(<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb1-103" title="103"><span class="co">; = (conj (conj (conj [] 3) 2) 1)</span></a>
<a class="sourceLine" id="cb1-104" title="104"><span class="co">; =&gt; [3 2 1]</span></a>
<a class="sourceLine" id="cb1-105" title="105"></a>
<a class="sourceLine" id="cb1-106" title="106"><span class="co">; Functions</span></a>
<a class="sourceLine" id="cb1-107" title="107"><span class="co">;;;;;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-108" title="108"></a>
<a class="sourceLine" id="cb1-109" title="109"><span class="co">; Use fn to create new functions. A function always returns</span></a>
<a class="sourceLine" id="cb1-110" title="110"><span class="co">; its last statement.</span></a>
<a class="sourceLine" id="cb1-111" title="111">(<span class="kw">fn</span> [] <span class="st">&quot;Hello World&quot;</span>) <span class="co">; =&gt; fn</span></a>
<a class="sourceLine" id="cb1-112" title="112"></a>
<a class="sourceLine" id="cb1-113" title="113"><span class="co">; (You need extra parens to call it)</span></a>
<a class="sourceLine" id="cb1-114" title="114">((<span class="kw">fn</span> [] <span class="st">&quot;Hello World&quot;</span>)) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-115" title="115"></a>
<a class="sourceLine" id="cb1-116" title="116"><span class="co">; You can create a var using def</span></a>
<a class="sourceLine" id="cb1-117" title="117">(<span class="bu">def</span><span class="fu"> x </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-118" title="118">x <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-119" title="119"></a>
<a class="sourceLine" id="cb1-120" title="120"><span class="co">; Assign a function to a var</span></a>
<a class="sourceLine" id="cb1-121" title="121">(<span class="bu">def</span><span class="fu"> hello-world </span>(<span class="kw">fn</span> [] <span class="st">&quot;Hello World&quot;</span>))</a>
<a class="sourceLine" id="cb1-122" title="122">(hello-world) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-123" title="123"></a>
<a class="sourceLine" id="cb1-124" title="124"><span class="co">; You can shorten this process by using defn</span></a>
<a class="sourceLine" id="cb1-125" title="125">(<span class="bu">defn</span><span class="fu"> hello-world </span>[] <span class="st">&quot;Hello World&quot;</span>)</a>
<a class="sourceLine" id="cb1-126" title="126"></a>
<a class="sourceLine" id="cb1-127" title="127"><span class="co">; The [] is the list of arguments for the function.</span></a>
<a class="sourceLine" id="cb1-128" title="128">(<span class="bu">defn</span><span class="fu"> hello </span>[<span class="kw">name</span>]</a>
<a class="sourceLine" id="cb1-129" title="129">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>))</a>
<a class="sourceLine" id="cb1-130" title="130">(hello <span class="st">&quot;Steve&quot;</span>) <span class="co">; =&gt; &quot;Hello Steve&quot;</span></a>
<a class="sourceLine" id="cb1-131" title="131"></a>
<a class="sourceLine" id="cb1-132" title="132"><span class="co">; You can also use this shorthand to create functions:</span></a>
<a class="sourceLine" id="cb1-133" title="133">(<span class="bu">def</span><span class="fu"> hello2 </span>#(<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="va">%1</span>))</a>
<a class="sourceLine" id="cb1-134" title="134">(hello2 <span class="st">&quot;Julie&quot;</span>) <span class="co">; =&gt; &quot;Hello Julie&quot;</span></a>
<a class="sourceLine" id="cb1-135" title="135"></a>
<a class="sourceLine" id="cb1-136" title="136"><span class="co">; You can have multi-variadic functions, too</span></a>
<a class="sourceLine" id="cb1-137" title="137">(<span class="bu">defn</span><span class="fu"> hello3</span></a>
<a class="sourceLine" id="cb1-138" title="138">  ([] <span class="st">&quot;Hello World&quot;</span>)</a>
<a class="sourceLine" id="cb1-139" title="139">  ([<span class="kw">name</span>] (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>)))</a>
<a class="sourceLine" id="cb1-140" title="140">(hello3 <span class="st">&quot;Jake&quot;</span>) <span class="co">; =&gt; &quot;Hello Jake&quot;</span></a>
<a class="sourceLine" id="cb1-141" title="141">(hello3) <span class="co">; =&gt; &quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb1-142" title="142"></a>
<a class="sourceLine" id="cb1-143" title="143"><span class="co">; Functions can pack extra arguments up in a seq for you</span></a>
<a class="sourceLine" id="cb1-144" title="144">(<span class="bu">defn</span><span class="fu"> count-args </span>[&amp; args]</a>
<a class="sourceLine" id="cb1-145" title="145">  (<span class="kw">str</span> <span class="st">&quot;You passed &quot;</span> (<span class="kw">count</span> args) <span class="st">&quot; args: &quot;</span> args))</a>
<a class="sourceLine" id="cb1-146" title="146">(count-args <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; =&gt; &quot;You passed 3 args: (1 2 3)&quot;</span></a>
<a class="sourceLine" id="cb1-147" title="147"></a>
<a class="sourceLine" id="cb1-148" title="148"><span class="co">; You can mix regular and packed arguments</span></a>
<a class="sourceLine" id="cb1-149" title="149">(<span class="bu">defn</span><span class="fu"> hello-count </span>[<span class="kw">name</span> &amp; args]</a>
<a class="sourceLine" id="cb1-150" title="150">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span> <span class="st">&quot;, you passed &quot;</span> (<span class="kw">count</span> args) <span class="st">&quot; extra args&quot;</span>))</a>
<a class="sourceLine" id="cb1-151" title="151">(hello-count <span class="st">&quot;Finn&quot;</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-152" title="152"><span class="co">; =&gt; &quot;Hello Finn, you passed 3 extra args&quot;</span></a>
<a class="sourceLine" id="cb1-153" title="153"></a>
<a class="sourceLine" id="cb1-154" title="154"></a>
<a class="sourceLine" id="cb1-155" title="155"><span class="co">; Maps</span></a>
<a class="sourceLine" id="cb1-156" title="156"><span class="co">;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-157" title="157"></a>
<a class="sourceLine" id="cb1-158" title="158"><span class="co">; Hash maps and array maps share an interface. Hash maps have faster lookups</span></a>
<a class="sourceLine" id="cb1-159" title="159"><span class="co">; but don&#39;t retain key order.</span></a>
<a class="sourceLine" id="cb1-160" title="160">(<span class="kw">class</span> {<span class="at">:a</span> <span class="dv">1</span> <span class="at">:b</span> <span class="dv">2</span> <span class="at">:c</span> <span class="dv">3</span>}) <span class="co">; =&gt; clojure.lang.PersistentArrayMap</span></a>
<a class="sourceLine" id="cb1-161" title="161">(<span class="kw">class</span> (<span class="kw">hash-map</span> <span class="at">:a</span> <span class="dv">1</span> <span class="at">:b</span> <span class="dv">2</span> <span class="at">:c</span> <span class="dv">3</span>)) <span class="co">; =&gt; clojure.lang.PersistentHashMap</span></a>
<a class="sourceLine" id="cb1-162" title="162"></a>
<a class="sourceLine" id="cb1-163" title="163"><span class="co">; Arraymaps will automatically become hashmaps through most operations</span></a>
<a class="sourceLine" id="cb1-164" title="164"><span class="co">; if they get big enough, so you don&#39;t need to worry.</span></a>
<a class="sourceLine" id="cb1-165" title="165"></a>
<a class="sourceLine" id="cb1-166" title="166"><span class="co">; Maps can use any hashable type as a key, but usually keywords are best</span></a>
<a class="sourceLine" id="cb1-167" title="167"><span class="co">; Keywords are like strings with some efficiency bonuses</span></a>
<a class="sourceLine" id="cb1-168" title="168">(<span class="kw">class</span> <span class="at">:a</span>) <span class="co">; =&gt; clojure.lang.Keyword</span></a>
<a class="sourceLine" id="cb1-169" title="169"></a>
<a class="sourceLine" id="cb1-170" title="170">(<span class="bu">def</span><span class="fu"> stringmap </span>{<span class="st">&quot;a&quot;</span> <span class="dv">1</span>, <span class="st">&quot;b&quot;</span> <span class="dv">2</span>, <span class="st">&quot;c&quot;</span> <span class="dv">3</span>})</a>
<a class="sourceLine" id="cb1-171" title="171">stringmap  <span class="co">; =&gt; {&quot;a&quot; 1, &quot;b&quot; 2, &quot;c&quot; 3}</span></a>
<a class="sourceLine" id="cb1-172" title="172"></a>
<a class="sourceLine" id="cb1-173" title="173">(<span class="bu">def</span><span class="fu"> keymap </span>{<span class="at">:a</span> <span class="dv">1</span>, <span class="at">:b</span> <span class="dv">2</span>, <span class="at">:c</span> <span class="dv">3</span>})</a>
<a class="sourceLine" id="cb1-174" title="174">keymap <span class="co">; =&gt; {:a 1, :c 3, :b 2}</span></a>
<a class="sourceLine" id="cb1-175" title="175"></a>
<a class="sourceLine" id="cb1-176" title="176"><span class="co">; By the way, commas are always treated as whitespace and do nothing.</span></a>
<a class="sourceLine" id="cb1-177" title="177"></a>
<a class="sourceLine" id="cb1-178" title="178"><span class="co">; Retrieve a value from a map by calling it as a function</span></a>
<a class="sourceLine" id="cb1-179" title="179">(stringmap <span class="st">&quot;a&quot;</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-180" title="180">(keymap <span class="at">:a</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-181" title="181"></a>
<a class="sourceLine" id="cb1-182" title="182"><span class="co">; Keywords can be used to retrieve their value from a map, too!</span></a>
<a class="sourceLine" id="cb1-183" title="183">(<span class="at">:b</span> keymap) <span class="co">; =&gt; 2</span></a>
<a class="sourceLine" id="cb1-184" title="184"></a>
<a class="sourceLine" id="cb1-185" title="185"><span class="co">; Don&#39;t try this with strings.</span></a>
<a class="sourceLine" id="cb1-186" title="186"><span class="co">;(&quot;a&quot; stringmap)</span></a>
<a class="sourceLine" id="cb1-187" title="187"><span class="co">; =&gt; Exception: java.lang.String cannot be cast to clojure.lang.IFn</span></a>
<a class="sourceLine" id="cb1-188" title="188"></a>
<a class="sourceLine" id="cb1-189" title="189"><span class="co">; Retrieving a non-present key returns nil</span></a>
<a class="sourceLine" id="cb1-190" title="190">(stringmap <span class="st">&quot;d&quot;</span>) <span class="co">; =&gt; nil</span></a>
<a class="sourceLine" id="cb1-191" title="191"></a>
<a class="sourceLine" id="cb1-192" title="192"><span class="co">; Use assoc to add new keys to hash-maps</span></a>
<a class="sourceLine" id="cb1-193" title="193">(<span class="bu">def</span><span class="fu"> newkeymap </span>(<span class="kw">assoc</span> keymap <span class="at">:d</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb1-194" title="194">newkeymap <span class="co">; =&gt; {:a 1, :b 2, :c 3, :d 4}</span></a>
<a class="sourceLine" id="cb1-195" title="195"></a>
<a class="sourceLine" id="cb1-196" title="196"><span class="co">; But remember, clojure types are immutable!</span></a>
<a class="sourceLine" id="cb1-197" title="197">keymap <span class="co">; =&gt; {:a 1, :b 2, :c 3}</span></a>
<a class="sourceLine" id="cb1-198" title="198"></a>
<a class="sourceLine" id="cb1-199" title="199"><span class="co">; Use dissoc to remove keys</span></a>
<a class="sourceLine" id="cb1-200" title="200">(<span class="kw">dissoc</span> keymap <span class="at">:a</span> <span class="at">:b</span>) <span class="co">; =&gt; {:c 3}</span></a>
<a class="sourceLine" id="cb1-201" title="201"></a>
<a class="sourceLine" id="cb1-202" title="202"><span class="co">; Sets</span></a>
<a class="sourceLine" id="cb1-203" title="203"><span class="co">;;;;;;</span></a>
<a class="sourceLine" id="cb1-204" title="204"></a>
<a class="sourceLine" id="cb1-205" title="205">(<span class="kw">class</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>}) <span class="co">; =&gt; clojure.lang.PersistentHashSet</span></a>
<a class="sourceLine" id="cb1-206" title="206">(<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>]) <span class="co">; =&gt; #{1 2 3}</span></a>
<a class="sourceLine" id="cb1-207" title="207"></a>
<a class="sourceLine" id="cb1-208" title="208"><span class="co">; Add a member with conj</span></a>
<a class="sourceLine" id="cb1-209" title="209">(<span class="kw">conj</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">4</span>) <span class="co">; =&gt; #{1 2 3 4}</span></a>
<a class="sourceLine" id="cb1-210" title="210"></a>
<a class="sourceLine" id="cb1-211" title="211"><span class="co">; Remove one with disj</span></a>
<a class="sourceLine" id="cb1-212" title="212">(<span class="kw">disj</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">1</span>) <span class="co">; =&gt; #{2 3}</span></a>
<a class="sourceLine" id="cb1-213" title="213"></a>
<a class="sourceLine" id="cb1-214" title="214"><span class="co">; Test for existence by using the set as a function:</span></a>
<a class="sourceLine" id="cb1-215" title="215">(#{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">1</span>) <span class="co">; =&gt; 1</span></a>
<a class="sourceLine" id="cb1-216" title="216">(#{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} <span class="dv">4</span>) <span class="co">; =&gt; nil</span></a>
<a class="sourceLine" id="cb1-217" title="217"></a>
<a class="sourceLine" id="cb1-218" title="218"><span class="co">; There are more functions in the clojure.sets namespace.</span></a>
<a class="sourceLine" id="cb1-219" title="219"></a>
<a class="sourceLine" id="cb1-220" title="220"><span class="co">; Useful forms</span></a>
<a class="sourceLine" id="cb1-221" title="221"><span class="co">;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-222" title="222"></a>
<a class="sourceLine" id="cb1-223" title="223"><span class="co">; Logic constructs in clojure are just macros, and look like</span></a>
<a class="sourceLine" id="cb1-224" title="224"><span class="co">; everything else</span></a>
<a class="sourceLine" id="cb1-225" title="225">(<span class="kw">if</span> <span class="va">false</span> <span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span>) <span class="co">; =&gt; &quot;b&quot;</span></a>
<a class="sourceLine" id="cb1-226" title="226">(<span class="kw">if</span> <span class="va">false</span> <span class="st">&quot;a&quot;</span>) <span class="co">; =&gt; nil</span></a>
<a class="sourceLine" id="cb1-227" title="227"></a>
<a class="sourceLine" id="cb1-228" title="228"><span class="co">; Use let to create temporary bindings</span></a>
<a class="sourceLine" id="cb1-229" title="229">(<span class="kw">let</span> [a <span class="dv">1</span> b <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb1-230" title="230">  (<span class="kw">&gt;</span> a b)) <span class="co">; =&gt; false</span></a>
<a class="sourceLine" id="cb1-231" title="231"></a>
<a class="sourceLine" id="cb1-232" title="232"><span class="co">; Group statements together with do</span></a>
<a class="sourceLine" id="cb1-233" title="233">(<span class="kw">do</span></a>
<a class="sourceLine" id="cb1-234" title="234">  (<span class="kw">print</span> <span class="st">&quot;Hello&quot;</span>)</a>
<a class="sourceLine" id="cb1-235" title="235">  <span class="st">&quot;World&quot;</span>) <span class="co">; =&gt; &quot;World&quot; (prints &quot;Hello&quot;)</span></a>
<a class="sourceLine" id="cb1-236" title="236"></a>
<a class="sourceLine" id="cb1-237" title="237"><span class="co">; Functions have an implicit do</span></a>
<a class="sourceLine" id="cb1-238" title="238">(<span class="bu">defn</span><span class="fu"> print-and-say-hello </span>[<span class="kw">name</span>]</a>
<a class="sourceLine" id="cb1-239" title="239">  (<span class="kw">print</span> <span class="st">&quot;Saying hello to &quot;</span> <span class="kw">name</span>)</a>
<a class="sourceLine" id="cb1-240" title="240">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>))</a>
<a class="sourceLine" id="cb1-241" title="241">(print-and-say-hello <span class="st">&quot;Jeff&quot;</span>) <span class="co">;=&gt; &quot;Hello Jeff&quot; (prints &quot;Saying hello to Jeff&quot;)</span></a>
<a class="sourceLine" id="cb1-242" title="242"></a>
<a class="sourceLine" id="cb1-243" title="243"><span class="co">; So does let</span></a>
<a class="sourceLine" id="cb1-244" title="244">(<span class="kw">let</span> [<span class="kw">name</span> <span class="st">&quot;Urkel&quot;</span>]</a>
<a class="sourceLine" id="cb1-245" title="245">  (<span class="kw">print</span> <span class="st">&quot;Saying hello to &quot;</span> <span class="kw">name</span>)</a>
<a class="sourceLine" id="cb1-246" title="246">  (<span class="kw">str</span> <span class="st">&quot;Hello &quot;</span> <span class="kw">name</span>)) <span class="co">; =&gt; &quot;Hello Urkel&quot; (prints &quot;Saying hello to Urkel&quot;)</span></a>
<a class="sourceLine" id="cb1-247" title="247"></a>
<a class="sourceLine" id="cb1-248" title="248"></a>
<a class="sourceLine" id="cb1-249" title="249"><span class="co">; Use the threading macros (-&gt; and -&gt;&gt;) to express transformations of</span></a>
<a class="sourceLine" id="cb1-250" title="250"><span class="co">; data more clearly.</span></a>
<a class="sourceLine" id="cb1-251" title="251"></a>
<a class="sourceLine" id="cb1-252" title="252"><span class="co">; The &quot;Thread-first&quot; macro (-&gt;) inserts into each form the result of</span></a>
<a class="sourceLine" id="cb1-253" title="253"><span class="co">; the previous, as the first argument (second item)</span></a>
<a class="sourceLine" id="cb1-254" title="254">(<span class="kw">-&gt;</span>  </a>
<a class="sourceLine" id="cb1-255" title="255">   {<span class="at">:a</span> <span class="dv">1</span> <span class="at">:b</span> <span class="dv">2</span>} </a>
<a class="sourceLine" id="cb1-256" title="256">   (<span class="kw">assoc</span> <span class="at">:c</span> <span class="dv">3</span>) <span class="co">;=&gt; (assoc {:a 1 :b 2} :c 3)</span></a>
<a class="sourceLine" id="cb1-257" title="257">   (<span class="kw">dissoc</span> <span class="at">:b</span>)) <span class="co">;=&gt; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span></a>
<a class="sourceLine" id="cb1-258" title="258"></a>
<a class="sourceLine" id="cb1-259" title="259"><span class="co">; This expression could be written as:</span></a>
<a class="sourceLine" id="cb1-260" title="260"><span class="co">; (dissoc (assoc {:a 1 :b 2} :c 3) :b)</span></a>
<a class="sourceLine" id="cb1-261" title="261"><span class="co">; and evaluates to {:a 1 :c 3}</span></a>
<a class="sourceLine" id="cb1-262" title="262"></a>
<a class="sourceLine" id="cb1-263" title="263"><span class="co">; The double arrow does the same thing, but inserts the result of</span></a>
<a class="sourceLine" id="cb1-264" title="264"><span class="co">; each line at the *end* of the form. This is useful for collection</span></a>
<a class="sourceLine" id="cb1-265" title="265"><span class="co">; operations in particular:</span></a>
<a class="sourceLine" id="cb1-266" title="266">(<span class="kw">-&gt;&gt;</span></a>
<a class="sourceLine" id="cb1-267" title="267">   (<span class="kw">range</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb1-268" title="268">   (<span class="kw">map</span> <span class="kw">inc</span>)     <span class="co">;=&gt; (map inc (range 10)</span></a>
<a class="sourceLine" id="cb1-269" title="269">   (<span class="kw">filter</span> <span class="kw">odd?</span>) <span class="co">;=&gt; (filter odd? (map inc (range 10))</span></a>
<a class="sourceLine" id="cb1-270" title="270">   (<span class="kw">into</span> []))    <span class="co">;=&gt; (into [] (filter odd? (map inc (range 10)))</span></a>
<a class="sourceLine" id="cb1-271" title="271">                 <span class="co">; Result: [1 3 5 7 9]</span></a>
<a class="sourceLine" id="cb1-272" title="272"></a>
<a class="sourceLine" id="cb1-273" title="273"><span class="co">; When you are in a situation where you want more freedom as where to</span></a>
<a class="sourceLine" id="cb1-274" title="274"><span class="co">; put the result of previous data transformations in an </span></a>
<a class="sourceLine" id="cb1-275" title="275"><span class="co">; expression, you can use the as-&gt; macro. With it, you can assign a</span></a>
<a class="sourceLine" id="cb1-276" title="276"><span class="co">; specific name to transformations&#39; output and use it as a</span></a>
<a class="sourceLine" id="cb1-277" title="277"><span class="co">; placeholder in your chained expressions:</span></a>
<a class="sourceLine" id="cb1-278" title="278"></a>
<a class="sourceLine" id="cb1-279" title="279">(<span class="kw">as-&gt;</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] input</a>
<a class="sourceLine" id="cb1-280" title="280">  (<span class="kw">map</span> <span class="kw">inc</span> input)<span class="co">;=&gt; You can use last transform&#39;s output at the last position</span></a>
<a class="sourceLine" id="cb1-281" title="281">  (<span class="kw">nth</span> input <span class="dv">2</span>) <span class="co">;=&gt;  and at the second position, in the same expression</span></a>
<a class="sourceLine" id="cb1-282" title="282">  (<span class="kw">conj</span> [<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>] input <span class="dv">8</span> <span class="dv">9</span> <span class="dv">10</span>)) <span class="co">;=&gt; or in the middle !</span></a>
<a class="sourceLine" id="cb1-283" title="283">                               <span class="co">; Result: [4 5 6 4 8 9 10]</span></a>
<a class="sourceLine" id="cb1-284" title="284"></a>
<a class="sourceLine" id="cb1-285" title="285"></a>
<a class="sourceLine" id="cb1-286" title="286"><span class="co">; Modules</span></a>
<a class="sourceLine" id="cb1-287" title="287"><span class="co">;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-288" title="288"></a>
<a class="sourceLine" id="cb1-289" title="289"><span class="co">; Use &quot;use&quot; to get all functions from the module</span></a>
<a class="sourceLine" id="cb1-290" title="290">(<span class="kw">use</span> <span class="at">&#39;clojure.set</span>)</a>
<a class="sourceLine" id="cb1-291" title="291"></a>
<a class="sourceLine" id="cb1-292" title="292"><span class="co">; Now we can use set operations</span></a>
<a class="sourceLine" id="cb1-293" title="293">(<span class="kw">intersection</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>}) <span class="co">; =&gt; #{2 3}</span></a>
<a class="sourceLine" id="cb1-294" title="294">(<span class="kw">difference</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>}) <span class="co">; =&gt; #{1}</span></a>
<a class="sourceLine" id="cb1-295" title="295"></a>
<a class="sourceLine" id="cb1-296" title="296"><span class="co">; You can choose a subset of functions to import, too</span></a>
<a class="sourceLine" id="cb1-297" title="297">(<span class="kw">use</span> &#39;[clojure.<span class="kw">set</span> <span class="at">:only</span> [<span class="kw">intersection</span>]])</a>
<a class="sourceLine" id="cb1-298" title="298"></a>
<a class="sourceLine" id="cb1-299" title="299"><span class="co">; Use require to import a module</span></a>
<a class="sourceLine" id="cb1-300" title="300">(<span class="kw">require</span> <span class="at">&#39;clojure.string</span>)</a>
<a class="sourceLine" id="cb1-301" title="301"></a>
<a class="sourceLine" id="cb1-302" title="302"><span class="co">; Use / to call functions from a module</span></a>
<a class="sourceLine" id="cb1-303" title="303"><span class="co">; Here, the module is clojure.string and the function is blank?</span></a>
<a class="sourceLine" id="cb1-304" title="304">(clojure.string/blank? <span class="st">&quot;&quot;</span>) <span class="co">; =&gt; true</span></a>
<a class="sourceLine" id="cb1-305" title="305"></a>
<a class="sourceLine" id="cb1-306" title="306"><span class="co">; You can give a module a shorter name on import</span></a>
<a class="sourceLine" id="cb1-307" title="307">(<span class="kw">require</span> &#39;[clojure.string <span class="at">:as</span> <span class="kw">str</span>])</a>
<a class="sourceLine" id="cb1-308" title="308">(str/replace <span class="st">&quot;This is a test.&quot;</span> <span class="ss">#&quot;[a-o]&quot;</span> str/upper-case) <span class="co">; =&gt; &quot;THIs Is A tEst.&quot;</span></a>
<a class="sourceLine" id="cb1-309" title="309"><span class="co">; (#&quot;&quot; denotes a regular expression literal)</span></a>
<a class="sourceLine" id="cb1-310" title="310"></a>
<a class="sourceLine" id="cb1-311" title="311"><span class="co">; You can use require (and use, but don&#39;t) from a namespace using :require.</span></a>
<a class="sourceLine" id="cb1-312" title="312"><span class="co">; You don&#39;t need to quote your modules if you do it this way.</span></a>
<a class="sourceLine" id="cb1-313" title="313">(<span class="kw">ns</span> <span class="kw">test</span></a>
<a class="sourceLine" id="cb1-314" title="314">  (<span class="at">:require</span></a>
<a class="sourceLine" id="cb1-315" title="315">    [clojure.string <span class="at">:as</span> <span class="kw">str</span>]</a>
<a class="sourceLine" id="cb1-316" title="316">    [clojure.<span class="kw">set</span> <span class="at">:as</span> <span class="kw">set</span>]))</a>
<a class="sourceLine" id="cb1-317" title="317"></a>
<a class="sourceLine" id="cb1-318" title="318"><span class="co">; Java</span></a>
<a class="sourceLine" id="cb1-319" title="319"><span class="co">;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-320" title="320"></a>
<a class="sourceLine" id="cb1-321" title="321"><span class="co">; Java has a huge and useful standard library, so</span></a>
<a class="sourceLine" id="cb1-322" title="322"><span class="co">; you&#39;ll want to learn how to get at it.</span></a>
<a class="sourceLine" id="cb1-323" title="323"></a>
<a class="sourceLine" id="cb1-324" title="324"><span class="co">; Use import to load a java module</span></a>
<a class="sourceLine" id="cb1-325" title="325">(<span class="kw">import</span> java.util.Date)</a>
<a class="sourceLine" id="cb1-326" title="326"></a>
<a class="sourceLine" id="cb1-327" title="327"><span class="co">; You can import from an ns too.</span></a>
<a class="sourceLine" id="cb1-328" title="328">(<span class="kw">ns</span> <span class="kw">test</span></a>
<a class="sourceLine" id="cb1-329" title="329">  (<span class="at">:import</span> java.util.Date</a>
<a class="sourceLine" id="cb1-330" title="330">           java.util.Calendar))</a>
<a class="sourceLine" id="cb1-331" title="331"></a>
<a class="sourceLine" id="cb1-332" title="332"><span class="co">; Use the class name with a &quot;.&quot; at the end to make a new instance</span></a>
<a class="sourceLine" id="cb1-333" title="333">(Date.) <span class="co">; &lt;a date object&gt;</span></a>
<a class="sourceLine" id="cb1-334" title="334"></a>
<a class="sourceLine" id="cb1-335" title="335"><span class="co">; Use . to call methods. Or, use the &quot;.method&quot; shortcut</span></a>
<a class="sourceLine" id="cb1-336" title="336">(. (Date.) getTime) <span class="co">; &lt;a timestamp&gt;</span></a>
<a class="sourceLine" id="cb1-337" title="337">(.getTime (Date.)) <span class="co">; exactly the same thing.</span></a>
<a class="sourceLine" id="cb1-338" title="338"></a>
<a class="sourceLine" id="cb1-339" title="339"><span class="co">; Use / to call static methods</span></a>
<a class="sourceLine" id="cb1-340" title="340">(System/currentTimeMillis) <span class="co">; &lt;a timestamp&gt; (system is always present)</span></a>
<a class="sourceLine" id="cb1-341" title="341"></a>
<a class="sourceLine" id="cb1-342" title="342"><span class="co">; Use doto to make dealing with (mutable) classes more tolerable</span></a>
<a class="sourceLine" id="cb1-343" title="343">(<span class="kw">import</span> java.util.Calendar)</a>
<a class="sourceLine" id="cb1-344" title="344">(<span class="kw">doto</span> (Calendar/getInstance)</a>
<a class="sourceLine" id="cb1-345" title="345">  (.<span class="kw">set</span> <span class="dv">2000</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-346" title="346">  .getTime) <span class="co">; =&gt; A Date. set to 2000-01-01 00:00:00</span></a>
<a class="sourceLine" id="cb1-347" title="347"></a>
<a class="sourceLine" id="cb1-348" title="348"><span class="co">; STM</span></a>
<a class="sourceLine" id="cb1-349" title="349"><span class="co">;;;;;;;;;;;;;;;;;</span></a>
<a class="sourceLine" id="cb1-350" title="350"></a>
<a class="sourceLine" id="cb1-351" title="351"><span class="co">; Software Transactional Memory is the mechanism clojure uses to handle</span></a>
<a class="sourceLine" id="cb1-352" title="352"><span class="co">; persistent state. There are a few constructs in clojure that use this.</span></a>
<a class="sourceLine" id="cb1-353" title="353"></a>
<a class="sourceLine" id="cb1-354" title="354"><span class="co">; An atom is the simplest. Pass it an initial value</span></a>
<a class="sourceLine" id="cb1-355" title="355">(<span class="bu">def</span><span class="fu"> my-atom </span>(<span class="kw">atom</span> {}))</a>
<a class="sourceLine" id="cb1-356" title="356"></a>
<a class="sourceLine" id="cb1-357" title="357"><span class="co">; Update an atom with swap!.</span></a>
<a class="sourceLine" id="cb1-358" title="358"><span class="co">; swap! takes a function and calls it with the current value of the atom</span></a>
<a class="sourceLine" id="cb1-359" title="359"><span class="co">; as the first argument, and any trailing arguments as the second</span></a>
<a class="sourceLine" id="cb1-360" title="360">(<span class="kw">swap!</span> my-atom <span class="kw">assoc</span> <span class="at">:a</span> <span class="dv">1</span>) <span class="co">; Sets my-atom to the result of (assoc {} :a 1)</span></a>
<a class="sourceLine" id="cb1-361" title="361">(<span class="kw">swap!</span> my-atom <span class="kw">assoc</span> <span class="at">:b</span> <span class="dv">2</span>) <span class="co">; Sets my-atom to the result of (assoc {:a 1} :b 2)</span></a>
<a class="sourceLine" id="cb1-362" title="362"></a>
<a class="sourceLine" id="cb1-363" title="363"><span class="co">; Use &#39;@&#39; to dereference the atom and get the value</span></a>
<a class="sourceLine" id="cb1-364" title="364">my-atom  <span class="co">;=&gt; Atom&lt;#...&gt; (Returns the Atom object)</span></a>
<a class="sourceLine" id="cb1-365" title="365"><span class="at">@my-atom</span> <span class="co">; =&gt; {:a 1 :b 2}</span></a>
<a class="sourceLine" id="cb1-366" title="366"></a>
<a class="sourceLine" id="cb1-367" title="367"><span class="co">; Here&#39;s a simple counter using an atom</span></a>
<a class="sourceLine" id="cb1-368" title="368">(<span class="bu">def</span><span class="fu"> counter </span>(<span class="kw">atom</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb1-369" title="369">(<span class="bu">defn</span><span class="fu"> inc-counter </span>[]</a>
<a class="sourceLine" id="cb1-370" title="370">  (<span class="kw">swap!</span> counter <span class="kw">inc</span>))</a>
<a class="sourceLine" id="cb1-371" title="371"></a>
<a class="sourceLine" id="cb1-372" title="372">(inc-counter)</a>
<a class="sourceLine" id="cb1-373" title="373">(inc-counter)</a>
<a class="sourceLine" id="cb1-374" title="374">(inc-counter)</a>
<a class="sourceLine" id="cb1-375" title="375">(inc-counter)</a>
<a class="sourceLine" id="cb1-376" title="376">(inc-counter)</a>
<a class="sourceLine" id="cb1-377" title="377"></a>
<a class="sourceLine" id="cb1-378" title="378"><span class="at">@counter</span> <span class="co">; =&gt; 5</span></a>
<a class="sourceLine" id="cb1-379" title="379"></a>
<a class="sourceLine" id="cb1-380" title="380"><span class="co">; Other STM constructs are refs and agents.</span></a>
<a class="sourceLine" id="cb1-381" title="381"><span class="co">; Refs: http://clojure.org/refs</span></a>
<a class="sourceLine" id="cb1-382" title="382"><span class="co">; Agents: http://clojure.org/agents</span></a></code></pre>
    </div>
    <h3 id="further-reading">Further Reading</h3>
    <p>
      This is far from exhaustive, but hopefully its enough to get you on your
      feet.
    </p>
    <p>
      Clojure.org has lots of articles:
      <a href="http://clojure.org/">http://clojure.org/</a>
    </p>
    <p>
      Clojuredocs.org has documentation with examples for most core functions:
      <a href="http://clojuredocs.org/quickref/Clojure%20Core"
        >http://clojuredocs.org/quickref/Clojure%20Core</a
      >
    </p>
    <p>
      4Clojure is a great way to build your clojure/FP skills:
      <a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
    </p>
    <p>
      Clojure-doc.org (yes, really) has a number of getting started articles:
      <a href="http://clojure-doc.org/">http://clojure-doc.org/</a>
    </p>
    <p>
      Clojure for the Brave and True has a great introduction to Clojure and a
      free online version:
      <a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/"
        >https://www.braveclojure.com/clojure-for-the-brave-and-true/</a
      >
    </p>
  </body>
</html>
