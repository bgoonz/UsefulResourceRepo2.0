<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>lambda-calculus.html</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="lambda-calculus">Lambda Calculus</h1>
    <p>
      Lambda calculus (λ-calculus), originally created by
      <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>,
      is the world’s smallest programming language. Despite not having numbers,
      strings, booleans, or any non-function datatype, lambda calculus can be
      used to represent any Turing Machine!
    </p>
    <p>
      Lambda calculus is composed of 3 elements: <strong>variables</strong>,
      <strong>functions</strong>, and <strong>applications</strong>.
    </p>
    <table>
      <colgroup>
        <col style="width: 12%" />
        <col style="width: 33%" />
        <col style="width: 10%" />
        <col style="width: 43%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th>Name</th>
          <th>Syntax</th>
          <th>Example</th>
          <th>Explanation</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td>Variable</td>
          <td><code>&lt;name&gt;</code></td>
          <td><code>x</code></td>
          <td>a variable named “x”</td>
        </tr>
        <tr class="even">
          <td>Function</td>
          <td><code>λ&lt;parameters&gt;.&lt;body&gt;</code></td>
          <td><code>λx.x</code></td>
          <td>a function with parameter “x” and body “x”</td>
        </tr>
        <tr class="odd">
          <td>Application</td>
          <td><code>&lt;function&gt;&lt;variable or function&gt;</code></td>
          <td><code>(λx.x)a</code></td>
          <td>calling the function “λx.x” with argument “a”</td>
        </tr>
      </tbody>
    </table>
    <p>
      The most basic function is the identity function: <code>λx.x</code> which
      is equivalent to <code>f(x) = x</code>. The first “x” is the function’s
      argument, and the second is the body of the function.
    </p>
    <h2 id="free-vs.-bound-variables">Free vs. Bound Variables:</h2>
    <ul>
      <li>
        In the function <code>λx.x</code>, “x” is called a bound variable
        because it is both in the body of the function and a parameter.
      </li>
      <li>
        In <code>λx.y</code>, “y” is called a free variable because it is never
        declared before hand.
      </li>
    </ul>
    <h2 id="evaluation">Evaluation:</h2>
    <p>
      Evaluation is done via
      <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction"
        >β-Reduction</a
      >, which is essentially lexically-scoped substitution.
    </p>
    <p>
      When evaluating the expression <code>(λx.x)a</code>, we replace all
      occurences of “x” in the function’s body with “a”.
    </p>
    <ul>
      <li><code>(λx.x)a</code> evaluates to: <code>a</code></li>
      <li><code>(λx.y)a</code> evaluates to: <code>y</code></li>
    </ul>
    <p>You can even create higher-order functions:</p>
    <ul>
      <li><code>(λx.(λy.x))a</code> evaluates to: <code>λy.a</code></li>
    </ul>
    <p>
      Although lambda calculus traditionally supports only single parameter
      functions, we can create multi-parameter functions using a technique
      called <a href="https://en.wikipedia.org/wiki/Currying">currying</a>.
    </p>
    <ul>
      <li>
        <code>(λx.λy.λz.xyz)</code> is equivalent to
        <code>f(x, y, z) = ((x y) z)</code>
      </li>
    </ul>
    <p>
      Sometimes <code>λxy.&lt;body&gt;</code> is used interchangeably with:
      <code>λx.λy.&lt;body&gt;</code>
    </p>
    <hr />
    <p>
      It’s important to recognize that traditional
      <strong
        >lambda calculus doesn’t have numbers, characters, or any non-function
        datatype!</strong
      >
    </p>
    <h2 id="boolean-logic">Boolean Logic:</h2>
    <p>
      There is no “True” or “False” in lambda calculus. There isn’t even a 1 or
      0.
    </p>
    <p>Instead:</p>
    <p><code>T</code> is represented by: <code>λx.λy.x</code></p>
    <p><code>F</code> is represented by: <code>λx.λy.y</code></p>
    <p>
      First, we can define an “if” function <code>λbtf</code> that returns
      <code>t</code> if <code>b</code> is True and <code>f</code> if
      <code>b</code> is False
    </p>
    <p><code>IF</code> is equivalent to: <code>λb.λt.λf.b t f</code></p>
    <p>
      Using <code>IF</code>, we can define the basic boolean logic operators:
    </p>
    <p><code>a AND b</code> is equivalent to: <code>λab.IF a b F</code></p>
    <p><code>a OR b</code> is equivalent to: <code>λab.IF a T b</code></p>
    <p><code>NOT a</code> is equivalent to: <code>λa.IF a F T</code></p>
    <p>
      <em
        >Note: <code>IF a b c</code> is essentially saying:
        <code>IF((a b) c)</code></em
      >
    </p>
    <h2 id="numbers">Numbers:</h2>
    <p>
      Although there are no numbers in lambda calculus, we can encode numbers
      using
      <a href="https://en.wikipedia.org/wiki/Church_encoding">Church numerals</a
      >.
    </p>
    <p>
      For any number n: <code>n = λf.f<sup>n</sup></code> so:
    </p>
    <p><code>0 = λf.λx.x</code></p>
    <p><code>1 = λf.λx.f x</code></p>
    <p><code>2 = λf.λx.f(f x)</code></p>
    <p><code>3 = λf.λx.f(f(f x))</code></p>
    <p>
      To increment a Church numeral, we use the successor function
      <code>S(n) = n + 1</code> which is:
    </p>
    <p><code>S = λn.λf.λx.f((n f) x)</code></p>
    <p>Using successor, we can define add:</p>
    <p><code>ADD = λab.(a S)b</code></p>
    <p>
      <strong>Challenge:</strong> try defining your own multiplication function!
    </p>
    <h2 id="get-even-smaller-ski-sk-and-iota">
      Get even smaller: SKI, SK and Iota
    </h2>
    <h3 id="ski-combinator-calculus">SKI Combinator Calculus</h3>
    <p>Let S, K, I be the following functions:</p>
    <p><code>I x = x</code></p>
    <p><code>K x y = x</code></p>
    <p><code>S x y z = x z (y z)</code></p>
    <p>
      We can convert an expression in the lambda calculus to an expression in
      the SKI combinator calculus:
    </p>
    <ol type="1">
      <li><code>λx.x = I</code></li>
      <li><code>λx.c = Kc</code></li>
      <li><code>λx.(y z) = S (λx.y) (λx.z)</code></li>
    </ol>
    <p>Take the church number 2 for example:</p>
    <p><code>2 = λf.λx.f(f x)</code></p>
    <p>For the inner part <code>λx.f(f x)</code>:</p>
    <pre><code>  λx.f(f x)
= S (λx.f) (λx.(f x))          (case 3)
= S (K f)  (S (λx.f) (λx.x))   (case 2, 3)
= S (K f)  (S (K f) I)         (case 2, 1)</code></pre>
    <p>So:</p>
    <pre><code>  2
= λf.λx.f(f x)
= λf.(S (K f) (S (K f) I))
= λf.((S (K f)) (S (K f) I))
= S (λf.(S (K f))) (λf.(S (K f) I)) (case 3)</code></pre>
    <p>For the first argument <code>λf.(S (K f))</code>:</p>
    <pre><code>  λf.(S (K f))
= S (λf.S) (λf.(K f))       (case 3)
= S (K S) (S (λf.K) (λf.f)) (case 2, 3)
= S (K S) (S (K K) I)       (case 2, 3)</code></pre>
    <p>For the second argument <code>λf.(S (K f) I)</code>:</p>
    <pre><code>  λf.(S (K f) I)
= λf.((S (K f)) I)
= S (λf.(S (K f))) (λf.I)             (case 3)
= S (S (λf.S) (λf.(K f))) (K I)       (case 2, 3)
= S (S (K S) (S (λf.K) (λf.f))) (K I) (case 1, 3)
= S (S (K S) (S (K K) I)) (K I)       (case 1, 2)</code></pre>
    <p>Merging them up:</p>
    <pre><code>  2
= S (λf.(S (K f))) (λf.(S (K f) I))
= S (S (K S) (S (K K) I)) (S (S (K S) (S (K K) I)) (K I))</code></pre>
    <p>
      Expanding this, we would end up with the same expression for the church
      number 2 again.
    </p>
    <h3 id="sk-combinator-calculus">SK Combinator Calculus</h3>
    <p>
      The SKI combinator calculus can still be reduced further. We can remove
      the I combinator by noting that <code>I = SKK</code>. We can substitute
      all <code>I</code>’s with <code>SKK</code>.
    </p>
    <h3 id="iota-combinator">Iota Combinator</h3>
    <p>The SK combinator calculus is still not minimal. Defining:</p>
    <pre><code>ι = λf.((f S) K)</code></pre>
    <p>We have:</p>
    <pre><code>I = ιι
K = ι(ιI) = ι(ι(ιι))
S = ι(K) = ι(ι(ι(ιι)))</code></pre>
    <h2 id="for-more-advanced-reading">For more advanced reading:</h2>
    <ol type="1">
      <li>
        <a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf"
          >A Tutorial Introduction to the Lambda Calculus</a
        >
      </li>
      <li>
        <a
          href="http://www.cs.cornell.edu/courses/cs3110/2008fa/recitations/rec26.html"
          >Cornell CS 312 Recitation 26: The Lambda Calculus</a
        >
      </li>
      <li>
        <a href="https://en.wikipedia.org/wiki/Lambda_calculus"
          >Wikipedia - Lambda Calculus</a
        >
      </li>
      <li>
        <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus"
          >Wikipedia - SKI combinator calculus</a
        >
      </li>
      <li>
        <a href="https://en.wikipedia.org/wiki/Iota_and_Jot"
          >Wikipedia - Iota and Jot</a
        >
      </li>
    </ol>
  </body>
</html>
