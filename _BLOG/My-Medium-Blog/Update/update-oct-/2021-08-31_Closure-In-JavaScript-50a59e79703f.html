<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Closure In JavaScript</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Closure In JavaScript</h1>
</header>
<section data-field="subtitle" class="p-summary">
And why you’ve been stressed about it for no reason.
</section>
<section data-field="body" class="e-content">
<section name="45b9" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="12d0" id="12d0" class="graf graf--h3 graf--leading graf--title">Closure In JavaScript</h3><p name="0eff" id="0eff" class="graf graf--p graf-after--h3">And why you’ve been stressed about it for no reason.</p><h3 name="4490" id="4490" class="graf graf--h3 graf-after--p">What is a closure? Can you give a useful example of one?</h3><h4 name="f3b3" id="f3b3" class="graf graf--h4 graf-after--h3">Answer</h4><p name="c850" id="c850" class="graf graf--p graf-after--h4">A closure is a function defined inside another function and has access to its lexical scope even when it is executing outside its lexical scope. The closure has access to variables in three scopes:</p><ul class="postList"><li name="5a64" id="5a64" class="graf graf--li graf-after--p">Variables declared in its own scope</li><li name="f46e" id="f46e" class="graf graf--li graf-after--li">Variables declared in the scope of the parent function</li><li name="97c3" id="97c3" class="graf graf--li graf-after--li">Variables declared in the global scope</li></ul><p name="4155" id="4155" class="graf graf--p graf-after--li">In JavaScript, all functions are closures because they have access to the outer scope, but most functions don’t utilise the usefulness of closures: the persistence of state. Closures are also sometimes called stateful functions because of this.</p><p name="c37f" id="c37f" class="graf graf--p graf-after--p">In addition, closures are the only way to store private data that can’t be accessed from the outside in JavaScript. They are the key to the UMD (Universal Module Definition) pattern, which is frequently used in libraries that only expose a public API but keep the implementation details private, preventing name collisions with other libraries or the user’s own code.</p><h4 name="1b37" id="1b37" class="graf graf--h4 graf-after--p">Good to hear</h4><ul class="postList"><li name="d813" id="d813" class="graf graf--li graf-after--h4">Closures are useful because they let you associate data with a function that operates on that data.</li><li name="ce0c" id="ce0c" class="graf graf--li graf-after--li">A closure can substitute an object with only a single method.</li><li name="19d5" id="19d5" class="graf graf--li graf-after--li">Closures can be used to emulate private properties and methods.</li></ul><p name="aec2" id="aec2" class="graf graf--p graf-after--li">Additional links</p><ul class="postList"><li name="5977" id="5977" class="graf graf--li graf-after--p"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">MDN docs for closures</a></li><li name="f18b" id="f18b" class="graf graf--li graf-after--li"><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" data-href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" class="markup--anchor markup--li-anchor" target="_blank">What is a closure</a></li><li name="62c7" id="62c7" class="graf graf--li graf-after--li"><a href="https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8" data-href="https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8" class="markup--anchor markup--li-anchor" target="_blank">I never understood JavaScript closures</a></li></ul><p name="0b8e" id="0b8e" class="graf graf--p graf-after--li">A closure is the combination of a function bundled together (enclosed) with <strong class="markup--strong markup--p-strong">references to its surrounding state (the lexical environment)</strong>. In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.</p><p name="3bac" id="3bac" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A closure is a function</strong> that retains access to variables of the context it was created in even after said function call has returned.</p><pre name="f420" id="f420" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function init() {<br>  var name = &quot;Mozilla&quot; // name is a local variable created by init<br>  function displayName() {<br>    // displayName() is the inner function, a closure<br>    alert(name) // use variable declared in the parent function<br>  }<br>  displayName()<br>}<br>init()</code></pre><p name="5a13" id="5a13" class="graf graf--p graf-after--pre">init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer functions, displayName() can access the variable name declared in the parent function, init().</p><p name="b3e3" id="b3e3" class="graf graf--p graf-after--p">This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.</p><pre name="6334" id="6334" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">var awFunc = function(first) {<br>  var someFunc = function(second) {<br>    return first + second<br>  }<br>  return someFunc // note that I did not invoke this function i.e. I did not use someFunc(), but I did returned the function itself<br>}</code></pre><pre name="84c9" id="84c9" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">var someMoreFunc = awFunc(&quot;awe&quot;) // At this point awFunc has finished running</code></pre><pre name="e527" id="e527" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(someMoreFunc()) // This will return &#39;aweundefined&#39;</code></pre><pre name="8371" id="8371" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(someMoreFunc(&quot;some&quot;)) // returns awesome</code></pre><h3 name="58ee" id="58ee" class="graf graf--h3 graf-after--pre">Using Closures (Examples)</h3><p name="705a" id="705a" class="graf graf--p graf-after--h3">Among other things, closures are commonly used to give objects data privacy. Data privacy is an essential property that helps us program to an interface, not an implementation. This is an important concept that helps us build more robust software because implementation details are more likely to change in breaking ways than interface contracts.</p><p name="ab2f" id="ab2f" class="graf graf--p graf-after--p">To use a closure, simply define a function inside another function and expose it. To expose a function, return it or pass it to another function.</p><h4 name="c447" id="c447" class="graf graf--h4 graf-after--p">In JavaScript, closures are the primary mechanism used to enable data privacy. When you use closures for data privacy, the enclosed variables are only in scope within the containing (outer) function. You can’t get at the data from an outside scope except through the object’s privileged methods. In JavaScript, any exposed method defined within the closure scope is privileged. For example:</h4><pre name="0bcf" id="0bcf" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">const getSecret = secret =&gt; {<br>  return {<br>    getPrivileged: () =&gt; secret,<br>  }<br>}</code></pre><p name="449e" id="449e" class="graf graf--p graf-after--pre">In the example above, the <code class="markup--code markup--p-code">getPrivileged()</code> method is defined inside the scope of <code class="markup--code markup--p-code">getSecret()</code>, which gives it access to any variables from <code class="markup--code markup--p-code">getSecret()</code>, and makes it a privileged method. In this case, the parameter, <code class="markup--code markup--p-code">secret</code>.</p><h3 name="291f" id="291f" class="graf graf--h3 graf-after--p">Another example of closure</h3><pre name="7947" id="7947" class="graf graf--pre graf-after--h3"><code class="markup--code markup--pre-code">const outerFunc = () =&gt; {<br>  let name = &quot;Rohan&quot;</code></pre><pre name="04f2" id="04f2" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  const closureFunc = () =&gt; {<br>    console.log(name)<br>  }<br>  return closureFunc()<br>}</code></pre><pre name="4089" id="4089" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">var name = &quot;Paul&quot;</code></pre><pre name="ebdb" id="ebdb" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">outerFunc() // =&gt; Will Print &#39;Rohan&#39;</code></pre><h3 name="5727" id="5727" class="graf graf--h3 graf-after--pre">So what&#39;s going on above</h3><p name="1b18" id="1b18" class="graf graf--p graf-after--h3">First, when a function runs, a new function Lexical Environment is created automatically. That’s a general rule for all functions. That Lexical Environment is used to store local variables and parameters of the call.</p><p name="4534" id="4534" class="graf graf--p graf-after--p">During the function call we have two Lexical Environments: the inner one (for the function call) and the outer one (global):</p><p name="585c" id="585c" class="graf graf--p graf-after--p">The inner Lexical Environment corresponds to the current execution of that function.</p><p name="76a6" id="76a6" class="graf graf--p graf-after--p">When code wants to access a variable — it is first searched for in the inner Lexical Environment, then in the outer one, then the more outer one and so on until the end of the chain.</p><p name="bcbe" id="bcbe" class="graf graf--p graf-after--p">If a variable is not found anywhere, that’s an error in strict mode. Without use strict, an assignment to an undefined variable creates a new global variable, for backwards compatibility.</p><h3 name="619e" id="619e" class="graf graf--h3 graf-after--p">Some overall key points</h3><h3 name="6196" id="6196" class="graf graf--h3 graf-after--h3">Closure</h3><ul class="postList"><li name="41d3" id="41d3" class="graf graf--li graf-after--h3">A closure is a function that remembers its outer variables and can access them.</li><li name="5536" id="5536" class="graf graf--li graf-after--li">Combination of a function and the lexical environment within which that function was declared</li><li name="2ba2" id="2ba2" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">closure</code> is the function object itself.</li><li name="4f31" id="4f31" class="graf graf--li graf-after--li">Accessing variables outside of the immediate lexical scope creates a closure.</li><li name="7958" id="7958" class="graf graf--li graf-after--li">Happens when we have a nested functions.</li><li name="6fe2" id="6fe2" class="graf graf--li graf-after--li">JavaScript engines also may optimize, discard variables that are unused to save memory.</li><li name="071c" id="071c" class="graf graf--li graf-after--li">A <code class="markup--code markup--li-code">Lexical Environment</code> object lives in the <code class="markup--code markup--li-code">heap</code> as long as there is a function which may use it. And when there are none, it is cleared.</li><li name="e081" id="e081" class="graf graf--li graf-after--li">All functions in JavaScript are closures.</li><li name="a0ab" id="a0ab" class="graf graf--li graf-after--li">The internal property <code class="markup--code markup--li-code">[[Environment]]</code> of a function, refers to the outer lexical environment</li></ul><h3 name="9bd6" id="9bd6" class="graf graf--h3 graf-after--li">Question: Look at the code below, you have a for loop if you have setTimeout inside it. If log the loop counter inside setTimeout, what will be logged?</h3><pre name="2e74" id="2e74" class="graf graf--pre graf-after--h3"><code class="markup--code markup--pre-code">for (let i = 0; i &lt; 10; i++) {<br>  setTimeout(function () {<br>    console.log(i)<br>  }, 10)<br>}</code></pre><p name="eb5e" id="eb5e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Answer</strong>: The above will not output the numbers 0 through 9, but will simply print the number 10 ten times.</p><p name="200e" id="200e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Explanation</strong>: The console log is inside the anonymous function of setTimeout and setTimeout is executed when current call stack is over. So, the loop finishes and before setTimeout get the chance to execute. However, anonymous functions keep a reference to i by creating a closure. Since, the loop is already finished, the value i has been set to 10. When setTimeout use the value of i by reference, it gets the value of i as 10. Hence, you see 10 ten times.</p><p name="23d9" id="23d9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Solution</strong>: You can fix it by avoiding closure. Just create a IIFE (Immediately Invoked Function Expression), it will create its own scope and you can pass i to the function. In that case i will be a local variable (will not refer to i in the closure) and value of the i in every loop will be preserved.</p><pre name="71d3" id="71d3" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">for (let i = 0; i &lt; 10; i++) {<br>  setTimeout(<br>    (function (i) {<br>      console.log(i)<br>    })(i),<br>    10<br>  )<br>}</code></pre><p name="64e4" id="64e4" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Alternative Solution</strong>: Look at the code below and use your brain (if any).</p><pre name="bbd7" id="bbd7" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">for (let i = 0; i &lt; 10; i++) {<br>  setTimeout(console.log.bind(console, i), 10)<br>}</code></pre><p name="02ed" id="02ed" class="graf graf--p graf-after--pre">Lets look at this function</p><pre name="2cfe" id="2cfe" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function outer() {<br>  var b = 10<br>  function inner() {<br>    var a = 20<br>    console.log(a + b)<br>  }<br>  return inner<br>}/*<br>Here we have two functions:</code></pre><pre name="f517" id="f517" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">an outer function outer which has a variable b, and returns the inner function<br>an inner function inner which has its variable called a, and accesses an outer variable b, within its function body<br>The scope of variable b is limited to the outer function, and the scope of variable a is limited to the inner function.</code></pre><pre name="e344" id="e344" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Let us now invoke the outer() function, and store the result of the outer() function in a variable X<br> */</code></pre><pre name="61c3" id="61c3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">var X = outer()</code></pre><p name="5d5b" id="5d5b" class="graf graf--p graf-after--pre">Since the variables X is functions, we can <strong class="markup--strong markup--p-strong">execute</strong> them. In JavaScript, a function can be executed by adding <strong class="markup--strong markup--p-strong">()</strong> after the function name, such as <strong class="markup--strong markup--p-strong">X()</strong>.</p><p name="b7ce" id="b7ce" class="graf graf--p graf-after--p">When we execute X(), we are essentially executing the <code class="markup--code markup--p-code">inner</code> function.</p><p name="aa5b" id="aa5b" class="graf graf--p graf-after--p">If I run &lt; console.log(X()) &gt; the output will be below</p><p name="8baf" id="8baf" class="graf graf--p graf-after--p">30<br>undefined</p><p name="480e" id="480e" class="graf graf--p graf-after--p">So the closure function <strong class="markup--strong markup--p-strong">inner</strong>() is getting the value of <strong class="markup--strong markup--p-strong">b = 10</strong> from its enclosing <strong class="markup--strong markup--p-strong">outer()</strong> function ever after <strong class="markup--strong markup--p-strong">outer()</strong> function has returned.</p><h4 name="5f40" id="5f40" class="graf graf--h4 graf-after--p">Let’s see step-by-step what happens when the outer() function is first invoked:</h4><ul class="postList"><li name="d0f8" id="d0f8" class="graf graf--li graf-after--h4">1. Variable b is created, its scope is limited to the outer() function, and its value is set to 10.</li><li name="0887" id="0887" class="graf graf--li graf-after--li">2. The next line is a function declaration, so nothing to execute.</li><li name="9d15" id="9d15" class="graf graf--li graf-after--li">3. On the last line, return inner looks for a variable called inner, finds that this variable inner is actually a function, and so returns the entire body of the function inner.</li><li name="1344" id="1344" class="graf graf--li graf-after--li">4. Note that the return statement does not execute the inner function — a function is executed only when followed by () — , but rather the return statement returns the entire body of the function.</li><li name="4e55" id="4e55" class="graf graf--li graf-after--li">5. The contents returned by the return statement are stored in X.</li></ul><p name="3f7b" id="3f7b" class="graf graf--p graf-after--li">Thus, X will store the following:</p><pre name="11e5" id="11e5" class="graf graf--pre graf-after--p">function inner() {<br>var a=20;<br>console.log(a+b);<br>}</pre><p name="3d18" id="3d18" class="graf graf--p graf-after--pre">This can be easily verified by adding the following to the JavaScript code:</p><pre name="349d" id="349d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">console.log(typeof X) //X is of type function</code></pre><ul class="postList"><li name="fc52" id="fc52" class="graf graf--li graf-after--pre">6. Function outer() finishes execution, and all variables within the scope of outer() now no longer exist.</li><li name="f9cd" id="f9cd" class="graf graf--li graf-after--li">7. This last part is important to understand. Once a function completes its execution, any variables that were defined inside the function scope cease to exist.</li></ul><blockquote name="d651" id="d651" class="graf graf--pullquote graf-after--li">The lifespan of a variable defined inside of a function is the lifespan of the function execution.</blockquote><p name="c020" id="c020" class="graf graf--p graf-after--pullquote">What this means is that in <strong class="markup--strong markup--p-strong">console.log(a+b)</strong>, the variable <strong class="markup--strong markup--p-strong">b</strong> exists only during the execution of the the <strong class="markup--strong markup--p-strong">outer()</strong> function. Once the outer function has finished execution, the variable b no longer exists.</p><p name="da04" id="da04" class="graf graf--p graf-after--p">This is the most important point to realize. The variables inside the functions only come into existence when the function is running, and cease to exist once the functions completes execution.</p><p name="64c0" id="64c0" class="graf graf--p graf-after--p">Now see the main point of this exercise — that how a closure function retains its enclosing function’s variable values, even after the enclosing function has returned.</p><ul class="postList"><li name="2c6b" id="2c6b" class="graf graf--li graf-after--p">A. When we execute X(), we are essentially executing the <code class="markup--code markup--li-code">inner</code> function.</li><li name="2f2e" id="2f2e" class="graf graf--li graf-after--li">B. If I run &lt; console.log(X()) &gt; the output will be below</li></ul><pre name="7c65" id="7c65" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">30<br>undefined</code></pre><ul class="postList"><li name="1b5c" id="1b5c" class="graf graf--li graf-after--pre">C. So the closure function <strong class="markup--strong markup--li-strong">inner</strong>() is getting the value of <strong class="markup--strong markup--li-strong">b = 10</strong> from its enclosing <strong class="markup--strong markup--li-strong">outer()</strong> function ever after <strong class="markup--strong markup--li-strong">outer()</strong> function has returned.</li></ul><h4 name="ec76" id="ec76" class="graf graf--h4 graf-after--li">Let us examine step-by-step what happens when X() is executed the first time:</h4><ul class="postList"><li name="881a" id="881a" class="graf graf--li graf-after--h4">1. Variable a is created, and its value is set to 20.</li><li name="8b24" id="8b24" class="graf graf--li graf-after--li">2. JavaScript now tries to execute a + b. Here is where things get interesting. JavaScript knows that a exists since it just created it. However, variable b no longer exists. Since b is part of the outer function, b would only exist while the outer() function is in execution. Since the outer() function finished execution long before we invoked X(), any variables within the scope of the outer function cease to exist, and hence variable b no longer exists.</li></ul><h4 name="3610" id="3610" class="graf graf--h4 graf-after--li">Closures</h4><ul class="postList"><li name="bc72" id="bc72" class="graf graf--li graf-after--h4">A. The inner function can access the variables of the enclosing function due to closures in JavaScript. In other words, the inner function preserves the scope chain of the enclosing function at the time the enclosing function was executed, and thus can access the enclosing function’s variables.</li><li name="d87c" id="d87c" class="graf graf--li graf-after--li">B. In our example, the inner function had preserved the value of b=10 when the outer() function was executed, and continued to preserve (closure) it.</li><li name="1f8f" id="1f8f" class="graf graf--li graf-after--li">C. It now refers to its scope chain and notices that it does have the value of variable b within its scope chain, since it had enclosed the value of b within a closure at the point when the outer function had executed.</li><li name="cbcc" id="cbcc" class="graf graf--li graf-after--li">D. Thus, JavaScript knows a=20 and b=10, and can calculate a+b.</li></ul><p name="223d" id="223d" class="graf graf--p graf-after--li">So the inner function has three scope chains:</p><p name="61e1" id="61e1" class="graf graf--p graf-after--p">access to its own scope — variable a<br>access to the outer function’s variables — variable b, which it enclosed<br>access to any global variables that may be defined</p><h3 name="d9a4" id="d9a4" class="graf graf--h3 graf-after--p">Examples:</h3><pre name="6224" id="6224" class="graf graf--pre graf-after--h3"><code class="markup--code markup--pre-code">/*A closure is an inner function that has access to the outer (enclosing) function&#39;s variables<br>The closure has three scopes, all part of the same chain: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function&#39;s variables, and it has access to the global variables<br>The inner function has access not only to the outer function&#39;s variables, but also to the outer function&#39;s parameters<br>*/<br>sayHelloTo = name =&gt; {<br>  let text = &#39;Hello &#39; + name; // this is the local variable withing this function&#39;s block scope</code></pre><pre name="977b" id="977b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  let say = () =&gt; console.log(text);<br>  return say<br>}</code></pre><pre name="6519" id="6519" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let say2 = sayHelloTo(&#39;Paul&#39;);</code></pre><pre name="048e" id="048e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// say2();   // =&gt; Hello Paul</code></pre><pre name="069b" id="069b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/*<br>The above code has a closure because the anonymous function function() { console.log(text); } is declared inside another function, sayHello2() in this example. In JavaScript, if you use the function keyword inside another function, you are creating a closure.</code></pre><pre name="fd75" id="fd75" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Here, say2 has reference to a function.  In JavaScript, you can think of a function reference variable as having both a pointer to a function as well as a hidden pointer to a closure.</code></pre><pre name="6dd8" id="6dd8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">If I declare a function within another function, then the local variables can remain accessible after returning from the function I called</code></pre><pre name="845f" id="845f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">In above, I call the function say2() after we have returned from sayHello2(). The code that we call is still able to reference the variable &#39;text&#39;, which was a local variable of the function sayHello2()</code></pre><pre name="9471" id="9471" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">*/</code></pre><pre name="7518" id="7518" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">showFullName = (first, last) =&gt; {</code></pre><pre name="d01a" id="d01a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  let introText = &quot;Your name is &quot;;</code></pre><pre name="a0b3" id="a0b3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  constructFullName = () =&gt; introText + first + &quot; &quot; + last</code></pre><pre name="72bf" id="72bf" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return constructFullName();<br>}</code></pre><pre name="ee31" id="ee31" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(showFullName(&quot;Rohan&quot;, &quot;Paul&quot;)); // =&gt; Your name is Rohan Paul</code></pre><pre name="365e" id="365e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">//--------------------------------------------------------------<br><br></code></pre><pre name="b39d" id="b39d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// implement function add in such a way that:<br>// add() =&gt; 0<br>// add(1)(2)() =&gt; 3<br>// add(n0)(n1)...(nk)() =&gt; n0+n1+...+nk</code></pre><pre name="18ab" id="18ab" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function add(val){<br>    var total = 0;<br>    var result;<br>    var step = val =&gt; {<br>        if(val === undefined){<br>            result = total;<br>            total = 0;<br>            return result;<br>        } else {<br>            total += val;<br>        }</code></pre><pre name="04ad" id="04ad" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">        return step;<br>    }</code></pre><pre name="9f60" id="9f60" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    result = step(val);</code></pre><pre name="ce68" id="ce68" class="graf graf--pre graf-after--pre graf--trailing"><code class="markup--code markup--pre-code">    return result;<br>}</code></pre></div></div></section><section name="9854" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><pre name="4a65" id="4a65" class="graf graf--pre graf--leading"><code class="markup--code markup--pre-code">// In the following examples we will predict what will <br>// be printed to the terminal<br><br></code></pre><pre name="f3bb" id="f3bb" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 1</code></pre><pre name="d309" id="d309" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function dinerBreakfast(food) {<br>    let order = &quot;I&#39;d like cheesy scrambled eggs and &quot;;</code></pre><pre name="e085" id="e085" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    function finishOrder() {<br>        return order + food;<br>    }</code></pre><pre name="3e6d" id="3e6d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    return finishOrder();<br>}</code></pre><pre name="e293" id="e293" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// console.log(dinerBreakfast(&#39;green tea&#39;));</code></pre><pre name="d0ee" id="d0ee" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 2</code></pre><pre name="11d9" id="11d9" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function dinerBreakfast2(food) {<br>    let order = &quot;I&#39;d like a(n) &quot; + food;</code></pre><pre name="de63" id="de63" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    function withEggs() {<br>        order = order + &#39; and cheesy scrambled eggs, please!&#39;<br>    };</code></pre><pre name="820a" id="820a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    withEggs();<br>    return order;<br>}</code></pre><pre name="976f" id="976f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// console.log(dinerBreakfast2(&#39;avocado toast&#39;));</code></pre><pre name="0aea" id="0aea" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 3</code></pre><pre name="1d1c" id="1d1c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function dinerBreakfast3() {<br>    let order = &quot;I&#39;d like cheesy scrambled eggs&quot;;</code></pre><pre name="a676" id="a676" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    return food =&gt; {<br>        order = order + &quot; and &quot; + food;<br>        return order;<br>    };<br>}</code></pre><pre name="e806" id="e806" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let breakfastOrder = dinerBreakfast3();</code></pre><pre name="f76b" id="f76b" class="graf graf--pre graf-after--pre graf--trailing"><code class="markup--code markup--pre-code">console.log(breakfastOrder);<br>console.log(breakfastOrder(&#39;cappuccino&#39;));<br>console.log(breakfastOrder(&#39;pancakes&#39;));</code></pre></div></div></section><section name="5210" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><pre name="f1dc" id="f1dc" class="graf graf--pre graf--leading"><code class="markup--code markup--pre-code">/* Problem statement - we would like to display numbers 1 to 5 at once sequentially. But we want to delay the output and have each number display 1 second apart from each other consecutively.</code></pre><pre name="df87" id="df87" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">The below solution may come to mind first. But whats the output of the below code, whats wrong with it and fix it */</code></pre><pre name="2b0c" id="2b0c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// for (var i = 1; i &lt;= 5; i++) {<br>//     setTimeout(function() {<br>//         console.log(i);<br>//     }, 1000 * i);<br>// }</code></pre><pre name="a42d" id="a42d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/* A) The problem with the above code is, numbers are each outputting to console 1 second after another consecutively, but they are all 6s. So we now have 6 6 6 6 6 as the end result.</code></pre><pre name="ec58" id="ec58" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">The reason for this is because the setTimeout function creates a function (the closure) that has access to its outer scope, which is the for loop that contains the index i. After 1 second go by, the function is executed and it prints out the value of i, which at the end of the loop is at 6 because it cycles through 0, 1, 2, 3, 4, 5, 6 and the loop finally stops at 6 .</code></pre><pre name="8317" id="8317" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">B) The problem resides in the variable i we&#39;re passing into setTimeout(). In this case, we&#39;re simply passing the reference to the variable i, and not the actual value at the moment inside each loop. Therefore, by the time the setTimeout() function is executed (after 1, 2, 3, 4, and 5 seconds in this case), the for statement has already been executed and incremented i to the final value of 6.</code></pre><pre name="3b86" id="3b86" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">In other words, we are not passing value of i to the callback function of setTimeout(), instead what we are telling the callback function is too look for the variable i when it is executed at a later time. When the callback functions run, the variable i will be set to 6, since the callbacks will run after the loop completes... and that is why get the value 6.</code></pre><pre name="c824" id="c824" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">C) Explanation why the time interval is taking 1 second for consoling out the last value of 6 i.e. printing &quot;6&quot; five times with 1 second of time interval and NOT 6 seconds - Because, the setTimeout() function is only executed once (while setInterval() is for repeat execution ). And the i outside the curly braces (which is the second argument of the setInterval function ) takes the first value of i which is 1 second and get executed once and then stops.<br>*/</code></pre><pre name="7de1" id="7de1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/* SOLUTION -<br>To print the successive values of i with an interval of 1 second, we need to pass into setTimeout() the actual value of i at the moment of each loop execution in the for statement.  */</code></pre><pre name="9706" id="9706" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">funcToExecute = x =&gt; () =&gt; {<br>  console.log(x);<br>};</code></pre><pre name="9a1a" id="9a1a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">for (var i = 1; i &lt;= 5; i++) {<br>  setTimeout(funcToExecute(i), i * 500);<br>}</code></pre><pre name="126f" id="126f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/* More Explanation on why the delay is happening in the correct solution and not in the original solution -</code></pre><pre name="7f53" id="7f53" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">In JavaScript you only have 2 ways of passing an argument....pass by value or pass by reference.</code></pre><pre name="cee4" id="cee4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">In the incorrect solution above in the loop, i is being passed by reference. So the loop is done by the time first console.log runs and and i is already at 6. To pass by reference in JavaScript, the argument has to be object.property. However in the loop case above, this is a exception where a variable is being passed as a reference to the value instead of the value itself.</code></pre><pre name="66ce" id="66ce" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Now, other than the loop exception.... if you pass a variable as a arg into a function(x).... you are passing by value. Thus, passing the variable i in the function(x) passes by value.<br>*/</code></pre><pre name="3f61" id="3f61" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/***********************************************************************<br>Let&#39;s practice writing closures by creating a method called `dynamicMultiply(num)`.<br>The dynamicMultiply function will return a new function that will allow us to<br>create new separate custom multiply functions.<br><br></code></pre><pre name="272b" id="272b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Look below to see how this function is invoked:</code></pre><pre name="688e" id="688e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const doubler = dynamicMultiply(2); // returns a functions<br>doubler(5); // returns 10</code></pre><pre name="fa33" id="fa33" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const tripler = dynamicMultiply(3);<br>tripler(5); // returns 15</code></pre><pre name="a933" id="a933" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const multiplyByFive = dynamicMultiply(5);<br>multiplyByFive(5); // returns 25<br><br></code></pre><pre name="9689" id="9689" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">***********************************************************************/</code></pre><pre name="5b0e" id="5b0e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function dynamicMultiply( num ) {<br>  let multiplier = num;</code></pre><pre name="c531" id="c531" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return factor =&gt; multiplier * factor;<br>}</code></pre><pre name="3699" id="3699" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/***********************************************************************<br>Let&#39;s practice writing closures by creating a function named `sandwichMaker()`.<br>This function will return another function that will accept a string to add <br>to the sandwich order (which will start off with a default &quot;tomato&quot; ingredient),<br>separating each incoming ingredient with &quot;and&quot;.</code></pre><pre name="410e" id="410e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Look below to see how this function is invoked:</code></pre><pre name="734a" id="734a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">let sandwich = sandwichMaker(); // =&gt; returns a function<br>sandwich(&quot;spinach&quot;) // =&gt; &quot;One sandwich with tomato and spinach&quot;<br>sandwich(&quot;jelly&quot;) // =&gt; &quot;One sandwich with tomato and spinach and jelly&quot;<br>sandwich(&quot;bread&quot;) // =&gt; &quot;One sandwich with tomato and spinach and jelly and bread&quot;</code></pre><pre name="cc14" id="cc14" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Another Sandwich:<br>let sandwich2 = sandwichMaker(); // =&gt; returns a function<br>sandwich2(&quot;pb&quot;) // =&gt; &quot;One sandwich with tomato and pb&quot;</code></pre><pre name="1bea" id="1bea" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">***********************************************************************/</code></pre><pre name="d68f" id="d68f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function sandwichMaker() {<br>  let order = &quot;One sandwich with tomato&quot;;</code></pre><pre name="c601" id="c601" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  return food =&gt; {<br>    order = order.slice(0, order.length) + &quot; and &quot; + food;<br>    return order;<br>  };<br>}</code></pre><pre name="8565" id="8565" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/**************DO NOT MODIFY ANYTHING UNDER THIS  LINE*****************/<br>module.exports = sandwichMaker;</code></pre><pre name="fe68" id="fe68" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/*</code></pre><pre name="4253" id="4253" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Closures<br>The inner function can access the variables of the enclosing function due to closures in JavaScript. In other words, the inner function preserves the scope chain of the enclosing function at the time the enclosing function was executed, and thus can access the enclosing function&#39;s variables.</code></pre><pre name="7341" id="7341" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">The closure has three scope chains:</code></pre><pre name="47a6" id="47a6" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">it has access to its own scope — variables defined between its curly brackets<br>it has access to the outer function&#39;s variables<br>it has access to the global variables<br> */</code></pre><pre name="9cf3" id="9cf3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">var text = &quot;outside&quot;;</code></pre><pre name="173a" id="173a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function logText() {<br>  console.log(text); // ans: &#39;undefined&#39;<br>  var text = &quot;inside&quot;;<br>  console.log(text); // ans:&#39;inside&#39;<br>}</code></pre><pre name="9f2c" id="9f2c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">logText();</code></pre><pre name="2e0d" id="2e0d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/* When I run the above code, the first &lt; console.log(text) &gt; will print &#39;undefined&#39; instead of &#39;outside&#39; - Here&#39;s Why - Because, I have the variable &#39;text&#39; declared and assigned both inside the function and outside the function -<br>https://medium.com/backticks-tildes/understanding-hoisting-and-scoping-in-javascript-39ea7b41e31</code></pre><pre name="fe07" id="fe07" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Variable Shadowing -</code></pre><pre name="4e5d" id="4e5d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">In JavaScript, variables with the same name can be specified at multiple layers of nested scope. In such case local variables gain priority over global variables. If you declare a local variable and a global variable with the same name, the local variable will take precedence when you use it inside a function. This type of behavior is called shadowing. Simply put, the inner variable shadows the outer. This is how the Javascript interpreter finds a particular variable; it searches for the variable at the innermost scope being executed at the time, and continues until the first match is found, even if there are other variables with the same name in the outer scope.</code></pre><pre name="5505" id="5505" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">So in above, it takes the &#39;text&#39; declared inside the function, but then only variable declaration is hoisted and NOT variable-assignment. So here, I am trying to print the &#39;outside&#39; variable before assigning a value to it. So it prints undefined.</code></pre><pre name="ab92" id="ab92" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">*/</code></pre><pre name="88f0" id="88f0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">var c = 15;</code></pre><pre name="b15c" id="b15c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function outer() {<br>  console.log(c);<br>  // the above will print &#39;undefined&#39; instead of &#39;15&#39;<br>  // because, just like the above example of &#39;Variable Shadowing&#39;, variable declaration is hoisted but not variable assignment,<br>  // And variable declared inside the function-scope will take precedence over the one declared outside</code></pre><pre name="bd3e" id="bd3e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  var b = 10;<br>  var c = 25;<br>  function inner() {<br>    var a = 20;<br>    console.log(a + b + c); // =&gt; but this will correctly print 55, because at this point I have the correct reference to all the variable values<br>  }<br>  return inner();<br>}</code></pre><pre name="9d07" id="9d07" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">outer();</code></pre><pre name="83aa" id="83aa" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/*</code></pre><pre name="5ddc" id="5ddc" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Final output from outer()</code></pre><pre name="fe1c" id="fe1c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">undefined<br>55<br><br></code></pre><pre name="b33b" id="b33b" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">1 &gt; https://medium.freecodecamp.org/javascript-closures-simplified-d0d23fa06ba4</code></pre><pre name="4c09" id="4c09" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Function outer() finishes execution, and all variables within the scope of outer() now no longer exist.<br>This last part is important to understand. Once a function completes its execution, any variables that were defined inside the function scope cease to exist.</code></pre><pre name="fe6e" id="fe6e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">The lifespan of a variable defined inside of a function is the lifespan of the function execution.</code></pre><pre name="2f0a" id="2f0a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">What this means is that in console.log(a+b), the variable b exists only during the execution of the the outer() function. Once the outer function has finished execution, the variable b no longer exists.</code></pre><pre name="ddcb" id="ddcb" class="graf graf--pre graf-after--pre graf--trailing"><code class="markup--code markup--pre-code"> */</code></pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/50a59e79703f"><time class="dt-published" datetime="2021-08-31T15:52:48.421Z">August 31, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/closure-in-javascript-50a59e79703f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 12, 2021.</p></footer></article></body></html>