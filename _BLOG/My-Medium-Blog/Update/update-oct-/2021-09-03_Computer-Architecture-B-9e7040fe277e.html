<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Computer Architecture B</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Computer Architecture B</h1>
</header>
<section data-field="subtitle" class="p-summary">
Introduction to Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="eb0d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fb07" id="fb07" class="graf graf--h3 graf--leading graf--title">Computer Architecture Basics</h3><h3 name="d2db" id="d2db" class="graf graf--h3 graf-after--h3">Introduction to Computer Architecture</h3><h4 name="fab5" id="fab5" class="graf graf--h4 graf-after--h3">Transistors:</h4><p name="cb77" id="cb77" class="graf graf--p graf-after--h4">Basic element of computation that controls the flow of electricity, similar to but different than a switch. Transistors are used to build logic gates.</p><figure name="ee06" id="ee06" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*j4MIDugdWQzDyV5g.jpg" data-width="750" data-height="421" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*j4MIDugdWQzDyV5g.jpg"></figure><h4 name="89f7" id="89f7" class="graf graf--h4 graf-after--figure">Logic gate:</h4><figure name="f2d7" id="f2d7" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*R3XZDUeZgX-1WW62.png" data-width="854" data-height="462" src="https://cdn-images-1.medium.com/max/800/0*R3XZDUeZgX-1WW62.png"></figure><p name="43b9" id="43b9" class="graf graf--p graf-after--figure">A collection of transistors put together to perform one of the basic boolean logic functions on a single bit or a collection of bits. (E.g., AND, NOT, XOR, OR, NAND, NOR)</p><p name="f932" id="f932" class="graf graf--p graf-after--p">NAND gate is made of two transistors.<br>NAND and NOR gates are called functionally complete since they can each be used to build any other gates.</p><p name="7999" id="7999" class="graf graf--p graf-after--p">If you can make a NAND gate, you can make an entire computer.</p><h4 name="e1ac" id="e1ac" class="graf graf--h4 graf-after--p">Flip flop:</h4><figure name="543d" id="543d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*0jUR0auaBHNzbnlQFtorNg.png" data-width="593" data-height="190" src="https://cdn-images-1.medium.com/max/800/1*0jUR0auaBHNzbnlQFtorNg.png"></figure><p name="64b8" id="64b8" class="graf graf--p graf-after--figure">Basic memory storage device that can be used to hold registers — main memory is rarely made up of flip flops.</p><h4 name="5a01" id="5a01" class="graf graf--h4 graf-after--p">AND Gate:</h4><figure name="72cd" id="72cd" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*jqMiCHzdfhesn2dh.jpg" data-width="289" data-height="302" src="https://cdn-images-1.medium.com/max/800/0*jqMiCHzdfhesn2dh.jpg"></figure><p name="96f6" id="96f6" class="graf graf--p graf-after--figure">It has two inputs (can have more than two) and it has an output.</p><p name="a1e0" id="a1e0" class="graf graf--p graf-after--p">A with a 1 on it, B with a 1 on it, want output to have 1 on it.</p><h4 name="2c56" id="2c56" class="graf graf--h4 graf-after--p">Boolean Logic:</h4><p name="90f5" id="90f5" class="graf graf--p graf-after--h4">If condition A is true &amp;&amp; condition B is true… If condition A || condition B is true…</p><p name="f210" id="f210" class="graf graf--p graf-after--p">Basic Boolean operations are often demonstrated with truth tables. Values on left are input, values on left are result:</p><figure name="e9af" id="e9af" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2NaKQ6U97e641Qsz8LtweA.png" data-width="810" data-height="562" src="https://cdn-images-1.medium.com/max/800/1*2NaKQ6U97e641Qsz8LtweA.png"></figure><figure name="5b8c" id="5b8c" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*vpAdjV5FXIYP2gK1vS5D_w.png" data-width="808" data-height="861" src="https://cdn-images-1.medium.com/max/800/1*vpAdjV5FXIYP2gK1vS5D_w.png"></figure><pre name="0684" id="0684" class="graf graf--pre graf-after--figure"><code class="markup--code markup--pre-code">128 64 32 16  8 4 2 1<br>    0  0  0  0  1 1 0 0 = 8 + 4 = 12<br>|   0  1  1  0  0 1 1 1 = 64 + 32 + 4 + 2 + 1 = 103<br>    0  1  1  0  1 1 1 1 = 64 + 32 + 8 + 4 + 2 + 1 = 111</code></pre><pre name="b593" id="b593" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">     128 64 32 16 8 4 2 1<br>     1    1  0  1 0 1 1 0 = 128 + 64 + 16 + 4 + 2 = 214<br>AND  1    1  1  1 0 0 0 0 = 128 + 64 + 32 + 16 = 240<br>     1    1  0  1 0 0 0 0 = 128 + 64 + 16 = 208</code></pre><p name="25e4" id="25e4" class="graf graf--p graf-after--pre">If you want to extract two bits, you can shift a number</p><pre name="fcb0" id="fcb0" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">Original number: 01101111<br>Shifted one to the right: 001101111 &lt;-- last one will fall off into space<br>Shifted two to the right: 00011011<br>Shifted three to the right: 00001101<br>Shifted four to the right: 00000110<br>Shifted five to the right: 00000011<br>Shifted six to the right: 00000001</code></pre><pre name="9bd6" id="9bd6" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">     00000001 = b<br>&amp;    00000011 - and mask<br>-------------<br>     00000001</code></pre><pre name="943a" id="943a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">a = 0b01101111;<br>b = a &gt;&gt; 6;</code></pre><h3 name="4196" id="4196" class="graf graf--h3 graf-after--pre">Architecture:</h3><p name="6e1b" id="6e1b" class="graf graf--p graf-after--h3">Visual 6502 : Can see what parts of memory are being accessed during program execution.</p><h3 name="68e2" id="68e2" class="graf graf--h3 graf-after--p">While program running:</h3><p name="3967" id="3967" class="graf graf--p graf-after--h3">Has to go out to RAM to see what the next instruction is. How is a number a computer instruction? Register — program counter: holds the index into memory of where the next instruction is, will store it in the instruction manager (IR).</p><p name="9fff" id="9fff" class="graf graf--p graf-after--p">In our simulation, 8 bits, each bit has a meaning. Some of the bits get stripped off and go to the control unit, some get stripped and sent to register file, and some go to the ALU.</p><p name="5d1b" id="5d1b" class="graf graf--p graf-after--p">Register file — R0 to R7 (all CPUs have different register names, this is a common one) — registers are like variables. R0 to R7, that’s not many variables. Within the CPU, extremely fast to operate on.</p><p name="ce61" id="ce61" class="graf graf--p graf-after--p">When a compiler builds code to run on the CPU, tries to use registers as much as possible to keep the speed high.</p><h3 name="4c1e" id="4c1e" class="graf graf--h3 graf-after--p">ALU — arithmetic logic unit:</h3><p name="1d6a" id="1d6a" class="graf graf--p graf-after--h3">Responsible for arithmetic and bitwise operations, and comparisons between numbers.</p><h3 name="80f6" id="80f6" class="graf graf--h3 graf-after--p">Cache:</h3><p name="1ecf" id="1ecf" class="graf graf--p graf-after--h3">High speed memory that’s close to the CPU. If reading byte at address 10, likely to get address 11, so cache stores subsequent bytes when retrieving data from RAM.</p><h3 name="6122" id="6122" class="graf graf--h3 graf-after--p">Memory Address Register:</h3><p name="0465" id="0465" class="graf graf--p graf-after--h3">Address of memory we’re interested in reading or writing. Memory Data Register: In case of write, holds value of what we want to write. In the case of a read, MDR gets loaded with the value that is in memory at the Memory Address Register address.</p><p name="026e" id="026e" class="graf graf--p graf-after--p">In our emulator, you’ll see this in the emulator.js file</p><h3 name="e332" id="e332" class="graf graf--h3 graf-after--p">Interrupt Handler:</h3><p name="8e7d" id="8e7d" class="graf graf--p graf-after--h3">If key gets hit, raises a voltage on a wire, which goes to the interrupt handler which sets a value in the interrupt status register and the CPU sees it. When it goes to execute the next instruction, a complicated set of steps happen where it finds another location in memory to begin executing instructions. That other location will handle the interrupt handler program. Interrupt handler returns and code continues executing like it did before the interrupt occurred.</p><ul class="postList"><li name="bb81" id="bb81" class="graf graf--li graf-after--p">Interrupt flow of execution, perform some action in the handler, and then resume the flow of execution where the interrupt left off.</li></ul><p name="8720" id="8720" class="graf graf--p graf-after--li">Can decide which interrupts you’re interested in by using the interrupt mask register — gets bitwise ANDed with the status register and masks out interrupts you’re not interested in.</p><p name="605a" id="605a" class="graf graf--p graf-after--p">Our CPU has two interrupts defined: a timer interrupt that occurs once per second, and a keyboard interrupt when a key is pressed. By setting interrupt register mask to all 0, masks them out so you don’t get any interrupts.</p><p name="65f0" id="65f0" class="graf graf--p graf-after--p">One of the problems with having the CPU be the sole control of the RAM, the CPU will be busy copying data into RAM from devices that have a lot of data to present to it.</p><p name="fb2a" id="fb2a" class="graf graf--p graf-after--p">For example, if you have a disk and the OS wants to read block 7004 on the disk, the OS is going to command the peripheral to read block 7004 and get back to it when it’s done. How will CPU know it’s finished? Will get an interrupt.</p><p name="3811" id="3811" class="graf graf--p graf-after--p">Direct memory access — disk is asked to read a block, it puts it into memory and when it’s loaded, an interrupt happens to let the CPU know the information is there.</p><p name="1c21" id="1c21" class="graf graf--p graf-after--p">When we write the emulator, we’ll have registers, an ALU, a PC to keep track of what instruction we’re doing, an instruction register, simulated RAM that allows you to read and write bytes from RAM.</p><h3 name="0c71" id="0c71" class="graf graf--h3 graf-after--p">Important to remember: Individual instructions don’t do very much.</h3><h4 name="0b8f" id="0b8f" class="graf graf--h4 graf-after--h3">ADD:</h4><p name="ad6a" id="ad6a" class="graf graf--p graf-after--h4">Adds two numbers.</p><h4 name="be2a" id="be2a" class="graf graf--h4 graf-after--p">COMPARE:</h4><p name="ffc9" id="ffc9" class="graf graf--p graf-after--h4">Compares two numbers and sets flags whether numbers are greater than, equal or less than each other.</p><h4 name="97b9" id="97b9" class="graf graf--h4 graf-after--p">JUMP:</h4><p name="d1aa" id="d1aa" class="graf graf--p graf-after--h4">Takes program counter from where it’s running, jumps to another address and continues running there. Individual handlers we write in our emulator to simulate the individual instructions are short, usually one-liners.</p><p name="ae28" id="ae28" class="graf graf--p graf-after--p">Complexity of how to make a CPU work is from building on these tiny instructions. Doing that is a pain, which is why nobody programs that way.</p><p name="2da9" id="2da9" class="graf graf--p graf-after--p">Machine code — usually if you write in machine code, hexadecimal.</p><p name="2114" id="2114" class="graf graf--p graf-after--p">Mnemonics are great — three or four letter code lets you know what you’re doing (easier than remembering a hexadecimal number).</p><p name="0110" id="0110" class="graf graf--p graf-after--p">Talking about CPU and assembly language is down to the metal.</p><h3 name="201a" id="201a" class="graf graf--h3 graf-after--p">Clock:</h3><p name="c534" id="c534" class="graf graf--p graf-after--h3">Driver of voltage that goes up and down several times a second — every time it raises or lowers, work gets done. A lot of instructions just take one clock to execute. You can execute billions of instructions per second on a modern CPU.</p><h3 name="7e38" id="7e38" class="graf graf--h3 graf-after--p">Operations or Opcodes:</h3><p name="3439" id="3439" class="graf graf--p graf-after--h3">Opcode is shorthand for the instruction that you’re executing — not the data it’s working on. ADD Register 0 to Register 4 — Opcode is AND. Register 0 and Register 4 are operands.</p><h3 name="44e0" id="44e0" class="graf graf--h3 graf-after--p">Bus:</h3><p name="c310" id="c310" class="graf graf--p graf-after--h3">A way for information to get from one part of the motherboard to another part of the motherboard. It’s like a telephone line (bunch of wires). Different buses on the system that get used to move information back and forth.</p><h3 name="5595" id="5595" class="graf graf--h3 graf-after--p">RAM:</h3><p name="5d35" id="5d35" class="graf graf--p graf-after--h3 graf--trailing">Grid of bits — more commonly exposed to programmers at machine level and up as an array of bytes. Program counter will be an index into the array of bytes.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/9e7040fe277e"><time class="dt-published" datetime="2021-09-03T17:15:31.848Z">September 3, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/computer-architecture-b-9e7040fe277e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 12, 2021.</p></footer></article></body></html>