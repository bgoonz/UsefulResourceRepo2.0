<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Fundamental Concepts In JavaScript</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Fundamental Concepts In JavaScript</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is the stuff that comes up on interviews… Cheatsheet Included Below!
</section>
<section data-field="body" class="e-content">
<section name="dc8e" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a4f0" id="a4f0" class="graf graf--h3 graf--leading graf--title">Fundamental Concepts In JavaScript</h3><h4 name="0f4f" id="0f4f" class="graf graf--h4 graf-after--h3 graf--subtitle">This is the stuff that comes up on interviews… Cheatsheet Included Below!</h4><figure name="3af0" id="3af0" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*v_HRUxnqaDN-wJd8.png" data-width="880" data-height="373" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*v_HRUxnqaDN-wJd8.png"></figure><p name="527a" id="527a" class="graf graf--p graf-after--figure">Or even deeper:</p><h3 name="4929" id="4929" class="graf graf--h3 graf-after--p">Here are most of the below exercises!</h3><figure name="ce39" id="ce39" class="graf graf--figure graf--iframe graf-after--h3"><iframe src="https://replit.com/@bgoonz/funcamentalJS?lite=true&amp;amp%3Breferrer=https%3A%2F%2Fbryanguner.medium.com&amp;lite=true" width="700" height="525" frameborder="0" scrolling="no"></iframe></figure></div><div class="section-inner sectionLayout--outsetColumn"><figure name="5d8b" id="5d8b" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure"><img class="graf-image" data-image-id="1*99CR4DhBOCjuVCkkK-lLwg.png" data-width="2200" data-height="1700" src="https://cdn-images-1.medium.com/max/1200/1*99CR4DhBOCjuVCkkK-lLwg.png"></figure><figure name="11e8" id="11e8" class="graf graf--figure graf--layoutOutsetCenter graf-after--figure"><img class="graf-image" data-image-id="1*UKRWX0waAKW3M_ZWJgRUmA.jpeg" data-width="2198" data-height="1044" src="https://cdn-images-1.medium.com/max/1200/1*UKRWX0waAKW3M_ZWJgRUmA.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="1fd7" id="1fd7" class="graf graf--li graf-after--figure">Label variables as either Primitive vs. Reference</li><li name="de11" id="de11" class="graf graf--li graf-after--li">primitives: strings, booleans, numbers, null and undefined</li><li name="c203" id="c203" class="graf graf--li graf-after--li">primitives are immutable</li><li name="254c" id="254c" class="graf graf--li graf-after--li">refereces: objects (including arrays)</li><li name="80bc" id="80bc" class="graf graf--li graf-after--li">references are mutable</li><li name="8b53" id="8b53" class="graf graf--li graf-after--li">Identify when to use <code class="markup--code markup--li-code">.</code> vs <code class="markup--code markup--li-code">[]</code> when accessing values of an object</li><li name="cb76" id="cb76" class="graf graf--li graf-after--li">dot syntax <code class="markup--code markup--li-code">object.key</code></li><li name="91bc" id="91bc" class="graf graf--li graf-after--li">easier to read</li><li name="7ff8" id="7ff8" class="graf graf--li graf-after--li">easier to write</li><li name="a46a" id="a46a" class="graf graf--li graf-after--li">cannot use variables as keys</li><li name="74e2" id="74e2" class="graf graf--li graf-after--li">keys cannot begin with a number</li><li name="c648" id="c648" class="graf graf--li graf-after--li">bracket notation <code class="markup--code markup--li-code">object[&quot;key]</code></li><li name="5677" id="5677" class="graf graf--li graf-after--li">allows variables as keys</li><li name="f562" id="f562" class="graf graf--li graf-after--li">strings that start with numbers can be use as keys</li><li name="08df" id="08df" class="graf graf--li graf-after--li">Write an object literal with a variable key using interpolation</li></ul><h3 name="5680" id="5680" class="graf graf--h3 graf-after--li">put it in brackets to access the value of the variable, rather than just making the value that string</h3><figure name="17c0" id="17c0" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/deae28d93966d1cfdad250fe17fbb24f.js"></script></figure><ul class="postList"><li name="d0b0" id="d0b0" class="graf graf--li graf-after--figure">Use the <code class="markup--code markup--li-code">obj[key] !== undefined</code> pattern to check if a given variable that contains a key exists in an object</li><li name="9f75" id="9f75" class="graf graf--li graf-after--li">can also use <code class="markup--code markup--li-code">(key in object)</code> syntax interchangeably (returns a boolean)</li><li name="811d" id="811d" class="graf graf--li graf-after--li">Utilize Object.keys and Object.values in a function</li><li name="1f44" id="1f44" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Object.keys(obj)</code> returns an array of all the keys in <code class="markup--code markup--li-code">obj</code></li><li name="8efe" id="8efe" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Object.values(obj)</code> returns an array of the values in <code class="markup--code markup--li-code">obj</code></li></ul><h3 name="6d28" id="6d28" class="graf graf--h3 graf-after--li">Iterate through an object using a <code class="markup--code markup--h3-code">for in</code> loop</h3><figure name="a855" id="a855" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/7a594a256493eea522c0363b9302d459.js"></script></figure><h3 name="6bde" id="6bde" class="graf graf--h3 graf-after--figure">Define a function that utilizes <code class="markup--code markup--h3-code">...rest</code> syntax to accept an arbitrary number of arguments</h3><ul class="postList"><li name="eb23" id="eb23" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">...rest</code> syntax will store all additional arguments in an array</li><li name="e2d4" id="e2d4" class="graf graf--li graf-after--li">array will be empty if there are no additional arguments</li></ul><figure name="4acc" id="4acc" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/97dc6ccc49c420f942b69250dd1032ab.js"></script></figure><h3 name="d487" id="d487" class="graf graf--h3 graf-after--figure">Use <code class="markup--code markup--h3-code">...spread</code> syntax for Object literals and Array literals</h3><figure name="59fe" id="59fe" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/3a4bec729479bc6d0fb8b749f94165f7.js"></script></figure><ul class="postList"><li name="438a" id="438a" class="graf graf--li graf-after--figure">Destructure an array to reference specific elements</li></ul><figure name="4241" id="4241" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/08cc137a676266a204fc795060cebfb3.js"></script></figure><h3 name="cf58" id="cf58" class="graf graf--h3 graf-after--figure">Write a function that accepts a array as an argument and returns an object representing the count of each character in the array</h3><figure name="49cc" id="49cc" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/0832c28a42491a08a915f7b6277f5a38.js"></script></figure><h3 name="ecff" id="ecff" class="graf graf--h3 graf-after--figure">Callbacks Lesson Concepts</h3><ul class="postList"><li name="133e" id="133e" class="graf graf--li graf-after--h3">Given multiple plausible reasons, identify why functions are called “First Class Objects” in JavaScript.</li><li name="22a1" id="22a1" class="graf graf--li graf-after--li">they can be stored in variables, passed as arguments to other functions, and serve as return value for a function</li><li name="5b83" id="5b83" class="graf graf--li graf-after--li">supports same basic operations as other types (strings, bools, numbers)</li><li name="2419" id="2419" class="graf graf--li graf-after--li">higher-order functions take functions as arguments or return functions as values</li><li name="2cc7" id="2cc7" class="graf graf--li graf-after--li">Given a code snippet containing an anonymous callback, a named callback, and multiple <code class="markup--code markup--li-code">console.log</code>s, predict what will be printed</li><li name="7d16" id="7d16" class="graf graf--li graf-after--li">what is this referring to?</li><li name="e1c6" id="e1c6" class="graf graf--li graf-after--li">Write a function that takes in a value and two callbacks. The function should return the result of the callback that is greater.</li></ul><figure name="0360" id="0360" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/313653da551081a72b4ca0ea74ee472a.js"></script></figure><h4 name="cb6a" id="cb6a" class="graf graf--h4 graf-after--figure">Write a function, myMap, that takes in an array and a callback as arguments. The function should mimic the behavior of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">`Array#map`.</a></h4><figure name="35c7" id="35c7" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/0be14434eb3edee7671e1154dab1ef09.js"></script></figure><h3 name="4409" id="4409" class="graf graf--h3 graf-after--figure">Write a function, myFilter, that takes in an array and a callback as arguments. The function should mimic the behavior of <code class="markup--code markup--h3-code">Array#filter</code>.</h3><figure name="6f0f" id="6f0f" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/f7a4bb8f34472a0e51bb95ebcae4d239.js"></script></figure><h3 name="2a56" id="2a56" class="graf graf--h3 graf-after--figure">Write a function, myEvery, that takes in an array and a callback as arguments. The function should mimic the behavior of <code class="markup--code markup--h3-code">Array#every</code>.</h3><figure name="8249" id="8249" class="graf graf--figure graf--iframe graf-after--h3 graf--trailing"><script src="https://gist.github.com/bgoonz/c106182ced28c1b0da641958b2f49691.js"></script></figure></div></div></section><section name="5896" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a53d" id="a53d" class="graf graf--h3 graf--leading">Scope Lesson Concepts</h3><figure name="6739" id="6739" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*2WT03WQBOGKWH_9i.png" data-width="880" data-height="518" src="https://cdn-images-1.medium.com/max/800/0*2WT03WQBOGKWH_9i.png"></figure><ul class="postList"><li name="cd3f" id="cd3f" class="graf graf--li graf-after--figure">Identify the difference between <code class="markup--code markup--li-code">const</code>, <code class="markup--code markup--li-code">let</code>, and <code class="markup--code markup--li-code">var</code> declarations</li></ul><blockquote name="39b7" id="39b7" class="graf graf--blockquote graf-after--li"><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">const</em></strong></code><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em"> - cannot reassign variable, scoped to block</em></strong></blockquote><blockquote name="d119" id="d119" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">let</em></strong></code><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em"> - can reassign variable, scoped to block</em></strong></blockquote><blockquote name="5317" id="5317" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">var</em></strong></code><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em"> - outdated, may or may not be reassigned, scoped to function. can be not just reassigned, but also redeclared!</em></strong></blockquote><ul class="postList"><li name="dc31" id="dc31" class="graf graf--li graf-after--blockquote"><em class="markup--em markup--li-em">a variable will always evaluate to the value it contains regardless of how it was declared</em></li></ul><h4 name="2bc8" id="2bc8" class="graf graf--h4 graf-after--li">Explain the difference between <code class="markup--code markup--h4-code">const</code>, <code class="markup--code markup--h4-code">let</code>, and <code class="markup--code markup--h4-code">var</code> declarations</h4><blockquote name="0a89" id="0a89" class="graf graf--blockquote graf-after--h4"><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">var</em></code><em class="markup--em markup--blockquote-em"> is function scoped—so if you declare it anywhere in a function, the declaration </em><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">(but not assignment…the fact that it exists is known to the javascript engine but the value assigned to it is a mystery until the code is run line by line!) is &quot;hoisted&quot; </em></strong><em class="markup--em markup--blockquote-em">so it will </em><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">exist in memory as “undefined”</em></strong><em class="markup--em markup--blockquote-em"> which is bad and unpredictable</em></blockquote><blockquote name="cec8" id="cec8" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">var</em></code><em class="markup--em markup--blockquote-em"> will also allow you to redeclare a variable, while </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">let</em></code><em class="markup--em markup--blockquote-em"> or </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">const</em></code><em class="markup--em markup--blockquote-em"> will raise a syntax error. you shouldn&#39;t be able to do that!</em></blockquote><h4 name="8d7a" id="8d7a" class="graf graf--h4 graf-after--blockquote"><code class="markup--code markup--h4-code"><em class="markup--em markup--h4-em">!!const</em></code><em class="markup--em markup--h4-em"> won&#39;t let you reassign a variable!!</em></h4><blockquote name="3769" id="3769" class="graf graf--blockquote graf-after--h4"><em class="markup--em markup--blockquote-em">but if it points to a mutable object, you will still be able to change the value by mutating the object</em></blockquote><ul class="postList"><li name="2e8a" id="2e8a" class="graf graf--li graf-after--blockquote"><strong class="markup--strong markup--li-strong">block-scoped variables allow new variables with the same name in new scopes</strong></li><li name="b7a6" id="b7a6" class="graf graf--li graf-after--li">block-scoped still performs hoisting of all variables within the block, but it doesn’t <strong class="markup--strong markup--li-strong">initialize to the value of </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">undefined</strong></code><strong class="markup--strong markup--li-strong"> like </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">var</strong></code><strong class="markup--strong markup--li-strong"> does, </strong>so it throws a specific reference error if you try to access the value before it has been declared</li><li name="d64f" id="d64f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">if you do not use </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">var</strong></code><strong class="markup--strong markup--li-strong"> or </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">let</strong></code><strong class="markup--strong markup--li-strong"> or </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">const</strong></code><strong class="markup--strong markup--li-strong"> when initializing, it will be declared as global—THIS IS BAD </strong><em class="markup--em markup--li-em">(pretend that’s something you didn’t even know you could do)</em></li><li name="a6c4" id="a6c4" class="graf graf--li graf-after--li">if you assign a value without a declaration<em class="markup--em markup--li-em">(la la la la….I’m not listening)</em>, it exists in the global scope (so then it would be accessible by all outer scopes, so bad). however, there’s no hoisting, so it doesn’t exist in the scope until after the line is run.</li></ul><h3 name="b74a" id="b74a" class="graf graf--h3 graf-after--li">Predict the evaluation of code that utilizes function scope, block scope, lexical scope, and scope chaining</h3><figure name="44c4" id="44c4" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*P22Rwsk7Uzn5vJNS.png" data-width="880" data-height="500" src="https://cdn-images-1.medium.com/max/800/0*P22Rwsk7Uzn5vJNS.png"></figure><ul class="postList"><li name="904e" id="904e" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">scope of a program means the set of variables that are available for use within the program</strong></li><li name="2aa4" id="2aa4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">global scope is represented by the </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">window</strong></code><strong class="markup--strong markup--li-strong"> object in the browser and the </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">global</strong></code><strong class="markup--strong markup--li-strong"> object in Node.js</strong></li><li name="e255" id="e255" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">global variables are available everywhere, and so increase the risk of name collisions</em></li></ul><h4 name="2ea8" id="2ea8" class="graf graf--h4 graf-after--li">local scope is the set of variables available for use within the function</h4><ul class="postList"><li name="bb8a" id="bb8a" class="graf graf--li graf-after--h4">when we enter a function, we enter a new scope</li><li name="6bc8" id="6bc8" class="graf graf--li graf-after--li">includes functions arguments, local variables declared inside function, and any variables that were already declared when the function is defined (hmm about that last one)</li><li name="b80e" id="b80e" class="graf graf--li graf-after--li">for blocks (denoted by curly braces <code class="markup--code markup--li-code">{}</code>, as in conditionals or <code class="markup--code markup--li-code">for</code> loops), variables can be block scoped</li><li name="5ae1" id="5ae1" class="graf graf--li graf-after--li">inner scope does not have access to variables in the outer scope</li><li name="068c" id="068c" class="graf graf--li graf-after--li">scope chaining — if a given variable is not found in immediate scope, javascript will search all accessible outer scopes until variable is found</li><li name="c44e" id="c44e" class="graf graf--li graf-after--li">so an inner scope can access outer scope variables</li><li name="37e1" id="37e1" class="graf graf--li graf-after--li">but an outer scope can never access inner scope variables</li></ul><h3 name="a333" id="a333" class="graf graf--h3 graf-after--li">Define an arrow function</h3><figure name="7db3" id="7db3" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/6350a4dce719062909dc017a865f0556.js"></script></figure><h3 name="bfce" id="bfce" class="graf graf--h3 graf-after--figure">Given an arrow function, deduce the value of <code class="markup--code markup--h3-code">this</code> without executing the code</h3><ul class="postList"><li name="98d6" id="98d6" class="graf graf--li graf-after--h3">arrow functions are automatically bound to the context they were declared in.</li><li name="c91b" id="c91b" class="graf graf--li graf-after--li">unlike regular function which use the context they are invoked in (unless they have been bound using <code class="markup--code markup--li-code">Function#bind</code>).</li><li name="66a9" id="66a9" class="graf graf--li graf-after--li">if you implement an arrow function as a method in an object the context it will be bound to is NOT the object itself, but the global context.</li><li name="b6e8" id="b6e8" class="graf graf--li graf-after--li">so you can’t use an arrow function to define a method directly</li></ul><figure name="590b" id="590b" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/bff34bed5f35c3f20d7011e4b07fa35b.js"></script></figure><h3 name="f33d" id="f33d" class="graf graf--h3 graf-after--figure">Implement a closure and explain how the closure effects scope</h3><h4 name="b299" id="b299" class="graf graf--h4 graf-after--h3">a closure is “the combination of a function and the lexical environment within which that function was declared”</h4><ul class="postList"><li name="bb50" id="bb50" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">alternatively, “when an inner function uses or changes variables in an outer function”</strong></li><li name="87c8" id="87c8" class="graf graf--li graf-after--li">closures have access to any variables within their own scope + scope of outer functions + global scope</li><li name="a9e4" id="a9e4" class="graf graf--li graf-after--li">the set of all these available variables is “lexical environemnt”</li><li name="8562" id="8562" class="graf graf--li graf-after--li">closure keeps reference to all variables ** even if the outer function has returned</li><li name="0a13" id="0a13" class="graf graf--li graf-after--li">Without a closure to access the variables of an outer function from within a call to an inner function the outer function ‘closed’ over …each function has a private mutable state that cannot be accessed externally</li><li name="2d6a" id="2d6a" class="graf graf--li graf-after--li">The inner function will maintain a reference to the scope in which it was declared.so it has access to variables that were initialized in any outer scope- even if that scope</li><li name="d0d9" id="d0d9" class="graf graf--li graf-after--li">The inner function will maintain a reference to the scope in which it was declared.so it has access to variables that were initialized in any outer scope- even if that scope</li></ul><h3 name="7946" id="7946" class="graf graf--h3 graf-after--li">Q:</h3><h4 name="ec8e" id="ec8e" class="graf graf--h4 graf-after--h3">if a variable exists in the scope of what could have been accessed by a function(e.g.global scope, outer function, etc), does that variable wind up in the closure even if it never got accessed ?</h4><h3 name="861d" id="861d" class="graf graf--h3 graf-after--h4">A:</h3><h4 name="7e5c" id="7e5c" class="graf graf--h4 graf-after--h3">if you change the value of a variable(e.g.i++) you will change the value of that variable in the scope that it was declared in</h4><figure name="bba5" id="bba5" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/f64381f5e31e2e4a482341e85f7d6feb.js"></script></figure><h3 name="ce95" id="ce95" class="graf graf--h3 graf-after--figure">Define a method that references <code class="markup--code markup--h3-code">this</code> on an object literal</h3><ul class="postList"><li name="e43c" id="e43c" class="graf graf--li graf-after--h3">when we use <code class="markup--code markup--li-code">this</code> in a method it refers to the object that the method is invoked on</li><li name="568d" id="568d" class="graf graf--li graf-after--li">it will let you access other pieces of information from within that object, or even other methods</li><li name="3cc8" id="3cc8" class="graf graf--li graf-after--li">method style invocation — <code class="markup--code markup--li-code">object.method(args)</code> (e.g. built in examples like <code class="markup--code markup--li-code">Array#push</code>, or <code class="markup--code markup--li-code">String#toUpperCase</code>)</li><li name="e9b1" id="e9b1" class="graf graf--li graf-after--li">context is set every time we invoke a function</li><li name="5423" id="5423" class="graf graf--li graf-after--li">function style invocation sets the context to the global object no matter what</li><li name="31b8" id="31b8" class="graf graf--li graf-after--li">being inside an object does not make the context that object! you still have to use method-style invocation</li><li name="fa5a" id="fa5a" class="graf graf--li graf-after--li">Utilize the built in <code class="markup--code markup--li-code">Function#bind</code> on a callback to maintain the context of this</li><li name="5e6d" id="5e6d" class="graf graf--li graf-after--li">when we call bind on a function, we get an exotic function back — so the context will always be the same for that new function</li></ul><figure name="d0de" id="d0de" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/7118ebdab2e6d669a48290be2d4663b2.js"></script></figure><p name="e0b8" id="e0b8" class="graf graf--p graf-after--figure">can also work with arguments, so you can have a version of a function with particular arguments and a particular context.the first arg will be the context aka the `this` you want it to use.the next arguments will be the functions arguments that you are binding — if you just want to bind it to those arguments in particular, you can use `null` as the first argument, so the context won ‘t be bound, just the arguments — Given a code snippet, identify what `this` refers to</p><blockquote name="7bcf" id="7bcf" class="graf graf--pullquote graf-after--p">Important to recognize the difference between scope and context</blockquote><ul class="postList"><li name="a071" id="a071" class="graf graf--li graf-after--pullquote"><strong class="markup--strong markup--li-strong">scope works like a dictionary that has all the variables that are available within a given block, plus a pointer back the next outer scope(which itself has pointers to new scopes until you reach the global scope.so you can think about a whole given block ‘s scope as a kind of linked list of dictionaries) (also, this is not to say that scope is actually implemented in this way, that is just the schema that i can use to understand it)</strong></li></ul><figure name="ca18" id="ca18" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*ATcQhZwwSH5EPFWk.gif" data-width="1000" data-height="420" src="https://cdn-images-1.medium.com/max/800/0*ATcQhZwwSH5EPFWk.gif"></figure><ul class="postList"><li name="f933" id="f933" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">context refers to the value of the `this` keyword</strong></li><li name="03e2" id="03e2" class="graf graf--li graf-after--li">the keyword `this` exists in every function and it evaluates to the object that is currently invoking that function</li><li name="7933" id="7933" class="graf graf--li graf-after--li">so the context is fairly straightforward when we talk about methods being called on specific objects</li><li name="f7bb" id="f7bb" class="graf graf--li graf-after--li">you could, however, call an object ‘s method on something other than that object, and then this would refer to the context where/how it was called, e.g.</li></ul><figure name="4eba" id="4eba" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/3bb280a844fae2ce301714207fde6c15.js"></script></figure><h3 name="acd8" id="acd8" class="graf graf--h3 graf-after--figure">CALLING SOMETHING IN THE WRONG CONTEXT CAN MESS YOU UP!</h3><ul class="postList"><li name="1757" id="1757" class="graf graf--li graf-after--h3">could throw an error if it expects this to have some other method or whatever that doesn’t exist</li><li name="11b1" id="11b1" class="graf graf--li graf-after--li">you could also overwrite values or assign values to exist in a space where they should not exist</li><li name="e2bc" id="e2bc" class="graf graf--li graf-after--li">if you call a function as a callback, it will set <code class="markup--code markup--li-code">this</code> to be the outer function itself, even if the function you were calling is a method that was called on a particular object</li></ul><figure name="241a" id="241a" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/bgoonz/cdbd4d9a6a51a246d6d1af65162984b3.js"></script></figure><p name="4f11" id="4f11" class="graf graf--p graf-after--figure">we can use strict mode with <code class="markup--code markup--p-code">&quot;use strict&quot;;</code> this will prevent you from accessing the global object with <code class="markup--code markup--p-code">this</code> in functions, so if you try to call <code class="markup--code markup--p-code">this</code> in the global context and change a value, you will get a type error, and the things you try to access will be undefined</p><figure name="1f40" id="1f40" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/50e1d71c50e20355aaa5750cd14a6b12.js"></script></figure><ul class="postList"><li name="2d21" id="2d21" class="graf graf--li graf-after--figure">CALLING SOMETHING IN THE WRONG CONTEXT CAN MESS YOU UP!</li><li name="e8e4" id="e8e4" class="graf graf--li graf-after--li">could throw an error if it expects this to have some other method or whatever that doesn’t exist</li><li name="b227" id="b227" class="graf graf--li graf-after--li">you could also overwrite values or assign values to exist in a space where they should not exist</li><li name="a0a0" id="a0a0" class="graf graf--li graf-after--li">if you call a function as a callback, it will set <code class="markup--code markup--li-code">this</code> to be the outer function itself, even if the function you were calling is a method that was called on a particular object</li></ul><blockquote name="216c" id="216c" class="graf graf--blockquote graf-after--li"><em class="markup--em markup--blockquote-em">we can use strict mode with </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">&quot;use strict&quot;;</em></code><em class="markup--em markup--blockquote-em"> this will prevent you from accessing the global object with </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">this</em></code><em class="markup--em markup--blockquote-em"> in functions, so if you try to call </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">this</em></code><em class="markup--em markup--blockquote-em"> in the global context and change a value, you will get a type error, and the things you try to access will be undefined</em></blockquote><h3 name="c296" id="c296" class="graf graf--h3 graf-after--blockquote">POJOs</h3><h3 name="1e10" id="1e10" class="graf graf--h3 graf-after--h3">POJOs</h3><h4 name="df61" id="df61" class="graf graf--h4 graf-after--h3">1. Label variables as either Primitive vs. Reference</h4><p name="d838" id="d838" class="graf graf--p graf-after--h4">Javascript considers most data types to be ‘primitive’, these data types are immutable, and are passed by value. The more complex data types: Array and Object are mutable, are considered ‘reference’ data types, and are passed by reference.</p><ul class="postList"><li name="05bb" id="05bb" class="graf graf--li graf-after--p">Boolean — Primitive</li><li name="a5ab" id="a5ab" class="graf graf--li graf-after--li">Null — Primitive</li><li name="8aa7" id="8aa7" class="graf graf--li graf-after--li">Undefined — Primitive</li><li name="5c6b" id="5c6b" class="graf graf--li graf-after--li">Number — Primitive</li><li name="2e68" id="2e68" class="graf graf--li graf-after--li">String — Primitive</li><li name="e2a1" id="e2a1" class="graf graf--li graf-after--li">Array — Reference</li><li name="1fe0" id="1fe0" class="graf graf--li graf-after--li">Object — Reference</li><li name="545b" id="545b" class="graf graf--li graf-after--li">Function — Reference</li></ul><h4 name="3654" id="3654" class="graf graf--h4 graf-after--li">2. Identify when to use . vs [] when accessing values of an object</h4><figure name="f218" id="f218" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/ffe470d96623e9eb5818c48414bebeb5.js"></script></figure><h4 name="e6f4" id="e6f4" class="graf graf--h4 graf-after--figure">3. Write an object literal with a variable key using interpolation</h4><figure name="6402" id="6402" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/c510e7915126f558b3e7a6ffe393c1d0.js"></script></figure><h4 name="1685" id="1685" class="graf graf--h4 graf-after--figure">4. Use the obj[key] !== undefined pattern to check if a given variable that contains a key exists in an object</h4><figure name="391e" id="391e" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/393c60205d4de322efcc4cefc32c9934.js"></script></figure><h4 name="0908" id="0908" class="graf graf--h4 graf-after--figure">5. Utilize Object.keys and Object.values in a function</h4><figure name="2549" id="2549" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/9dc903cc1aecc6659a688cb7852e8293.js"></script></figure><h4 name="f9aa" id="f9aa" class="graf graf--h4 graf-after--figure">6. Iterate through an object using a for in loop</h4><figure name="57a7" id="57a7" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/dbe4e44df4757b174663c8515eb60f7d.js"></script></figure><h4 name="94a5" id="94a5" class="graf graf--h4 graf-after--figure">7. Define a function that utilizes …rest syntax to accept an arbitrary number of arguments</h4><figure name="62c9" id="62c9" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/6557be86c7d3fb9d288c826be0b8e764.js"></script></figure><h4 name="36fd" id="36fd" class="graf graf--h4 graf-after--figure">8. Use …spread syntax for Object literals and Array literals</h4><figure name="74ef" id="74ef" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/8855919398ff3bb22a9fde87e17e1125.js"></script></figure><h4 name="a834" id="a834" class="graf graf--h4 graf-after--figure">9. Destructure an array to reference specific elements</h4><figure name="1f76" id="1f76" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/42b1f634ab61f5d393cadc7cb7c7f202.js"></script></figure><h4 name="6fce" id="6fce" class="graf graf--h4 graf-after--figure">10. Destructure an object to reference specific values</h4><figure name="bb47" id="bb47" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/cd967cfd968044952e7084451ef71dca.js"></script></figure><h4 name="709d" id="709d" class="graf graf--h4 graf-after--figure">11. Write a function that accepts a string as an argument and returns an object representing the count of each character in the array</h4><figure name="53c0" id="53c0" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/c0fe778bab432310e9e9f8ee86427cbd.js"></script></figure><h3 name="16aa" id="16aa" class="graf graf--h3 graf-after--figure">Review of Concepts</h3><figure name="c121" id="c121" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/e14c20bf8dd88d28e47efb72f8e65780.js"></script></figure><h4 name="8c0b" id="8c0b" class="graf graf--h4 graf-after--figure">1. Identify the difference between const, let, and var declarations</h4><h4 name="32f7" id="32f7" class="graf graf--h4 graf-after--h4">2. Explain the difference between const, let, and var declarations</h4><pre name="5d41" id="5d41" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">var a = &quot;a&quot;;</code></pre><ul class="postList"><li name="cb01" id="cb01" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">var</code> is the historical keyword used for variable declaration.</li><li name="f2d5" id="f2d5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">var</code> declares variables in function scope, or global scope if not inside a function.</li><li name="8c4a" id="8c4a" class="graf graf--li graf-after--li">We consider <code class="markup--code markup--li-code">var</code> to be deprecated and it is never used in this course.</li></ul><pre name="a2a4" id="a2a4" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">let b = &quot;b&quot;;</code></pre><ul class="postList"><li name="9912" id="9912" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">let</code> is the keyword we use most often for variable declaration.</li><li name="f9dd" id="f9dd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">let</code> declares variables in block scope.</li><li name="75e1" id="75e1" class="graf graf--li graf-after--li">variables declared with <code class="markup--code markup--li-code">let</code> are re-assignable.</li></ul><pre name="b0e4" id="b0e4" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">const c = &quot;c&quot;;</code></pre><ul class="postList"><li name="5f80" id="5f80" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">const</code> is a specialized form of <code class="markup--code markup--li-code">let</code> that can only be used to initialize a variable.</li><li name="7bc0" id="7bc0" class="graf graf--li graf-after--li">Except when it is declared, you cannot assign to a <code class="markup--code markup--li-code">const</code> variable.</li><li name="5df7" id="5df7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">const</code> scopes variables the same way that <code class="markup--code markup--li-code">let</code> does.</li></ul><h4 name="1731" id="1731" class="graf graf--h4 graf-after--li">3. Predict the evaluation of code that utilizes function scope, block scope, lexical scope, and scope chaining</h4><p name="ddab" id="ddab" class="graf graf--p graf-after--h4">Consider this <code class="markup--code markup--p-code">run</code> function, inside which <code class="markup--code markup--p-code">foo</code> and <code class="markup--code markup--p-code">bar</code> have <code class="markup--code markup--p-code">function scope</code> . <code class="markup--code markup--p-code">i</code> and <code class="markup--code markup--p-code">baz</code> are scoped to the block expression.</p><figure name="ac06" id="ac06" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/9be2a7998a254bb98108bc8d8199bf13.js"></script></figure><p name="b162" id="b162" class="graf graf--p graf-after--figure">Notice that referencing <code class="markup--code markup--p-code">baz</code> from outside it&#39;s block results in JavaScript throwing a ReferenceError.</p><p name="50a7" id="50a7" class="graf graf--p graf-after--p">Consider this <code class="markup--code markup--p-code">run</code> function, inside of which <code class="markup--code markup--p-code">foo</code> has <code class="markup--code markup--p-code">function scope</code> .</p><figure name="4f26" id="4f26" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/bgoonz/bf60c156719328d7760fcd34c92291f8.js"></script></figure><h4 name="b4d0" id="b4d0" class="graf graf--h4 graf-after--figure">6. Implement a closure and explain how the closure effects scope</h4><figure name="825d" id="825d" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/730d55a9b03bbabaa970b9b0616c75a4.js"></script></figure><h4 name="8710" id="8710" class="graf graf--h4 graf-after--figure">4. Define an arrow function</h4><pre name="3438" id="3438" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code">const returnValue = (val) =&gt; val;</code></pre><p name="b665" id="b665" class="graf graf--p graf-after--pre">This simple construct will create a function that accepts <code class="markup--code markup--p-code">val</code> as a parameter, and returns <code class="markup--code markup--p-code">val</code> immediately. We do not need to type <code class="markup--code markup--p-code">return val</code> , because this is a single-line function.</p><p name="00a9" id="00a9" class="graf graf--p graf-after--p">Identically, we could write</p><pre name="78d5" id="78d5" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const returnValue = (val) =&gt; {<br>    return val;<br>};</code></pre><h4 name="0be6" id="0be6" class="graf graf--h4 graf-after--pre">5. Given an arrow function, deduce the value of <code class="markup--code markup--h4-code">this</code> without executing the code</h4><figure name="e9e1" id="e9e1" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/6cc19594cbaee618f693766bd474e734.js"></script></figure><p name="5096" id="5096" class="graf graf--p graf-after--figure">If we use a function declaration style function, the <code class="markup--code markup--p-code">this</code> variable is set to the <code class="markup--code markup--p-code">global</code> object (i.e. <code class="markup--code markup--p-code">Object [global]</code> in Node. JS and <code class="markup--code markup--p-code">Window</code> in your browser).</p><pre name="574c" id="574c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const adder = (arr) =&gt; {<br>    console.log(this);<br>    arr.reduce((acc, ele) =&gt; sum += ele);<br>};<br>adder([1, 2, 4, 6]);</code></pre><p name="5842" id="5842" class="graf graf--p graf-after--pre">In this example, we use a fat arrow style function. Note that when we declare a functions like this <code class="markup--code markup--p-code">this</code> becomes</p><h4 name="b56f" id="b56f" class="graf graf--h4 graf-after--p">7. Define a method that references this on an object literal</h4><figure name="bedc" id="bedc" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/297378677e320cd335cbe482b4a59ceb.js"></script></figure><h4 name="ba8f" id="ba8f" class="graf graf--h4 graf-after--figure">8. Utilize the built in Function#bind on a callback to maintain the context of <code class="markup--code markup--h4-code">this</code></h4><figure name="9b78" id="9b78" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/7935901db3508cbf4b1925033d3d0be5.js"></script></figure><h4 name="d8fe" id="d8fe" class="graf graf--h4 graf-after--figure">9. Given a code snippet, identify what <code class="markup--code markup--h4-code">this</code> refers to</h4><figure name="35a8" id="35a8" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/bgoonz/ab0e6a9b0794a33008caa8d481312879.js"></script></figure><div name="8af6" id="8af6" class="graf graf--mixtapeEmbed graf-after--figure"><a href="https://bgoonz-blog.netlify.app/" data-href="https://bgoonz-blog.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://bgoonz-blog.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">Web-Dev-Hub</strong><br><em class="markup--em markup--mixtapeEmbed-em">Memoization, Tabulation, and Sorting Algorithms by Example Why is looking at runtime not a reliable method of…</em>bgoonz-blog.netlify.app</a><a href="https://bgoonz-blog.netlify.app/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a2f1abe4ed6a87b0b90d28e55f930d20" data-thumbnail-img-id="0*zMSVaDnL6GB5Rshj" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*zMSVaDnL6GB5Rshj);"></a></div></div><div class="section-inner sectionLayout--fullWidth"><figure name="83d9" id="83d9" class="graf graf--figure graf--iframe graf--layoutFillWidth graf-after--mixtapeEmbed"><iframe src="https://replit.com/@bgoonz/funcamentalJS?lite=true&amp;amp%3Breferrer=https%3A%2F%2Fbryanguner.medium.com&amp;lite=true" width="null" height="null" frameborder="0" scrolling="no"></iframe></figure></div><div class="section-inner sectionLayout--insetColumn"><figure name="9f4d" id="9f4d" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="0*Ff29X3kTbA17Qgoz.jpg" data-width="575" data-height="651" src="https://cdn-images-1.medium.com/max/800/0*Ff29X3kTbA17Qgoz.jpg"></figure><figure name="2c99" id="2c99" class="graf graf--figure graf--iframe graf-after--figure"><script src="https://gist.github.com/bgoonz/fd2412bc8a146733dfed4e7425a925a0.js"></script></figure><figure name="64bd" id="64bd" class="graf graf--figure graf--iframe graf-after--figure graf--trailing"><script src="https://gist.github.com/bgoonz/f2848ccb37d417f3c10cfc267e9d6930.js"></script></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/8e093a665b04"><time class="dt-published" datetime="2021-08-11T03:29:25.811Z">August 11, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/fundamental-concepts-in-javascript-8e093a665b04" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 12, 2021.</p></footer></article></body></html>