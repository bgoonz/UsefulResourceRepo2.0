<!DOCTYPE html>
<html>
<head>
<title>00000OUTLINE-w08_getting-to-know-the-network.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<hr>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=2 orderedList=false} -->
<hr>
<hr>
<h1 id="week-08-brlearning-objectives-ignoretrue">WEEK-08 <br><em>Learning Objectives</em> {ignore=true}</h1>
<hr>
<h1 id="binary-trees-and-binary-search-trees">Binary Trees and Binary Search Trees</h1>
<p><strong>The objective of this lesson</strong> is for you to become comfortable with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</p>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Binary Tree.</li>
<li>Identify the three types of tree traversals: pre-order, in-order, and<br>
post-order.</li>
<li>Explain and implement a Binary Search Tree.you to become comfortable with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</li>
</ol>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Binary Tree.</li>
<li>Identify the three types of tree traversals: pre-order, in-order, and<br>
post-order.</li>
<li>Explain and implement a Binary Search Tree.</li>
</ol>
<hr>
<h1 id="graphs-and-heaps">Graphs and Heaps</h1>
<p><strong>The objective of this lesson</strong> is for you to become comfortable with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</p>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Heap.</li>
<li>Explain and implement a Graph.table with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</li>
</ol>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Heap.</li>
<li>Explain and implement a Graph.</li>
</ol>
<hr>
<h1 id="network-models-objectives">Network Models Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to get a basic understanding of<br>
network models. This lesson is relevant because any network-connected software<br>
that you write will implementations of these models to communicate with other<br>
computers. Questions about network models are popular interviewing topics, too.</p>
<p>When you finish, you should be able to</p>
<ol>
<li>Describe the structure and function of network models from the perspective of<br>
a developer.a basic understanding of<br>
network models. This lesson is relevant because any network-connected software<br>
that you write will implementations of these models to communicate with other<br>
computers. Questions about network models are popular interviewing topics, too.</li>
</ol>
<p>When you finish, you should be able to</p>
<ol>
<li>Describe the structure and function of network models from the perspective of<br>
a developer.</li>
</ol>
<hr>
<h1 id="internet-protocol-suite-objectives">Internet Protocol Suite Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to understand the different parts of<br>
the Internet Protocols. This lesson is relevant because knowledge of internet<br>
protocols is expected for all Software Engineers that write code that connects<br>
to a network. Moreover, internet protocols are popular interviewing topics.</p>
<p>When you complete this content, you should be able to do the following.</p>
<ol>
<li>Identify the correct fields of an IPv6 header.</li>
<li>Distinguish an IPv4 packet from an IPv6.</li>
<li>Describe the following subjects and how they relate to one another: IP<br>
Addresses, Domain Names, and DNS.</li>
<li>Identify use cases for the TCP and UDP protocols.</li>
<li>Describe the following subjects and how they relate to one another: MAC<br>
Address, IP Address, and a port.</li>
<li>Identify the fields of a TCP segment.</li>
<li>Describe how a TCP connection is negotiated.</li>
<li>Explaining the difference between network devices like a router and a switch.u to understand the different parts of<br>
the Internet Protocols. This lesson is relevant because knowledge of internet<br>
protocols is expected for all Software Engineers that write code that connects<br>
to a network. Moreover, internet protocols are popular interviewing topics.</li>
</ol>
<p>When you complete this content, you should be able to do the following.</p>
<ol>
<li>Identify the correct fields of an IPv6 header.</li>
<li>Distinguish an IPv4 packet from an IPv6.</li>
<li>Describe the following subjects and how they relate to one another: IP<br>
Addresses, Domain Names, and DNS.</li>
<li>Identify use cases for the TCP and UDP protocols.</li>
<li>Describe the following subjects and how they relate to one another: MAC<br>
Address, IP Address, and a port.</li>
<li>Identify the fields of a TCP segment.</li>
<li>Describe how a TCP connection is negotiated.</li>
<li>Explaining the difference between network devices like a router and a switch.</li>
</ol>
<hr>
<h1 id="network-tools">Network Tools</h1>
<p><strong>The objective of this lesson</strong> is for you to have a basic understanding of<br>
commonly-used network analysis utilities. This lesson is relevant because<br>
interacting with networks via different tools is essential for every software<br>
developer on the web. When you are done, you should be able to use <code>traceroute</code><br>
to show routes between your computer and other computers. You should also be<br>
able to use <code>Wireshark</code> to show inspect network traffic.erstanding of<br>
commonly-used network analysis utilities. This lesson is relevant because<br>
interacting with networks via different tools is essential for every software<br>
developer on the web. When you are done, you should be able to use <code>traceroute</code><br>
to show routes between your computer and other computers. You should also be<br>
able to use <code>Wireshark</code> to show inspect network traffic.</p>
<hr>
<h1 id="week-08-day-1brwhite-boarding-tips-and-tricks-ignoretrue">WEEK-08 DAY-1<br><em>White-Boarding Tips and Tricks</em> {ignore=true}</h1>
<hr>
<h1 id="white-boarding-tips">White-Boarding Tips</h1>
<h2 id="why-do-companies-whiteboard">Why do companies whiteboard?</h2>
<p>Steps to solving white-boarding questions are identical to the steps necessary to<br>
solve real-world practical problems.</p>
<p>Companies want to see how you perform as a team member in a real team.</p>
<p>Things the interviewer will be looking for:</p>
<ul>
<li>Can you think algorithmically? Can you think about efficiency?</li>
<li>Are you a good communicator? Are you someone I want to think through a new<br>
feature with?</li>
<li>Can you code? Can you code neatly and correctly?</li>
</ul>
<h2 id="correct-steps">Correct steps</h2>
<ol>
<li>Clarify the problem &amp; test I/O and edge cases</li>
<li>Formulate your approach(es)</li>
<li>Pseudocode best approach</li>
<li>Code it</li>
<li>Walk through an example input</li>
<li>Determine the Big O time and space complexity</li>
</ol>
<h2 id="clarification">Clarification</h2>
<p>Before you jump into coding, ask questions. Don't rush, it's a problem-solving<br>
demo, not a speed-coding test.</p>
<ul>
<li>What are we coding?</li>
<li>Are there any constraints on the input/output?</li>
<li>What edge cases can we expect?</li>
</ul>
<h2 id="test-io">Test I/O</h2>
<p>You should start with simple inputs and then slowly build up size or complexity<br>
of inputs. Look for patterns and things that remind you of problems you know how<br>
to solve.</p>
<p>If you draw a blank, use the following strategies to get started.</p>
<ul>
<li>Make up a sample input and compute it. Do this two or three times.</li>
<li>Go through data structures in your head. Go through algorithms you know<br>
simultaneously. If you find one that works for this problem, run with it.</li>
<li>If not, find a naive solution, any solution, to get started. Then you can<br>
optimize.</li>
<li>Come up with a simpler version of the problem, solve it, then progressively<br>
add complexity.</li>
<li>Think aloud about the likely bounds on efficiency for your solution.
<ul>
<li>This is an easy way to score points.</li>
<li>&quot;What's sure is I'll have to iterate through all the points, so it's at<br>
least linear time.&quot;</li>
<li>&quot;The problem is trivial when the set is sorted. So it can definitely be done<br>
in nLOGn time. Let's see if we can do better than n Log n.&quot;</li>
</ul>
</li>
</ul>
<h2 id="pseudocode">Pseudocode</h2>
<p>Never skip this step! Companies expect you to be able to pseudocode because it<br>
is the English version of your approach to the problem. You need to lay out your<br>
strategy step by step, so that when you code, you have something to refer back<br>
to. It's easy to be lost in the intricacies of implementation, so you as well as<br>
the interviewer need pseudocode to refer back to when you lose track of your<br>
thoughts.</p>
<ul>
<li>Be as detailed as possible</li>
<li>Spend as much time as you want, within reason</li>
<li>Make sure you can reason about implementation of every step</li>
</ul>
<h2 id="during-the-problem">During the Problem</h2>
<p>At this point, you should have spent at least 60% of your time. If you sprinted<br>
to coding, you most likely didn't spend enough time planning and will struggle<br>
here. If planned properly, this section should be the easiest part.</p>
<ul>
<li>The nice thing about white boards is you and the interviewer are facing the<br>
same direction.</li>
<li>Convince yourself that you are solving the problem together. Say &quot;we&quot; instead<br>
of &quot;I&quot;.</li>
<li>Don't stop until they tell you to.</li>
</ul>
<p>Your style definitely makes an impact. Here are tips to how to handle your<br>
bearing.</p>
<ul>
<li>Be confident; even if you don't know the answer, try to engage the problem,<br>
don't give up. If you keep telling an interviewer you don't know how to do<br>
something, they'll start to believe you.</li>
<li>Talk through the problem; they want to see the process going on in your head.<br>
If you don't talk, the interviewer doesn't learn how you break-down and<br>
analyze a problem. If you can write and talk at the same time, great! If not,<br>
tell the interviewer what you're about to write, write it, and explain what<br>
you wrote.</li>
<li>The interviewer may give you hints. They will ask questions to keep you on<br>
track. Don't be flustered or think you're failing; this is normal.</li>
<li>If they ask you &quot;does this work&quot;, take a moment to think. Walk through the<br>
steps; out loud is fine. If you say yes, say it like you believe it;<br>
interviewers don't like to think people are just praying they'll get the<br>
answer right.</li>
<li>Listen to the interviewer. They are trying to help you. No one likes someone<br>
who doesn't listen.</li>
</ul>
<h2 id="walk-through-an-example-input">Walk through an example input</h2>
<ul>
<li>Initiate this step - don't wait to be prompted.</li>
<li>Track all of your variables.</li>
<li>Draw stacks if you're using a recursive method.</li>
<li>Follow each iteration of your loops.</li>
<li>Reason through your code from input to output.</li>
</ul>
<h2 id="time-and-space-complexity">Time and space complexity</h2>
<ul>
<li>You should know how to do this - refer back to Big O reading if you need to.</li>
<li>Remember time is expensive and space is cheap.</li>
<li>If your approach is naive, attempt to optimize.</li>
<li>If not, ask your interviewer if they'd like you to optimize.</li>
</ul>
<h2 id="strategies">Strategies</h2>
<p>Keep a mental list of general strategies you can turn to. Here are a few:</p>
<ol>
<li>Bucketizing with a hash: If the input set is bounded, try organizing it into<br>
a hash.
<ul>
<li>Ex: Sort an array of 100,000 integers that are all in the range 1-100</li>
</ul>
</li>
<li>Dynamic programming, or &quot;divide and conquer&quot;: Divide into smaller and smaller<br>
but equal subproblems.
<ul>
<li>Ex: See <a href="http://www.careercup.com/question?id=19286747">this solution</a> for<br>
a Google interview question.</li>
</ul>
</li>
<li>Look for useful mathematical properties.
<ul>
<li>Sometimes you have individual values when really what you care about is<br>
their sums.</li>
<li>Ex: For an array of integers 1 - 100 where all elements appear once except<br>
one that appears twice, find the repeat.</li>
</ul>
</li>
<li><a href="http://en.wikipedia.org/wiki/Amortized_analysis">Amortized analysis</a>: it's<br>
ok to do something memory- or space-intensive if you can prove that this cost<br>
comes with a greater payoff.
<ul>
<li>Ex: Implement a queue using two stacks.</li>
</ul>
</li>
<li>Keep a stack or a queue on the side to track values as your algorithm goes<br>
through the problem.</li>
<li>Keep two pointers for the same iteration.
<ul>
<li>Ex: Reverse a string in place (ie. using no more memory space than the<br>
length of the string).</li>
</ul>
</li>
<li>Perform an operation twice.
<ul>
<li>Ex: Reverse the word order of a string, but not the letters within the<br>
words.</li>
</ul>
</li>
<li>Sort the input.
<ul>
<li>Ex: Finding anagrams.</li>
</ul>
</li>
<li>Approach the problem from the other end.
<ul>
<li>Ex: see <a href="http://www.techinterview.org/post/526325766/pirates">this<br>
solution</a> for a Fog<br>
Creek interview question.</li>
</ul>
</li>
<li>Use binary numbers instead of decimal numbers.
<ul>
<li>Ex: see the <a href="http://www.techinterview.org/post/526313890/bad-king">famous Bad<br>
King</a> problem.</li>
</ul>
</li>
<li>For efficiency, use binary search instead of incrementation. Esp. good for<br>
implementing math operators.
<ul>
<li>Ex: Implement division without using &quot;/&quot;, in less than O(n) time.</li>
</ul>
</li>
</ol>
<h2 id="dont-be-sly">Don't be Sly</h2>
<p>If you don't understand the problem, ask for clarification. A well-formulated<br>
question is as impressive as a good answer. If you don't know something, don't<br>
make it up. Tell the interviewer you don't know and then try your best guess.<br>
Many interviewers will really like this. Same thing when you hit a snag. Don't<br>
try to cover things up and make it look like you were on the right track.<br>
Explain to the interviewer why you think the current hypothesis actually won't<br>
work.</p>
<h2 id="how-to-handle-questions-youve-seen-before">How to handle questions you've seen before.</h2>
<p>What if you get a whiteboard problem you already know the solution to? Obviously<br>
the ethical thing is to tell your interviewer you've seen the problem before and<br>
you'll get points for that. Put on a sad face to show you were excited about<br>
solving a new problem.</p>
<p>Furthermore, you won't necessarily perform better on a question you've seen.<br>
You'll probably solve it faster, but speed is overrated. On the other hand, it's<br>
much harder to show your interviewer how you think when you're really just<br>
recalling a solution. Note that the easiest parts of a problem are also the<br>
hardest to remember. So even if you confound your interviewer, they'll be left<br>
wondering why you breezed through the hardest part of the problem while<br>
stumbling on the rest. That's a failure to demonstrate how you think, which is<br>
the real purpose of a whiteboard problem.</p>
<hr>
<h1 id="white-boarding-exercises">White Boarding Exercises</h1>
<p>Work together to &quot;white board&quot; answers to the following problems. Your pair will<br>
present one of them at the end of the day.</p>
<p>You may not have real white boards on which to draw. If not, use the Zoom<br>
white board or just pen and paper. Talk through the answers. Determine if you<br>
are right.</p>
<p>When white boarding, you don't have to necessarily draw .. You can write<br>
code or pseudocode or draw circles and arrows. Just something to indicate that<br>
you understand the problem and what it would take to solve it.</p>
<h2 id="mirror-image-trees">Mirror image trees</h2>
<p>Google asks in its interview process for you to draw an algorithm on a board<br>
that would return true if a binary tree is a mirror image of another binary<br>
tree.</p>
<h2 id="reverse-a-linked-list">Reverse a linked list</h2>
<p>Amazon and Microsoft ask you to show an algorithm that will reverse a<br>
singly-linked list, that is, a list that is made of nodes between which there is<br>
a unidirectional association as in the following image.</p>
<p><img src="./Singly-linked-list.svg" alt="singly-linked list"></p>
<h2 id="the-missing-value">The missing value</h2>
<p>Amazon and Microsoft ask you to derive an algorithm that will inspect an<br>
array of of numbers that contains the values between 0 and the length<br>
of the list, inclusive, and find the missing value. For example, you may be<br>
given an array that of length 6 that contains</p>
<pre class="hljs"><code><div>[0, 2, 3, 4, 5, 6]
</div></code></pre>
<p>It is your job to determine that the missing value from the array is 1.</p>
<h2 id="stack-min">Stack min</h2>
<p>Google and Apple ask you to design a stack that, in addition to the <code>push</code> and<br>
<code>pop</code> functions, has a function <code>min</code> that returns the minimum element in the<br>
stack <em>without</em> removing it. All three functions <code>push</code>, <code>pop</code>, and <code>min</code> should<br>
operate in O(1) time.</p>
<h2 id="test-a-retractable-ballpoint-pen">Test a retractable ballpoint pen</h2>
<p>Facebook asks you to write the tests cases for testing a ballpoint pen. What<br>
would you consider to be good tests for the pen? Try to be as exhaustive as<br>
possible.</p>
<h2 id="ooparking-lot">OOParking Lot</h2>
<p>Amazon and Microsoft ask you to specify the classes that it would take to write<br>
software to manage a paid parking lot. It should know where cars are parked,<br>
be able to identify the cars, know where the keys are hanging, how many cars<br>
are in the lot, what time the cars come and go, and how much it costs someone<br>
when they leave the parking lot based on the following schedule:</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Rate per hour</th>
</tr>
</thead>
<tbody>
<tr>
<td>8pm - 6am</td>
<td>$3</td>
</tr>
<tr>
<td>6am - noon</td>
<td>$10</td>
</tr>
<tr>
<td>noon - 6pm</td>
<td>$8</td>
</tr>
<tr>
<td>6pm - 8pm</td>
<td>$6</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="week-08-day-2brbinary-trees-ignoretrue">WEEK-08 DAY-2<br><em>Binary Trees</em> {ignore=true}</h1>
<hr>
<h1 id="binary-trees-and-binary-search-trees">Binary Trees and Binary Search Trees</h1>
<p><strong>The objective of this lesson</strong> is for you to become comfortable with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</p>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Binary Tree.</li>
<li>Identify the three types of tree traversals: pre-order, in-order, and<br>
post-order.</li>
<li>Explain and implement a Binary Search Tree.you to become comfortable with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</li>
</ol>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Binary Tree.</li>
<li>Identify the three types of tree traversals: pre-order, in-order, and<br>
post-order.</li>
<li>Explain and implement a Binary Search Tree.</li>
</ol>
<hr>
<h1 id="binary-trees">Binary Trees</h1>
<p>Binary Trees are perhaps the most pervasive data structure in computer science.<br>
Let's take a moment to go over the basic characteristics of a Binary Tree before<br>
we explore algorithms that utilize this structure.</p>
<h3 id="what-is-a-graph">What is a Graph?</h3>
<p>Before we define what a <strong>Tree</strong> is, we must first understand the definition of<br>
a <strong>Graph</strong>. A graph is a collection of <strong>nodes</strong> and any <strong>edges</strong> between<br>
those nodes. You've likely seen depictions of graphs before, they usually exist<br>
as circles (nodes) and arrows (edges) between those circles. Below are few<br>
examples of graphs:<br>
<img src="graphs.png" alt=""><br>
<img src="./graphs.png" alt="graphs"></p>
<p>For now, you can ignore the blue coloring. Notice how the graphs above vary<br>
greatly in their structure. A graph is indeed a very broad, overarching<br>
category. In fact, <strong>linked lists and trees are both considered subclasses of<br>
graphs</strong>. We'll cover algorithms that operate on a general graph structure later,<br>
but for now we want to focus on what graphs are trees and what graphs are not.<br>
It's worth mentioning that a single node with no edges (image 1) is considered a<br>
graph. The empty graph (a graph with 0 nodes and 0 edges, not pictured <img class="emoji" alt="smiley" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAWaUlEQVR4Xu2bebAlV33fP79zum/fe9+99+3z3qyaGc0iCQ3LzEhIMpalICQKx0JYyEAkgTEJlAtX4qLKdhHsgBIndoWYONj8gR0gWAI5BoPAC7KQUyJG20gapAgxZvbhzfZm3r7crfuck+5TXdXFvEUjBymqsk/Vd86dmdPn/j7f/p2tXz9xzvGPuSj+UZd/MuCfDAh4mcs9Iuquu9gaOHaheI0I2wRGlZY+HFUAhKY1bsbBWec4jOWFRHj+vvs4+nHnLC9jeVkmQUnLsbu52gm3hpqbVShX6FBVVUmhSoIoAS0AhYzDWYftZrKY2DZt7H4QGx4Sxze33Ms+l5ZXtQHP3CrVwT5+QWl+qVRWP6UrSqmqRkUZuEOURbRLJSAXGOAczmQSnFXYrmA7Fts0mJa13bZ91Bo+PznDn+35pmu+quaAR26U4Ph75RdHhuXJakN/oWc0+ulofaSidQHRsKM0rCmNDlHe9nqiK28h2vNeytf8MpXr/o1X+tn/W/p/vk3aNrvGX+v7SPvK+sz6zr4j+67sO18VGXDwTrm6HPKfyjX95qA3IGhoJDKockDQtxE1+gbUyB6ktg0pD0BQBdEgAA4AEHCAM5A0ce0p3MJh7Pgz2LPfI5kZw7YTXEeTzBmS2YT2gvnbdsy/3fElt+//iwGSlqN38pFyVe4p9Yc9ui9M2SyqGhCM7EJfcjNq+GqoDORwCWAhNxwBHMt8FkCBBCBAawp7fh/mxEMk489jmwlJU2FmYrrT8WK76T6+9Ut8yqXllTDAgz99B43hCn9Yruu7wqESQa9GVwzBmh3obbej1lwDQRlcF5xBRPEPKc7ZPFtKkLSx557AHP5zknMHMS1NMmuIJ7q0581951v8yt6vMOeNeJkM8PD7b2XtwABfqvYGN4QjKXxdCGppfektqM23I1Ef2DYCSyc6uVhylk6QAKqM68xgj6cmHPkbkoUuybwjHu/SnE0emZrizt3f5MxLMSF4qfBDAzxQHgyvioYjdB2C/n6Cy9+DGvlpcDGSzILIamAvXQ4EIOmA1uhtdyL1TciB+xE1jVJlCDo3KOIH0hhvE5GLNiG4WPgHb6E/hb/fw49m8ELYP0jwmg8g/ZcjZhaQJWP7J1IKFMQBNFFrriYM68gLnwM9SaQjgKuGiO9PY32HiExfjAnBxcAD6rJRPl3uD66P1kTohkrh+wguvxvV2AzxNIgq4HnZDCgywrSQxmaCK+6GA18EmSGyEVh3/WUu+TTwPhGxL2ZCcDHwB+/iI5WGvjNcUyLo0wT1tN76s0htIyQzHh63DHBUgkBDqwPW8pKKUlCJIDHQ6S5vSNLOYvCxcPCrCF2sLVFJ3J0H7zLP7biPTxUmvKRJsIB/7A72bO6X/1VeX+4pDUcEDQg2vgm1/iYgARGE5eBDnt9/mB8eOs0/f+teyrWyh7moEmjaC23+8sGn2bl9Hbt2b4NOvMQEB+DZAuyph0nGvksyB93zHdqn2ovHp90/u+4rPAOsaEKwGvzdI5TX1/lkNBj2hP0hQU2h+0dRQ28Auwg4JKdHfhz+hf2H+K3f/AJTkx0OHjjEb3z03WgsWFYvCkyi+NR//VMe/NZzDAxG/Mfffj+vef3WHzfBgeA8P4iPSS8cBXsWl4S4tulZn3Q/mTK87d5x2kUmXNwQEEB97CbeVanp64MUXtdCVEWhBq8ErcA0EVl+qbOdDv/zyw/RCDpsujTk2Sef46lHL+ean7kCWl1WLaUST33neX/N69NrZxZ8X3zi8rtQ1oJbksJ4LB2gBnfhmufRiRD0GyqL5vqP3WTede+XuBdwwIsZUKT+R6+m0RPJr3v4eqqyoGpDSHUUzAIiDpwsTf1Qc/zQec786BSXDIdEocLE8MRjz3PNdZvBxeBWsT1OfNvhGqxpKHorYdZX2ucYW7cPQ2wAlmaCFaQ64mPU8XlsPfQm9CzYX//o1e4bv7OPWRFxWXmxDFCAfs82bo8aemfQCFCVVJFCautBHGKbK6/1UYnDh04S2A6NckQYCAP1gNNjZ2nNzFKpKjArOKAlbdPM2vprapEQacXEbMf3uXVnL5juSpMZTgIfo2pO+piz2KNGsvM925LbUwO+CDjALG9AcffljQNE9bJ8IGhoVE+ALiskipByL2JbgIUV+Iktp0+fpxIKoU6loFJSzC02GT83xebN9ZVXBK3SNvN0mk36epS/Fi1ZX75P4jbY7iqbpRiyGKMIHXewPf5wRn3OfOCNA+5Pn5zCSJ4GK2WAAPp3r2d3pSp7dS1AlTWqpJBSBVEBmBaIA1Y2YHZ6nigUtAIleCOcSZidmQNXAmNWmv2zNr5tqBVKvCdZX75Pb4BZZQ5xksXoY1Wl2MeeMVSq8d7fvd7tvvEBHgcssKIB3vORmro1rGn/MEOXNBIoCCIgWX0MA1hLu90m0IIIXkrhodutRaABNmb5Evo2GINSKr+erC/fJ7bIgJUlPlYJlI/dVDUZy0iNW8HuAwxgCwMumPy29hNWyu5G8U9yNBIqJBCUDsB2eNF1zBp/B5UIQu6qgADOxjlEsvK1Nkbya4D8s88gsK3CvBWlfKw2EB+7Z6hqKuXkxozt6DRJMQwguHDp+/getkZl2akrGilpVGaA1oDxBuBWMECKk1sUBTQdRXGgAkUYxBDPpUqKTCwwIQiyNr4tDii69H3iukUGrLiSKMD4mFXoPEPGkjF9fI/b+r6HOZCzLmuA3lhnVxCpin+OFwjoPA9dB2yTFTf8LpP17WoNmLQFg3UQhJpaeQoWZyC2yxAIWJW2sb6tdQWntfg+cfNgbA4JwNJYnPMxID52z5CxZEwb63YXcDCHYNkM6KuoK3QkSJhKK0SJFy6GZB5U+YL9qAEbg8tkQMOaYcth42PxSgyEkWKwX3mAFU9KxmZtfNvE2Px6iI3vE+Jx6AKiQUJQqUQXPJBnaZzHnTOEQsaUsYH9+koGqExR4C6VQOHhtYBSxZqfLIJ0QVQBnwlHEYBm44YII4KxDqWETtfSP1qmvxFAe5UxbPFt+odKtM42sRXt+zAivk8sxXfSBSMgujDBWQ8P5LOvZ/AsGVMUJJeScxYGUKz/gA6FNeSpL5LDowpG1y0ARJbeza5l2+YKPX0pRCdGRFhsO153RR0dAq1VjskO32ZH2vax44v01qDVcVlfvk+63R8fcuSGkFAUKSTWM6AFAsGzgfbI+USoLrgy1AF9ko97dDHii71DAY1jqRJHowa73zTAuemEyZmEoFHi2msb0IpBWLkIvk3a1l+TXuv7SPvyfZK45Xf0TnCuqFOuoonHFTKmjA0IV50DlFAWlYM7L8T/UZhQ0IKw1Bfm2tzylj4mZgxHfjDHO9+3gTU1C9MGRFi1xI41/Zbb/9UmvvrFk1x5XcP3xeQCCAV9URWflzkv56EjCjI2QC1nQLFkC3j/XOGA82OriD3vdeUnPwbKswt84P3DtNUo5fkWnFvM4d3qyyjAdJPdW3q44vd2ULYGTs2BsUUbdwG4W6aTIn7AMyEChQFeLrhgLVHG0saQQxucE8TpvFGRGYIDWQZHcnUNcmKSst8GO9AX95TM5QxMzFOeXsh/ZgioAhhZCu/jLDIij9PgZS0Y8GxFT27Zs0BimcsucCZJJeByM6RYZ5VyEAlY5+Vc4Ssur3EFTGHzcmVFZzy4AJqlk1++HRAtgGA7zpvgkMIVDx7nLJaMbbXnAQ6gkzDhHbOZewpnFYKlyBHH7ILlqccT1o0Il25WRI3cAAsY8KYASKF/0ENQDdjCH5RAkJsdw/wUHDhsiGPh6l0BWgvOFkY561KZnMV6NkCWHIZcWkTEAcx25cS62Pm09Q66BKzgFAiCKju+9rU2n/l8m9EBxaYNiu3bFVfsVGzZLN6UWg2kLKBzEilAsKtkgyyzsgqQCLbpmJ2BsVOOI0cdB/7ecPio5eRpy2IC/+3fV9n7uhDbLoYGzjPgEoeLnWcDR47slsuA5MScPbKzq7HGYa1FOZWP9yIdDbChoRiMHBM/Sjh+EP76r6DSA319MLpWs3ZU0hpG1giDg1BvCOVK8aA4LIHWgIM4gaSbykC7Da0mzM45Jifg7LhLBafPWMbPWubnoNuCioZGGTY1NBNNRywOlEGUgC224BmDZ+lCxgaYlY7DFkgePcPRN2+3bWJbdkbhhwOCKEAsAJdsgZ7IURvqY+ueG2m12kycPMTcxBTz8zOMP2fY9xQUx2EPTKUCpciDE+ZGOCCOIUllDLRb3gT/dzwAiEBUhkojYmB9L72jIwyt3YbqLDD+zCP0Bwlr1+Y703y9w4CzeSYnFtOx7YwNiAG7kgHxn7zAyY9cxZFyx73GJXkKofK1FB/RJZvBhQ4zuI4rf+6DlIIAl7RJ4i7NmTMsTE3SWphhdvwIi1Oz/izfac/TmZ9J6wUfVDu2JE0DCGGkUZFQ0pr6aINyT18K3EO5ElEfXkN9aAuVnlpajxLVBglKJSSoMHHqGIf2P8rQSMLwEGAcqAwYHOBjj52fIBdaHMnYVjPAAZ3FmHh8Tp4YzAzwTXMBCGBgwzphYKPi6InjzE+cZP2m7agopFQqEW3aSpjWQRCgtUJEobTCJV1M3MSktQCCFCdrBeBwgA4rXojGp6+zmMSQJAndTodOp0XcjUEFjI8d5FS2Z7g2pKcOdhaQIk5vRKaWI2NajD1RZ+kQKCbCGGg9PGa/u2Ojen/Qdsp08RMfThAFDqjW4bVXBTx73yJ/99Cfcdudv8rQ8AhBoFEC4gwKRagDb0QYhqnqlEpr0UHo2+nMIAGAxFiM8ZAkcUw37qaQXTx0Cuuwvs9AK1Slig4SThw9yKMPfxWlYe81CiygQBxYBxiHyeDbjqTtbMYEtIA4Y13pFRkLND/1FH8/Neu+b5oW17XY2IEFBDxhF274Gc26Yc2hfQ/xh//hQ9z/+d/j/+x/gsXFRaJyhWpPnUq1RikqEwQhWmuKE6RFUlEs+DhrvESEQOvMNH9tT62W9lUjCCOmJs/zxN99my/8wT388X/+FeZPHeGyywLe8FoFHRDvPmDAJg7XsZiWJWPJmIAmYFd7LG6B1lxM69nT7oGbh+1rXVtBFbA+TiQQ6Dp2bBOu/SnNs49CqzPG/oe/zOPf/jK9QxvYsPlyLrtyNxsv2cHmbTtZM7KOWi0zpJeoFHJhCYLAC2Cx2UpNXGBhYYFTY0c5cewIxw+/wMED3+PMiR/Smp+iFsDaOqiy5pa3BdSq4NoAAhYweep3HG7ekrFkTOC1ggHFMGgBcx/7Lt9540Z7fKDXblYVQVVASgq0AxHoOG57V8CpH1h6gpCdQzAXW6aaJzn7wkkOPfNtDBBWqvTUB+kbGGZgzTr6B0YolatUUkWlEs5lBrbotFu0mvNMT5xh8vwZZqcnaC1MknRiIgWNClxSg4HBFFgL8aKjsll481sULDrwW25SCT5rWxYzb9N+7PGMBZgDWhfzg5EEmD8yy/zjY+5P3tpn/53uUdgKqAgIBTTQxm98bnxnyL6vxGzoUyit6VpFy8Bi4liMHc24RbM7Rmt8jB+N7edwAsbm4zSTeKEBrSEKoFKCDamqo0JPqFMpqgFUNIQidDqOMzG845dCqiHgBEHACi5/7moWHGbGkjFkLOCVLL8VXpoFC8DML/8t33lird2/tm52S9VnASpUoAUJgVnHLW/XnD1hmf6+Yf2wohQITsBYIXaOxCq6lrSG2Hl4/OrqKHbXgJZ8p6u8x4TKf6aU1SJo8dfQ7sLZSceb7gi5cpfAOQciuAw+gXzck8waxifs/owBmAEWXsoPRzvAzGyb3s8+6z7zGw3zGamoskRCGFiUVhCAWCHoWO74cMi9n4RzpyzrhhVR6IEQkeJUCljnLjil5pJifhUyCSLgRfFccbHjOD3t2PmWgJvfoWHCgCh8fwZs2/qhkcxa2lOmncWeMswBMzkTL25AkQVzwOTvP82RGzbK566vmA/rSLChQgILgaQCaUGj1/KeXyvx1T+IOXXMsnZYqOQ7Pa1ACtJVXvsQYOl53+QPRRe6KfyUY9tNAW9/b4CaMmBU/hgQXNtiU3ibwptJw5PH5HO//7Q7AkwCcxf/fkChLjAFVG/7uv3GU3XZvi1MbiYMQBRKCSoARJB5RzpZcmdqwl/fG3PiyYSRXqFeE0qSmyAXosqKh0DncngLnZhsGWMmdlz17hI3vFUhEwY6+aTXBdsCO++IZyzd8wlHxuxDt33dfQOYyBm6AKsasMpcMAVU7v5L90cP3G7XjGjzevIxKlohCE5AZqGnx/DOD4Y8faVm3zdjZs87BnuhWhHvm1KgAN9+OXgHNr/r3QQWFh1TKVh9s+a2O0K2bQXOWegKLgZfNx12zhJPpzpnsmH4bBYrMO3hlx37hfQnPvEJVirp/7l77rnHAEy00M+e5/s3jborKophAkEE8DAKEIhBWo71OxQ7rguII+H0acfMtKMbCw6wgPMSbCHi/G4vtv0dZ6oJekSx5+0lbv6FkOGK9fAuFjx4W7BNm8I7PPx4Bm8O/Mtvud/ZP84p4AwwlbJ3/59flBSROjACrH/TRtZ99hb5tXWb1BvC0QDdqwjqgvQoJAIJHRIAPcCAZqElHD5gOfqcYXrM0p13kBTDorjroCKI+hQjWxVbX6fZuk0oWQuTFjr5JjIRXAtc05LMO8ysJT6bcHrMfu9DD7r/8t2TnAROA+Mp2/xP7E1REekH1gCj23sZuv82+eDWTermcFij+1VugqDKApHkr8UDVaChIFI02zA97ZibhsUZR9x1AERVod4vNHqF/gEoBQ4WLcw6PLj14NB12LbDLTiSfJ2PzxsO/8h++1/8hfvvh6c4C17nU65pgJ+kAQL0A8N5NjT+/OfV26671L2/MqjLwaBGNwRdU0gZJBKkBBKACKDxxlABQoFAipOIARLnAWllNWBy8Kzu5tvaFphFi5lzJFOG1qRpP3ZEvnD71+y3gBlgPIMHZlxaXo53hRXQCwzlRgz86z1s+dAe+cW1o2q3HlAEfQqVZUJFpQIJMwloEA/tQFY4hjnAb2jyM33sPLxt47e2Nl/jzZTlzFm7/7PPuP/x6Wc4Ckzl4JPAbMpkX9a3xYE6MJirv6Kpf+atXHfDFvn5viG1RfcqdF2hqoJUBF0CSuLNQIOoYtcD5OAOH7bJwIGOw3T9WR7bdJgF68f7zIQ99sgx97UPP8hjLcM8MO3BvZh3aXmlfl+glmdDP9AHNNbXqP32Dey9dqPcMtgvu4KakswEXVXFkPDZgJdSAGBzcFye6nnKm6b18MmCdZNT7vnHT7q/+c1HePrUAguQ7/BgOr/rC6/4b4yISJRnQyM3oQ7UgOBX97LlZ7ervVv63d5anc2liopUJBAKEoAKfjwD/Pk9AfJHWN2W7SzMc/zYtDz9V4fs0+mO9BiQgIefz+Hn8rveAXjFDSjmBSoevlAV6AEiDerndrDm+o2s3zmoNg5V3bpqyEAUUAs1EUBs6HQSFpoxUxNNOf3DSTv2v8c49RcHOWfAAh1gEWh6+EKtYry/0gYsNSLIjejJVc2NKQOlXDqXLWoAFGCK2qubqw20cvjFTDl48ur7vcHCiAgo56p4+EIaUHlNIQxgC/hcHp52rs4S8FeVAUtXi/ACBb4uDChmgcKAGEh8TSFXBMqr24DV5woNKK/lz0M2l/Fj+xUo/xd+DYsy448VUQAAAABJRU5ErkJggg==" />) is<br>
also still a graph. This line of thinking will help us later when we design<br>
graph algorithms.</p>
<h3 id="what-is-a-tree">What is a Tree?</h3>
<p><em><strong>A <strong>Tree</strong> is a <strong>Graph</strong> that does not contain any cycles</strong></em>.</p>
<ul>
<li>A cycle is is<br>
defined as a path through edges that begins and ends at the same node.<br>
This seems straightforward, but the definition becomes a bit muddled as Mathematicians and Computer Scientists use the term &quot;tree&quot; in slightly differentways.</li>
</ul>
<ul>
<li>To a Mathematician, graphs 1, 2, 3, and 4 in the above image are trees.</li>
<li>To a Computer Scientist, only graphs 1 ,2, and 3 are trees.</li>
</ul>
<p>Well, at least both camps agree that graph 5 is most certainly not a tree! This<br>
is because of the obvious cycle that spans all three nodes. However, why is<br>
there disagreement over graph 4? The reason is this: In computer science, we use<br>
to the term &quot;tree&quot; to really refer to a &quot;rooted tree.&quot; A &quot;rooted tree&quot; is a<br>
&quot;tree&quot; where there exists a special node from which every other node is<br>
accessible; we call this special node the &quot;root&quot;.  Think of the root as ultimate<br>
ancestor, the single node that all other nodes inherit from. Above we have<br>
colored all roots in blue. Like you'd probably suspect, in this course we'll<br>
subscribe to the Computer Scientist's interpretation. That is, we won't consider<br>
graph 4 a tree because there is no such root we can label.</p>
<p>You've probably heard the term &quot;root&quot; throughout your software engineering<br>
career: root directory, root user, etc.. All of these concepts branch† from the<br>
humble tree data structure!</p>
<h3 id="what-is-a-binary-tree">What is a Binary Tree?</h3>
<p>A <strong>Binary Tree</strong> is a <strong>Tree</strong> where nodes have <strong>at most 2 children</strong>. This<br>
means graphs 1, 2, and 3 are all Binary Trees. There exist ternary trees (at<br>
most 3 children) and n-ary trees (at most n children), but you'll likely<br>
encounter binary trees in your job hunt, so we'll focus on them in this course.<br>
Based on our final definition for a binary tree, here is some food for thought:</p>
<ul>
<li>an empty graph of 0 nodes and 0 edges is a binary tree</li>
<li>a graph of 1 node and 0 edges is a binary tree</li>
<li>a linked list is a binary tree</li>
</ul>
<p>Take a moment to use the definitions we explored to verify that each of the<br>
three statements above is true. We bring up these three scenarios in particular<br>
because they are the simplest types of Binary Trees. We want to eventually build<br>
elegant algorithms and these simple scenarios will fuel our design.</p>
<h3 id="representing-a-binary-tree-with-node-instances">Representing a Binary Tree with Node Instances</h3>
<p>Let's explore a common way to represent binary trees using some object oriented<br>
design. A tree is a collection of nodes, so let's implement a <code>TreeNode</code> class.<br>
We'll use properties of <code>left</code> and <code>right</code> to reference the children of a<br>
<code>TreeNode</code>. That is, <code>left</code> and <code>right</code> will reference other <code>TreeNode</code>s:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(val) {
    <span class="hljs-keyword">this</span>.val = val;
    <span class="hljs-keyword">this</span>.left = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.right = <span class="hljs-literal">null</span>;
  }
}
</div></code></pre>
<p>Constructing a tree is a matter of creating the nodes and setting <code>left</code> and<br>
<code>right</code> however we please. For example:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">'a'</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">'b'</span>);
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">'c'</span>);
<span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">'d'</span>);
<span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">'e'</span>);
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">'f'</span>);

a.left = b;
a.right = c;
b.left = d;
b.right = e;
c.right = f;
</div></code></pre>
<p>The visual representation of the tree is:</p>
<p><img src="./graph_a.png" alt="graph_a"></p>
<p>To simplify our diagrams, we'll omit the arrowheads on the edges. Moving forward<br>
you can assume that the top node is the root and the direction of edges points<br>
downward. In other words, node A is the Root. Node A can access node B through<br>
<code>a.left</code>, but Node B cannot access Node A.</p>
<p>We now have a data structure we can use to explore Binary Tree algorithms!<br>
Creating a tree in this way may be tedious and repetitive, however it allows us<br>
to decide exactly what nodes are connected and in what direction. This is will<br>
be useful as we account for edge cases in our design.</p>
<h3 id="basic-tree-terminology">Basic Tree Terminology</h3>
<ul>
<li>tree - graph with no cycles</li>
<li>binary tree - tree where nodes have at most 2 nodes</li>
<li>root - the ultimate parent, the single node of a tree that can access every<br>
other node through edges; by definition the root will not have a parent</li>
<li>internal node - a node that has children</li>
<li>leaf - a node that does not have any children</li>
<li>path - a series of nodes that can be traveled through edges - for example A,<br>
B, E is a path through the above tree</li>
</ul>
<p>† Pun Intended</p>
<h2 id="traversing-trees">Traversing trees</h2>
<p>Unlike linked lists, arrays and other linear data structures, which are usually<br>
traversed in linear order from front to back or back to front, trees may be<br>
traversed in multiple ways. They may be traversed in depth-first or<br>
breadth-first order. There are three common ways to traverse them in depth-first<br>
order: in-order, pre-order and post-order.</p>
<h3 id="breadth-first-search">Breadth-first search</h3>
<p>Trees can also be traversed level-by-level, where you visit every node on a<br>
level before going to a lower level. This search is referred to as breadth-first<br>
search (BFS), as the search tree is broadened as much as possible on each depth<br>
before going to the next depth.</p>
<p><img src="./File:Sorted_binary_tree_breadth-first_traversal.svg" alt="breadth-first tree traversal"></p>
<h3 id="depth-first-searches">Depth-first searches</h3>
<p>These searches are referred to as depth-first search (DFS), since the search<br>
tree is deepened as much as possible on each child before going to the next<br>
sibling.</p>
<p><img src="./Sorted_binary_tree_ALL.svg" alt="depth-first tree traversal"></p>
<h4 id="pre-order-traversal">Pre-order traversal</h4>
<p>In the above image, the pre-order is noted by when the dotted line touches the<br>
red dot and yields F, B, A, D, C, E, G, I, H. The algorithm is as follows and is<br>
&quot;pre-order&quot; because you access the value of the node before recursively<br>
descending.</p>
<ul>
<li>Access the data of the current node</li>
<li>Recursively visit the left sub tree</li>
<li>Recursively visit the right sub tree</li>
</ul>
<h4 id="in-order-traversal">In-order traversal</h4>
<p>In the above image, the in-order is noted by when the dotted line touches the<br>
yellow dot and yields A, B, C, D, E, F, G, H, I. The algorithm is as follows and<br>
is &quot;in-order&quot; because you access the value of the node after descending to the<br>
left but before descending to the right.</p>
<ul>
<li>Recursively visit the left sub tree</li>
<li>Access the data of the current node</li>
<li>Recursively visit the right sub tree</li>
</ul>
<h4 id="post-order-traversal">Post-order traversal</h4>
<p>In the above image, the post-order is noted by when the dotted line touches the<br>
green dot and yields A, C, E, D, B, H, I, G, F. The algorithm is as follows and<br>
is &quot;post-order&quot; because you access the value of the node after descending to<br>
both branches.</p>
<ul>
<li>Recursively visit the left sub tree</li>
<li>Recursively visit the right sub tree</li>
<li>Access the data of the current node</li>
</ul>
<hr>
<h1 id="binary-search-trees">Binary Search Trees</h1>
<p>Now that we have a solid grasp of <strong>Binary Trees</strong>, let's add another constraint<br>
to the data structure. A Binary <strong>Search</strong> Tree (BST) has an additional criteria<br>
where:</p>
<ul>
<li>given any node of the tree, the values in the left subtree must all be<br>
strictly less than the given node's value.</li>
<li>and the values in the right subtree must all be greater than or equal to the<br>
given node's value</li>
</ul>
<h3 id="bst-definition">BST Definition</h3>
<p>We can also describe a BST using a recursive definition. A <strong>Binary Tree</strong> is a<br>
<strong>Binary Search Tree</strong> if:</p>
<ul>
<li>the left subtree contains values less than the root</li>
<li>AND the right subtree contains values greater than or equal to the root</li>
<li>AND the left subtree is a Binary Search Tree</li>
<li>AND the right subtree is a Binary Search Tree</li>
</ul>
<p>It's worth mentioning that the empty tree (a tree with 0 nodes) is indeed a BST<br>
(did someone say base case?).</p>
<p>Here are a few examples of BSTs:</p>
<p><img src="./bsts.png" alt="bsts"></p>
<p>Take a moment to verify that the above binary trees are BSTs. Note that image 2<br>
has the same chain structure as a linked list. This will come into play later.</p>
<p>Below is an example of a binary tree that is <strong>not</strong> a search tree because a<br>
left child (35) is greater than it's parent (23):</p>
<p><img src="./not_bst.png" alt="not_bst"></p>
<h3 id="a-bst-is-a-sorted-data-structure">A BST is a Sorted Data Structure</h3>
<p>So what's the big deal with BSTs? Well, because of the properties of a BST, we<br>
can consider the tree as having an order to the values. That means the values<br>
are fully sorted! By looking at the three BST examples above, you are probably<br>
not convinced of things being sorted. This is because the ordering is encoded by<br>
an in-order traversal. Let's recall our previous <code>inOrderPrint</code> function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inOrderPrint</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;

  inOrderPrint(root.left);
  <span class="hljs-built_in">console</span>.log(root.val);
  inOrderPrint(root.right);
}
</div></code></pre>
<p>If we run <code>inOrderPrint</code> on the three BSTs, we will get the following output:</p>
<pre class="hljs"><code><div>BST 1: 42
BST 2: 4, 5, 6
BST 3: 1, 5, 7, 10, 16, 16
</div></code></pre>
<p>For each tree, we printed out values in increasing order! A binary search tree<br>
contains sorted data; this will come into play when we perform algorithms on<br>
this data structure.</p>
<p>Once you create a binary search tree class <code>BST</code>, you can call <code>insert</code> to build<br>
up the <code>BST</code> without worrying about breaking the search tree property. Here are<br>
two different trees built with the <code>BST</code> class that you'll write.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> tree1 = <span class="hljs-keyword">new</span> BST();
tree1.insert(<span class="hljs-number">10</span>);
tree1.insert(<span class="hljs-number">5</span>);
tree1.insert(<span class="hljs-number">16</span>);
tree1.insert(<span class="hljs-number">1</span>);
tree1.insert(<span class="hljs-number">7</span>);
tree1.insert(<span class="hljs-number">16</span>);

<span class="hljs-keyword">let</span> tree2 = <span class="hljs-keyword">new</span> BST();
tree2.insert(<span class="hljs-number">1</span>);
tree2.insert(<span class="hljs-number">5</span>);
tree2.insert(<span class="hljs-number">7</span>);
tree2.insert(<span class="hljs-number">10</span>);
tree2.insert(<span class="hljs-number">16</span>);
tree2.insert(<span class="hljs-number">16</span>);
</div></code></pre>
<p>The insertions above will yield the following trees:</p>
<p><img src="./good_bad_bst.png" alt="good_bad_bst"></p>
<p>Are you cringing at <code>tree2</code>? You should be. Although we have the same values in<br>
both trees, they display drastically different structures because of the<br>
insertion order we used. This is why we have been referring to our <code>BST</code><br>
implementation as <strong>naive</strong>. Both of these trees are Binary Search Trees,<br>
however not all BSTs are created equal. A worst case BST degenerates into a<br>
linked list. The &quot;best&quot; BSTs are <strong>height balanced</strong>, we'll explore this concept<br>
soon™.</p>
<h2 id="a-special-traversal-case">A special traversal case</h2>
<p>In a binary search tree, in-order traversal retrieves the keys in <strong>ascending<br>
sorted order</strong>. Please review the image that you saw before about tree traversal.</p>
<p><img src="./Sorted_binary_tree_ALL.svg" alt="depth-first tree traversal"></p>
<p>Note that the in-order sort represented by where the dotted line touches the<br>
yellow dots results in node visiting in the order A, B, C, D, E, F, G, H, I.<br>
In-order traversal <em>always</em> visits the nodes in sequential order in a binary<br>
search tree.</p>
<hr>
<h1 id="binary-tree-project">Binary Tree Project</h1>
<p>This project contains a skeleton for you to implement a binary tree. This is a<br>
test-driven project. Run the tests and read the top-most error. If it's not<br>
clear what is failing, open the <strong>test/test.js</strong> file to figure out what the<br>
test is expecting. Make the top-most test pass.</p>
<p>Keep making the top-most test pass until all tests pass.</p>
<p>The algorithms for the traversal functions are in the files and are reproduced<br>
here.</p>
<pre class="hljs"><code><div>procedure in order array (node)
  parameter node: a tree node

  if the tree node is null, return an empty array

  // get the array for visiting the left node of node
  // get the array for visiting the right node of node

  // return the left array concatenated with the node value
  //   concatenated with the right array
end procedure in order array
</div></code></pre>
<pre class="hljs"><code><div>procedure post order array (node)
  parameter node: a tree node

  if the tree node is null, return an empty array

  // get the array for visiting the left node of node
  // get the array for visiting the right node of node

  // return the left array concatenated with the right array
  //   concatenated with the node value
end procedure post order array
</div></code></pre>
<h2 id="instructions">Instructions</h2>
<ul>
<li>Clone the project from<br>
https://github.com/appacademy-starters/data-structures-binary-tree-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>test/test.js</code>. Your job is to write code in
<ul>
<li><strong>lib/tree_node.js</strong> to implement the <code>TreeNode</code> class</li>
<li><strong>lib/tree_order.js</strong> to implement the <code>inOrderArray</code> and <code>postOrderArray</code><br>
functions to traverse a tree</li>
<li><strong>BONUS: lib/leet_code_105.js</strong> as a scratch pad to work on the LeetCode.com<br>
problem at https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</li>
</ul>
</li>
</ul>
<hr>
<h1 id="binary-search-tree-project">Binary Search Tree Project</h1>
<p>This project contains a skeleton for you to implement a binary search tree. This<br>
is a test-driven project. Run the tests and read the top-most error. If it's not<br>
clear what is failing, open the <strong>test/test.js</strong> file to figure out what the<br>
test is expecting. Make the top-most test pass.</p>
<p>Keep making the top-most test pass until all tests pass.</p>
<h2 id="instructions">Instructions</h2>
<ul>
<li>Clone the project from<br>
https://github.com/appacademy-starters/data-structures-binary-search-tree-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>test/test.js</code>. Your job is to write code in
<ul>
<li><strong>lib/bst.js</strong> to implement the <code>BST</code> class</li>
<li><strong>BONUS: lib/leet_code_108.js</strong> as a scratch pad to work on the LeetCode.com<br>
problem at https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</li>
<li><strong>BONUS: lib/leet_code_110.js</strong> as a scratch pad to work on the LeetCode.com<br>
problem at https://leetcode.com/problems/balanced-binary-tree/</li>
</ul>
</li>
</ul>
<hr>
<h1 id="week-08-day-3brgraphs-ignoretrue">WEEK-08 DAY-3<br><em>Graphs</em> {ignore=true}</h1>
<hr>
<h1 id="graphs-and-heaps">Graphs and Heaps</h1>
<p><strong>The objective of this lesson</strong> is for you to become comfortable with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</p>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Heap.</li>
<li>Explain and implement a Graph.table with<br>
implementing common data structures. This is important because questions about<br>
data structures are incredibly likely to be interview questions for software<br>
engineers from junior to senior levels. Moreover, understanding how different<br>
data structures work will influence the libraries and frameworks that you choose<br>
when writing software.</li>
</ol>
<p>When you are done, you will be able to:</p>
<ol>
<li>Explain and implement a Heap.</li>
<li>Explain and implement a Graph.</li>
</ol>
<hr>
<h1 id="graphs">Graphs</h1>
<p>It's time to generalize our knowledge! We've explored binary trees and the<br>
fundamental algorithms that accompany them. Naturally, we implemented these<br>
algorithms assuming the constraints of a binary tree. To review, these<br>
assumptions include the lack of cycles, a maximum of two children, and a single<br>
root node. However, what if we take away these constraints? How can we modify the<br>
algorithms to operate on general graphs?</p>
<h2 id="what-is-a-graph">What is a Graph?</h2>
<p>A <strong>graph</strong> is <strong>any</strong> collection of nodes and edges. In contrast to our<br>
previous trees, a graph is much more relaxed in it's structure. A graph may:</p>
<ul>
<li>lack a root node</li>
<li>have cycles</li>
<li>have any number edges leaving a node</li>
</ul>
<p>In this section, we will draw heavily from our tree algorithms. The adjustments<br>
we will make to those algorithms will be motivated by these core differences.</p>
<p>Below are a few examples of graphs that don't agree with our CompSci definition<br>
of a binary tree:</p>
<p><img src="./graphs.png" alt="graphs"></p>
<p>Here are some highlights:</p>
<ul>
<li><code>Graph 1</code> lacks a root. This means there is no single node that can access all<br>
other nodes in a path through edges. This is important because we previously<br>
referenced &quot;entire&quot; trees by referring to the ultimate root. We can no longer<br>
do that in a graph. If we provide just <code>T</code>, you can't access <code>U</code>. If we<br>
provide just <code>U</code>, you can't access <code>T</code>. If we provide just <code>V</code>, you can't<br>
access <code>T</code> or <code>U</code>.</li>
<li><code>Graph 2</code> has a cycle. This means there is no longer a parent-child<br>
relationship. Choose any node in <code>Graph 2</code>, its grandchild will also be its<br>
parent. Wait - what? From now on we'll have to use less specific language such<br>
as &quot;<code>X</code> is a neighbor of <code>Y</code>.&quot;  Perhaps even more deadly, imagine we ran a<br>
&quot;simple&quot; Depth-First traversal on this graph. We could get trapped in an<br>
infinite loop if we are not careful.</li>
<li><code>Graph 3</code> features nodes that have more than 2 edges. Anarchy!</li>
</ul>
<h2 id="graph-implementations">Graph Implementations</h2>
<p>There are many ways to represent a graph programmatically. Let's take a moment<br>
to explore each and describe the tradeoffs we make when choosing among them. We<br>
will use <code>Graph 3</code> from above as our candidate. Bear in mind that our graph is<br>
directed. For example, this means that <code>C</code> can access <code>D</code>, but <code>D</code> cannot access<br>
<code>C</code>.</p>
<h3 id="graphnode-class">GraphNode Class</h3>
<p>This implementation is most similar to how we implemented binary trees. That is,<br>
we create a node class that maintains a value and an array of references to<br>
neighboring nodes. This easily solves the problem that a node can have any<br>
number of neighbors, no longer just a left and right.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
    <span class="hljs-keyword">constructor</span>(val) {
        <span class="hljs-keyword">this</span>.val = val;
        <span class="hljs-keyword">this</span>.neighbors = [];
    }
}

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'a'</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'b'</span>);
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'c'</span>);
<span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'d'</span>);
<span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'e'</span>);
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'f'</span>);
a.neighbors = [b, c, e];
c.neighbors = [b, d];
e.neighbors = [a];
f.neighbors = [e];
</div></code></pre>
<p>This implementation is great because it feels familiar to how we implemented<br>
trees. However, this implementation is clunky in that we have no easy way to<br>
refer to the entire graph. How can we pass this graph to a function? Recall that<br>
there is no root to act as the definite starting point.</p>
<h3 id="adjacency-matrix">Adjacency Matrix</h3>
<p>This is the often the mathematician's preferred way of representing a graph. We<br>
use a 2D array to represent edges. We'll first map each node's value to an<br>
index. This means <code>A -&gt; 0</code>, <code>B -&gt; 1</code>, <code>C -&gt; 2</code>, etc.. Below is the mapping for<br>
<code>Graph 3</code>:</p>
<p><img src="./adj_matrix_graph.png" alt="adj_matrix_graph"></p>
<p>From here, the row index will correspond to the source of an edge and the column<br>
index will correspond to its destination. A value of <code>true</code> will mean that there<br>
does exist an edge from source to destination.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> matrix = [
<span class="hljs-comment">/*          A       B       C       D       E       F   */</span>
<span class="hljs-comment">/*A*/</span>    [<span class="hljs-literal">true</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*B*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*C*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*D*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*E*/</span>    [<span class="hljs-literal">true</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">false</span>],
<span class="hljs-comment">/*F*/</span>    [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">false</span>,  <span class="hljs-literal">true</span>,   <span class="hljs-literal">true</span>]
];
</div></code></pre>
<p>A few things to note about using an adjacency matrix:</p>
<ul>
<li>when the edges have direction, <code>matrix[i][j]</code> may not be the same as<br>
<code>matrix[j][i]</code></li>
<li>it is common to say that a node is adjacent to itself, so <input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">=== true</label> for any <code>x</code></li>
</ul>
<p>An advantage of the matrix implementation is that it allows us to refer to the<br>
entire graph by simply referring to the 2D array. A huge disadvantage of using a<br>
matrix is the space required. To represent a graph of n nodes, we must allocate<br>
n<sup>2</sup> space for the 2D array. This is even more upsetting when there are<br>
few edges in graph. We will have to use n<sup>2</sup> space, even though the<br>
array would be sparse with only a few <code>true</code> elements.</p>
<h3 id="adjacency-list">Adjacency List</h3>
<p>An adjacency list seeks to solve the shortcomings of the matrix implementation.<br>
We use an object where keys represent the node labels. The values associated<br>
with the keys will be an array containing all adjacent nodes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> graph = {
    <span class="hljs-string">'a'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>],
    <span class="hljs-string">'b'</span>: [],
    <span class="hljs-string">'c'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>],
    <span class="hljs-string">'d'</span>: [],
    <span class="hljs-string">'e'</span>: [<span class="hljs-string">'a'</span>],
    <span class="hljs-string">'f'</span>: [<span class="hljs-string">'e'</span>]
};
</div></code></pre>
<p>An adjacency list is easy to implement and allows us to refer to the entire<br>
graph by simply referencing the object. The space required for an adjacency list<br>
is the number of edges in the graph. Since there will be at most n<sup>2</sup><br>
edges in a graph of n nodes, the adjacency list will use at most the same amount<br>
of space as the matrix. You'll find adjacency lists useful when attacking<br>
problems that are not explicitly about graphs. We'll elaborate more on this<br>
soon.</p>
<hr>
<h1 id="graph-traversal">Graph Traversal</h1>
<p>Let's explore our classic Depth-First, but for <strong>graphs</strong> this time! We'll be<br>
utilizing the <code>GraphNode</code> and <code>Adjacency List</code> implementations of the following<br>
graph:</p>
<p><img src="./graph.png" alt="graph"></p>
<p>Since we already discussed the differences between Depth-First and<br>
Breadth-First, we'll focus just on Depth-First here. We'll leave the<br>
Breadth-First exploration in the upcoming project.</p>
<h3 id="graph-traversal-w-graphnode">Graph Traversal w/ GraphNode</h3>
<p>Let's begin by assuming we have our candidate graph implemented using our<br>
<code>GraphNode</code> class:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
    <span class="hljs-keyword">constructor</span>(val) {
        <span class="hljs-keyword">this</span>.val = val;
        <span class="hljs-keyword">this</span>.neighbors = [];
    }
}

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'a'</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'b'</span>);
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'c'</span>);
<span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'d'</span>);
<span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'e'</span>);
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">'f'</span>);
a.neighbors = [e, c, b];
c.neighbors = [b, d];
e.neighbors = [a];
f.neighbors = [e];
</div></code></pre>
<p>One thing we'll have to decide on is what node to begin our traversal. Depending<br>
on the structure of the graph, there may not be a suitable starting point.<br>
Remember that a graph may not have a &quot;root&quot;. However in our candidate, <code>F</code> is<br>
like a root. It is the only valid choice because it is the only node that may<br>
access all other nodes through some path of edges. We admit, the choice of <code>F</code><br>
is somewhat contrived and in a practical setting you may not have a nice<br>
starting point like this. We'll cover how to overcome this obstacle soon. For<br>
now we'll take <code>F</code>.</p>
<p>We want to build a recursive <code>depthFirstRecur</code> function that accepts a node and<br>
performs a Depth-First traversal through the graph. Let's begin with a baseline<br>
solution, although it is not yet complete to handle all graphs:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// broken</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstRecur</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-built_in">console</span>.log(node.val);

    node.neighbors.forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        depthFirstRecur(neighbor);
    });
}

depthFirstRecur(f);
</div></code></pre>
<p>Can you see where this code goes wrong? It will get caught in an infinite cycle<br>
<code>f, e, a, e, a, e, a, e, ...</code> ! To fix this, simply store which nodes we have<br>
visited already. Whenever we hit a node that has previously been visited, then<br>
return early. We'll use JavaScript<br>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Sets</a><br>
to store <code>visited</code> because they allow for constant time lookup.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// using GraphNode representation</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstRecur</span>(<span class="hljs-params">node, visited=new Set(</span>)) </span>{
    <span class="hljs-comment">// if this node has already been visited, then return early</span>
    <span class="hljs-keyword">if</span> (visited.has(node.val)) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// otherwise it hasn't yet been visited,</span>
    <span class="hljs-comment">// so print it's val and mark it as visited.</span>
    <span class="hljs-built_in">console</span>.log(node.val);
    visited.add(node.val);

    <span class="hljs-comment">// then explore each of its neighbors</span>
    node.neighbors.forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        depthFirstRecur(neighbor, visited);
    });
}

depthFirstRecur(f);
</div></code></pre>
<p>This code works well and will print the values in the order <code>f, e, a, c, b, d</code>.<br>
Note that this strategy only works if the values are guaranteed to be unique.</p>
<p>If you are averse to recursion (don't be), we can write an iterative version<br>
using the same principles:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstIter</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">let</span> stack = [ node ];

    <span class="hljs-keyword">while</span> (stack.length) {
        <span class="hljs-keyword">let</span> node = stack.pop();

        <span class="hljs-comment">// if this node has already been visited, then skip this node</span>
        <span class="hljs-keyword">if</span> (visited.has(node.val)) <span class="hljs-keyword">continue</span>;

        <span class="hljs-comment">// otherwise it hasn't yet been visited,</span>
        <span class="hljs-comment">// so print it's val and mark it as visited.</span>
        <span class="hljs-built_in">console</span>.log(node.val);
        visited.add(node.val);

        <span class="hljs-comment">// then add its neighbors to the stack to be explored</span>
        stack.push(...node.neighbors);
    }
}

depthFirstIter(f);
</div></code></pre>
<h3 id="graph-traversal-w-adjacency-list">Graph Traversal w/ Adjacency List</h3>
<p>Let's now assume our candidate graph in the form of an Adjacency List:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> graph = {
    <span class="hljs-string">'a'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>],
    <span class="hljs-string">'b'</span>: [],
    <span class="hljs-string">'c'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>],
    <span class="hljs-string">'d'</span>: [],
    <span class="hljs-string">'e'</span>: [<span class="hljs-string">'a'</span>],
    <span class="hljs-string">'f'</span>: [<span class="hljs-string">'e'</span>]
};
</div></code></pre>
<p>Bear in mind that the nodes are just strings now, not <code>GraphNode</code>s. Other than<br>
that, the code shares many details from our previous implementations:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// using Adjacency List representation</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstRecur</span>(<span class="hljs-params">node, graph, visited=new Set(</span>)) </span>{
    <span class="hljs-keyword">if</span> (visited.has(node)) <span class="hljs-keyword">return</span>;

    <span class="hljs-built_in">console</span>.log(node);
    visited.add(node);

    graph[node].forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        depthFirstRecur(neighbor, graph, visited);
    });
}

depthFirstRecur(<span class="hljs-string">'f'</span>, graph);
</div></code></pre>
<p>Cool! We print values in the order <code>f, e, a, b, c, d</code>. We'll leave the iterative<br>
version to you as an exercise for later.</p>
<p>Instead, let's draw our attention to a point from before: having to choose <code>f</code><br>
as the starting point isn't dynamic enough to be impressive. Also, if we choose<br>
a poor initial node, some nodes may be unreachable. For example, choosing <code>a</code> as<br>
the starting point with a call to <code>depthFirstRecur('a', graph)</code> will only print<br>
<code>a, b, c, d, e</code>. We missed out on <code>f</code>. Bummer.</p>
<p>We can fix this. A big advantage of using an Adjacency List is that it contains<br>
the full graph! We can use a surrounding loop to allow our traversal to jump<br>
between disconnected regions of the graph. Refactoring our code:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirst</span>(<span class="hljs-params">graph</span>) </span>{
    <span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> node <span class="hljs-keyword">in</span> graph) {
        _depthFirstRecur(node, graph, visited);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_depthFirstRecur</span>(<span class="hljs-params">node, graph, visited</span>) </span>{
    <span class="hljs-keyword">if</span> (visited.has(node)) <span class="hljs-keyword">return</span>;

    <span class="hljs-built_in">console</span>.log(node);
    visited.add(node);

    graph[node].forEach(<span class="hljs-function"><span class="hljs-params">neighbor</span> =&gt;</span> {
        _depthFirstRecur(neighbor, graph, visited);
    });
}

depthFirst(graph);
</div></code></pre>
<p>Notice that our main function <code>depthFirst</code> is iterative and accepts the entire<br>
Adjacency List as an Argo. Our helper <code>_depthFirstRecur</code> is recursive.<br>
<code>_depthFirstRecur</code> serves the same job as before, it will explore a full<br>
connected region in a graph. The main <code>depthFirst</code> method will allow us to<br>
&quot;bridge&quot; the gap between connection regions.</p>
<p>Still fuzzy? Imagine we had the following graph. Before you ask, these are not<br>
two separate graphs. This is a <strong>single</strong> graph that contains two connected<br>
components. Another term for a graph of this structure is a &quot;Forest&quot; because it<br>
contains multiple &quot;Trees&quot;, ha:</p>
<p><img src="./forest.png" alt="forest"></p>
<p>It is easy to represent this graph using an Adjacency List. We can then pass the<br>
graph into our <code>depthFirst</code> from above:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> graph = {
    <span class="hljs-string">'h'</span>: [<span class="hljs-string">'i'</span>, <span class="hljs-string">'j'</span>],
    <span class="hljs-string">'i'</span>: [],
    <span class="hljs-string">'j'</span>: [<span class="hljs-string">'k'</span>],
    <span class="hljs-string">'k'</span>: [],
    <span class="hljs-string">'l'</span>: [<span class="hljs-string">'m'</span>],
    <span class="hljs-string">'m'</span>: []
}

depthFirst(graph);
<span class="hljs-comment">// prints h, i, j, k, l, m</span>
</div></code></pre>
<p>Here's the description for how <code>depthFirst</code> operates above. We enter<br>
<code>depthFirst</code> and the for loop begins on <code>h</code>. This means we enter our<br>
<code>_depthFirstRecur</code>, which will continue to explore the &quot;local&quot; region as far as<br>
possible. When this recursion ends, we would have explored the entire connected<br>
region of <code>h, i, j, k</code> (note that we add these nodes to visited as well). Our<br>
recursive call then returns to the main <code>depthFirst</code> function, where we continue<br>
the for loop. We iterate it until we hit an unvisited node (<code>l</code>) and then<br>
explore it's local region as far as possible using <code>_depthFirstRecur</code>, hitting<br>
the last node <code>m</code>.</p>
<hr>
<h1 id="graph-project">Graph Project</h1>
<p>This project contains a skeleton for you to implement some graph functionality.<br>
This is a test-driven project. Run the tests and read the top-most error. If<br>
it's not clear what is failing, open the <strong>test/test.js</strong> file to figure out<br>
what the test is expecting. Make the top-most test pass.</p>
<p>Keep making the top-most test pass until all tests pass.</p>
<p>After the instructions, there is an in-depth explanation of the &quot;friends of&quot;<br>
problem.</p>
<h2 id="instructions">Instructions</h2>
<ul>
<li>Clone the project from<br>
https://github.com/appacademy-starters/data-structures-graph-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>test/test.js</code>. Your job is to write code in
<ul>
<li><strong>lib/breadth_first_search.js</strong> to implement the <code>breadthFirstSearch</code><br>
function for graphs</li>
<li><strong>lib/max_value.js</strong> to implement the <code>maxValue</code> function for graphs</li>
<li><strong>lib/num_regions.js</strong> to implement the <code>numRegions</code> function for graphs</li>
<li><strong>lib/friends-of.js</strong> to implement <code>friendsOf</code> and <code>friendsOfRecursion</code> to<br>
find connected nodes in a graph less than or equal to a specified distance<br>
away from the start node (please see the explanation after these<br>
instructions)</li>
<li><strong>lib/leet_code_207.js</strong> to implement the <code>canFinish</code> function located<br>
at https://leetcode.com/problems/course-schedule/</li>
</ul>
</li>
</ul>
<h2 id="friends-of">Friends of</h2>
<p>The set of tests in <strong>test/friends-of-spec.js</strong> asks you to write a function<br>
named <code>friendsOf</code> that finds the total set of friends a specified distance away<br>
from a person. It will take as parameters</p>
<ol>
<li>The adjacency list (which will always be an object with keys that always have<br>
arrays as values)</li>
<li>The name of the person whose friends you need to return</li>
<li>The distance away from the person that you'll use to collect the friends<br>
(this value will always be greater than or equal to 1)</li>
</ol>
<p>The following table interprets the distance parameter:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Distance</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>Immediate friends</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>Immediate friends and friends of friends</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>Immediate friends, friends of friends, and the friends of friends of friends</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td>All the people accessible <em>n</em> steps away from the indicated person</td>
</tr>
</tbody>
</table>
<p>For example, say you had the following dependency graph.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> graph = {
  <span class="hljs-string">'carrie'</span>:  [<span class="hljs-string">'humza'</span>, <span class="hljs-string">'jun'</span>],
  <span class="hljs-string">'farrah'</span>:  [<span class="hljs-string">'humza'</span>],
  <span class="hljs-string">'humza'</span>:   [<span class="hljs-string">'carrie'</span>, <span class="hljs-string">'farrah'</span>, <span class="hljs-string">'jun'</span>, <span class="hljs-string">'silla'</span>],
  <span class="hljs-string">'jun'</span>:     [<span class="hljs-string">'carrie'</span>, <span class="hljs-string">'silla'</span>],
  <span class="hljs-string">'ophelia'</span>: [<span class="hljs-string">'travis'</span>],
  <span class="hljs-string">'silla'</span>:   [<span class="hljs-string">'humza'</span>, <span class="hljs-string">'yervand'</span>],
  <span class="hljs-string">'travis'</span>:  [<span class="hljs-string">'ophelia'</span>],
  <span class="hljs-string">'yervand'</span>: [<span class="hljs-string">'silla'</span>],
};
</div></code></pre>
<p>Then, the following table shows the expected results for the person <strong>jun</strong> at<br>
different distances.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Distance</th>
<th>List of people returned by <code>friendsOf</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>carrie and silla</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>carrie, silla, humza, yervand</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>carrie, silla, humza, yervand, farrah</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>carrie, silla, humza, yervand, farrah</td>
</tr>
</tbody>
</table>
<p>At distance 1, your traversal algorithm will find the friends of <strong>jun</strong>, carrie<br>
and silla and return them.</p>
<p>At distance 2, your traversal algorithm will find carrie and silla, then find<br>
their friends, humza and jun for carrie, and humza and yervand for silla. But,<br>
jun is the person that you started with, so you don't include them in the return<br>
value. Humza is both carrie's <em>and</em> silla's friend, but you only include that<br>
name once.</p>
<p>At a distance 3, you find carrie and silla, then humza and yervand. Then,<br>
looking at humza's friends, you see that humza knows carrie, farrah, hun, and<br>
silla. Only farrah is new, so that name will end up in the return value. When<br>
your traversal looks at yervand, it sees that silla is that person's friend, but<br>
is not a new value and does not end up getting added again to the return value.</p>
<p>At a distance four, you find carrie and silla, then humza and yervand, then<br>
farrah. From there, you look at farrah's friends which is just humza. You<br>
already have that name, so it doesn't get duplicated in the return value.</p>
<p>All distances 3 and greater will return the same list because you've exhausted<br>
all of the distinct names of people. You've captured the entire circle of<br>
friends.</p>
<p>The order in which you return the names is not important.</p>
<p>The tests also define edge cases that you also have to handle that are not in<br>
this explanation.</p>
<hr>
<h1 id="week-08-day-4brnetwork-knowledge-ignoretrue">WEEK-08 DAY-4<br><em>Network Knowledge</em> {ignore=true}</h1>
<hr>
<h1 id="network-models-objectives">Network Models Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to get a basic understanding of<br>
network models. This lesson is relevant because any network-connected software<br>
that you write will implementations of these models to communicate with other<br>
computers. Questions about network models are popular interviewing topics, too.</p>
<p>When you finish, you should be able to</p>
<ol>
<li>Describe the structure and function of network models from the perspective of<br>
a developer.a basic understanding of<br>
network models. This lesson is relevant because any network-connected software<br>
that you write will implementations of these models to communicate with other<br>
computers. Questions about network models are popular interviewing topics, too.</li>
</ol>
<p>When you finish, you should be able to</p>
<ol>
<li>Describe the structure and function of network models from the perspective of<br>
a developer.</li>
</ol>
<hr>
<h1 id="internet-protocol-suite-objectives">Internet Protocol Suite Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to understand the different parts of<br>
the Internet Protocols. This lesson is relevant because knowledge of internet<br>
protocols is expected for all Software Engineers that write code that connects<br>
to a network. Moreover, internet protocols are popular interviewing topics.</p>
<p>When you complete this content, you should be able to do the following.</p>
<ol>
<li>Identify the correct fields of an IPv6 header.</li>
<li>Distinguish an IPv4 packet from an IPv6.</li>
<li>Describe the following subjects and how they relate to one another: IP<br>
Addresses, Domain Names, and DNS.</li>
<li>Identify use cases for the TCP and UDP protocols.</li>
<li>Describe the following subjects and how they relate to one another: MAC<br>
Address, IP Address, and a port.</li>
<li>Identify the fields of a TCP segment.</li>
<li>Describe how a TCP connection is negotiated.</li>
<li>Explaining the difference between network devices like a router and a switch.u to understand the different parts of<br>
the Internet Protocols. This lesson is relevant because knowledge of internet<br>
protocols is expected for all Software Engineers that write code that connects<br>
to a network. Moreover, internet protocols are popular interviewing topics.</li>
</ol>
<p>When you complete this content, you should be able to do the following.</p>
<ol>
<li>Identify the correct fields of an IPv6 header.</li>
<li>Distinguish an IPv4 packet from an IPv6.</li>
<li>Describe the following subjects and how they relate to one another: IP<br>
Addresses, Domain Names, and DNS.</li>
<li>Identify use cases for the TCP and UDP protocols.</li>
<li>Describe the following subjects and how they relate to one another: MAC<br>
Address, IP Address, and a port.</li>
<li>Identify the fields of a TCP segment.</li>
<li>Describe how a TCP connection is negotiated.</li>
<li>Explaining the difference between network devices like a router and a switch.</li>
</ol>
<hr>
<h1 id="network-tools">Network Tools</h1>
<p><strong>The objective of this lesson</strong> is for you to have a basic understanding of<br>
commonly-used network analysis utilities. This lesson is relevant because<br>
interacting with networks via different tools is essential for every software<br>
developer on the web. When you are done, you should be able to use <code>traceroute</code><br>
to show routes between your computer and other computers. You should also be<br>
able to use <code>Wireshark</code> to show inspect network traffic.erstanding of<br>
commonly-used network analysis utilities. This lesson is relevant because<br>
interacting with networks via different tools is essential for every software<br>
developer on the web. When you are done, you should be able to use <code>traceroute</code><br>
to show routes between your computer and other computers. You should also be<br>
able to use <code>Wireshark</code> to show inspect network traffic.</p>
<hr>
<h1 id="the-osi-network-model">The OSI Network Model</h1>
<p>One challenge with mental models is that everyone thinks about things<br>
differently! While we've discussed the <em>TCP/IP reference model</em> at length, we<br>
haven't introduced any others. Let's take a look at one other very well-known<br>
reference model for networks: the <em>OSI Model</em>.</p>
<p>We'll cover:</p>
<ul>
<li>the origin of the OSI reference model,</li>
<li>each OSI layer and its properties,</li>
<li>and how to choose between OSI &amp; TCP/IP.</li>
</ul>
<h2 id="more-layers-more-fewer-problems">More layers, <s>more</s> fewer problems?</h2>
<p>Around the same time computer scientists in the United States were hammering out<br>
the layers of the TCP/IP reference model, a similar discussion was happening a<br>
world away in the United Kingdom. Researchers in the UK decided that a clear<br>
reference model needed to be available to others worldwide, so they began<br>
working with the <a href="https://www.iso.org/home.html">International Standards Organization (ISO)</a>. The ISO<br>
published a document called <strong>The Basic Reference Model for Open Systems<br>
Interconnection</strong> (or <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html"><strong>ISO 7498</strong></a>), including a seven layer reference<br>
model for networking, in the early 1980s.</p>
<p>The <em>Open Systems Interconnection (OSI)</em> reference model differs from the TCP/IP<br>
model by its focus on standardization. The TCP/IP model is mostly focused on<br>
practical networking concepts and isn't tightly tied to particular protocols<br>
(other than those for which it's named). The OSI model, however, has both<br>
conceptual layers <strong>and</strong> suggested protocols for each. This idea was<br>
well-intentioned: make these protocols the standard so that computer scientists<br>
have less to think about! This standardization could help prevent <em>vendor<br>
lock-in</em> as well, since all major vendors would (hopefully) follow the<br>
standards.</p>
<h2 id="the-layers-of-the-osi-model">The layers of the OSI model</h2>
<p>Here's an overview of the seven layers of the OSI model, along with some<br>
well-known protocols for each layer:</p>
<p>
  <img src="./image-network-models-osi.svg" style="width: 100%; height: auto;">
</p>
<p>Let's dig into each layer, starting from the top.</p>
<h3 id="application">Application</h3>
<p>The OSI <em>Application Layer</em> includes information used by client-side software.<br>
Data transmitted on this layer will interact directly with applications, as the<br>
name suggests, and can be displayed to the user with limited translation.<br>
<strong>HTTP</strong> is an example of a common Application Layer protocol.</p>
<h3 id="presentation">Presentation</h3>
<p>The OSI <em>Presentation Layer</em> is where data gets translated into a presentable<br>
format. This is often called the <em>syntax layer</em> since data is converted between<br>
machine-readable &amp; human-readable syntax here as well. As a result, the<br>
Presentation Layer may include data compression, encryption, and character<br>
encoding. Many image formats, including <strong>JPEG</strong> and <strong>GIF</strong>, use well-known<br>
Presentation Layer protocols.</p>
<h3 id="session">Session</h3>
<p>The OSI <em>Session Layer</em> includes protocols responsible for authentication and<br>
data continuity. Session Layer protocols may authorize a client with the server<br>
or re-establish a dropped connection. An example protocol you may find on this<br>
layer is <strong>RPC (Remote Procedure Call)</strong>, a mechanism for one device to initiate<br>
a command on another.</p>
<h3 id="transport">Transport</h3>
<p>Now we're on familiar turf! The OSI <em>Transport Layer</em>, like the layer of the<br>
same name in the TCP/IP reference model, utilizes transport protocols. Processes<br>
here are focused on data integrity and connectivity. Our old friends <strong>TCP</strong> and<br>
<strong>UDP</strong> are the two most-used transport protocols.</p>
<h3 id="network">Network</h3>
<p>The OSI <em>Network Layer</em> mirrors TCP/IP's <em>Internet Layer</em>. This layer manages<br>
connections between remote networks, transferring packets across intermediary<br>
devices. The best-known protocol at the Network Layer is <strong>IP</strong>.</p>
<h3 id="data-link">Data Link</h3>
<p>Protocols at the OSI <em>Data Link Layer</em> deal with connections directly from one<br>
machine's network interface to another. Frames targeting different MAC addresses<br>
are transferred here, and the Data Link Layer is primarily used by machines in<br>
local networks. The most recognizable protocol on this layer is <strong>Ethernet</strong>.</p>
<h3 id="physical">Physical</h3>
<p>OSI's <em>Physical Layer</em> goes a little deeper than the TCP/IP reference model.<br>
Physical Layer protocols have to do with translating from raw electrical signals<br>
to bits &amp; bytes of data. You may recognize <strong>Wi-Fi</strong> (technically known as<br>
<strong>802.11</strong>) and <strong>DSL</strong> as common Physical Layer protocols.</p>
<h2 id="which-model-do-i-use">Which model do I use?</h2>
<p>That's a lot of layers! It can be a little overwhelming to think of networks<br>
from the two complementary but differing perspectives of the TCP/IP and OSI<br>
reference models. Let's discuss when we might want to use each.</p>
<p>The OSI model is <em>conceptual</em>, meaning its practical uses are limited. We can<br>
see this when we look at protocols that cross layers. For example, HTTP<br>
primarily works on the OSI Application Layer, but includes the ability to manage<br>
character encoding, a Presentation Layer concern. Uh-oh! This makes OSI good for<br>
<strong>understanding concepts</strong>, but too restrictive for <strong>building new protocols</strong>.</p>
<p>The TCP/IP reference model, on the other hand, is almost purely practical.  It<br>
was extracted from real, functional networks used by DARPA in the 1970s. Instead<br>
of concerns with minutiae like signal-to-data conversions, TCP/IP focuses on the<br>
core of networking: getting data from one place to another. For this reason,<br>
it's most often used when <strong>building new systems</strong> or <strong>analyzing real<br>
networks</strong>.</p>
<p>Of course, two popular models means most engineers will flip-flop between them!<br>
You'll often hear both models used in the same conversation. We'll discuss some<br>
techniques to differentiate between these two models in an upcoming lesson.</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>We've examined two ways of thinking about network design &amp; functionality: first,<br>
the TCP/IP reference model, and now the OSI model. Next up, we'll compare these<br>
two models in greater detail.</p>
<p>After this lesson, you should feel comfortable:</p>
<ul>
<li>describing the layers of the OSI reference model,</li>
<li>giving examples of protocols used at each layer,</li>
<li>and explaining where one model may be more applicable than the other.</li>
</ul>
<hr>
<h1 id="tcpip-four-layers">TCP/IP: Four Layers</h1>
<p>We've investigated TCP/IP in great detail, and we've seen how broad a scope it<br>
covers. Now let's step back and think about the whole networking process. We're<br>
breaking the TCP/IP stack down and categorizing our protocols - are you ready?</p>
<p>We'll cover:</p>
<ul>
<li>The TCP/IP four-layer reference model,</li>
<li>separation of concerns in networking,</li>
<li>and data encapsulation.</li>
</ul>
<h2 id="a-layered-approach">A layered approach</h2>
<p>Remember that when TCP/IP was first being crafted, researchers felt it was too<br>
large and separated the <em>Transmission Control Protocol</em> from the <em>Internet<br>
Protocol</em>. This separation was a boon; it made the protocols easier to implement<br>
individually and led to the Internet we know and love today!</p>
<p>We sometimes refer to this approach as <em>separation of concerns</em>. We divide up<br>
complex processes so that many connected concepts can work independently. This<br>
makes it easier to consider each concept in detail on its own and means each<br>
concept can grow at its own unique pace.</p>
<p>The developers of TCP/IP took this separation even farther in 1989 when they<br>
published <a href="https://www.iso.org/home.html">RFC 1122</a>. This spec, also titled &quot;Requirements for Internet Hosts<br>
-- Communication Layers&quot;, provided a new way of thinking about the whole TCP/IP<br>
process. According to the RFC, we can separate the connection out into four<br>
distinct <em>layers</em>, or separate areas of interest. These are:</p>
<ul>
<li><em>Application</em></li>
<li><em>Transport</em></li>
<li><em>Internet</em></li>
<li>and <em>Link</em></li>
</ul>
<p>We refer to this as a <em>reference model</em>: a high-level overview of a complex<br>
topic provided by an organization that manages it. The four-layer model<br>
presented in RFC 112 is often called the <em>TCP/IP reference model</em>, simply<br>
<em>TCP/IP model</em>, or even the <em>Department of Defense (DoD) model</em>, referring to<br>
the original research being done at DARPA.</p>
<h2 id="layers-of-the-tcpip-model">Layers of the TCP/IP model</h2>
<p>Here's a visual summary of the four layers of the TCP/IP reference model, along<br>
with some well-known protocols for each layer:</p>
<p>
  <img src="./image-network-models-tcp-ip.svg" style="width: 100%; height:
  auto;">
</p>
<p>Let's look at what each layer of the reference model includes.</p>
<h3 id="application">Application</h3>
<p>The <em>Application Layer</em> includes protocols related to user-facing data. Some of<br>
the protocols that's we've discussed, like <em>HTTP</em> and <em>FTP</em>, operate in this<br>
layer. The TCP/IP model doesn't care what type of application data is used;<br>
<strong>whatever</strong> is transmitted from the Transport Layer is considered Application<br>
Layer data.</p>
<h3 id="transport">Transport</h3>
<p>The <em>Transport Layer</em> includes (you guessed it) transport protocols! We've<br>
already discussed the two best-known: <em>TCP</em> and <em>UDP</em>. This layer focuses on<br>
connectivity between clients and servers, and relies on the lower layers to<br>
establish network connectivity.</p>
<h3 id="internet">Internet</h3>
<p>The <em>Internet Layer</em> is where IP lives. Data is processed in <em>packets</em> on this<br>
layer, and routing is primarily handled with IP addresses. The Internet layer<br>
focuses mostly on connecting separate networks together.</p>
<h3 id="link">Link</h3>
<p>The <em>Link Layer</em> includes our lower-level communication standards. Link Layer<br>
protocols aren't concerned with the type of data being transported, but instead<br>
focus on getting data from one local network resource to another. We jump up to<br>
the Internet layer when dealing with resources on other networks.</p>
<blockquote>
<h3 id="fifth-layer">Fifth layer?</h3>
<p>Despite the RFC specifying four layers for the TCP/IP model, you may encounter<br>
resources detailing a five layer model for TCP/IP instead! The &quot;fifth layer&quot;<br>
is usually the <em>Physical</em> layer. This helps us separate electrical concepts<br>
like transmission across wires from data-oriented concepts like MAC addresses,<br>
but isn't an official reference model from the IETF. TCP/IP doesn't explicitly<br>
include any physical mediums, so thinking of this as a fifth layer can be<br>
helpful.</p>
</blockquote>
<h2 id="translating-layers-to-data">Translating layers to data</h2>
<p>Layers provide a mental model we can use to think about how interactions across<br>
networks occur. It's important to remember that these are &quot;best fit&quot; models,<br>
though: they translate loosely to our actual data. Some protocols may cross<br>
layers, and some companies will adjust these models to fit their own internal<br>
implementations. Ultimately, these layers provide a form of shared communication<br>
between professionals. You can count on another engineer understanding what an<br>
&quot;Application Layer issue&quot; means, even if your own definitions differ slightly!</p>
<p>We often refer to <em>encapsulation</em> when describing how layers map to our data.<br>
This means higher layers are <em>encapsulated</em>, or wrapped, in lower layers. For<br>
example, a Transport Layer <em>segment</em> includes Application Layer data in its<br>
payload, and a Link Layer <em>frame</em> includes the whole stack! Here's an example:</p>
<p>
  <img src="./image-network-models-encapsulation.svg" style="width: 100%;
  height: auto;">
</p>
<p>As we'll see, alternative networking reference models may define layers as<br>
beginning/ending at different points in our data. However, the general idea is<br>
shared across models: lower layer data units include data for higher layers in<br>
their payloads.</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>When it comes to technical concepts, it's <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html">&quot;reference models all the way<br>
down&quot;</a>! These new ways of thinking about topics we've already explored will<br>
help you communicate the concepts more clearly, and help you navigate problems<br>
that may be deeper than your own code.</p>
<p>You should feel confident:</p>
<ul>
<li>naming each of the four canonical TCP/IP reference model layers,</li>
<li>explaining why these layers were defined,</li>
<li>and relating these layers to the data being transferred on a network.</li>
</ul>
<hr>
<h1 id="a-crash-course-in-binary-and-hexadecimal-notation">A Crash Course in Binary and Hexadecimal Notation</h1>
<p>As we study networking we are going to be investigating a very low level of<br>
computing compared to the JavaScript programming we've been doing so far.  We<br>
are moving closer to hardware, and so we will be exposed to some new numbers,<br>
formatted as binary or hexadecimal.</p>
<h2 id="binary">Binary</h2>
<p>At the lowest level, a computer just speaks two values, <code>1</code> and <code>0</code>.  These are<br>
usually represented by two different voltages inside an integrated circuit known<br>
as a CPU (Central Processing Unit).  Everything that you do on a computer,<br>
writing and running your JavaScript code, watching videos online, chatting or<br>
posting on social media, or playing a video game, are at a fundamental level<br>
just 1's and 0's being processed by an integrated circuit.</p>
<p>So, what is binary? To understand this, we need to talk about bases.</p>
<h3 id="bases">Bases</h3>
<p>What's a base?  It turns out there's not just one number system.  The number<br>
system human beings have used for thousands of years is <strong>base 10</strong>.  This means<br>
we count using the Arabic digits 0 through 9.  The reason we use base 10? It<br>
should be pretty obvious. The majority of human beings have ten fingers.  So<br>
naturally we invented a counting system that used 10 digits.  If we ever meet<br>
aliens from another planet that only have say, six digits, they might indeed use<br>
<strong>base 6</strong>.</p>
<p>As it turns out, the base that computers speak is <strong>base 2</strong>. This derives<br>
directly from the fact that transistors (which is what all integrated circuits<br>
are made of) have two voltage states.  You can use <strong>base 2</strong> to perform<br>
mathematical calculations and because of this all computing at a fundamental<br>
level is base 2.</p>
<h3 id="base-2">Base 2</h3>
<p>So what does base 2 look like? Well if base 10 contains the digits 0 through 9,<br>
then base 2 contains the digits 0 through 1.</p>
<p>If you remember from your early math education, decimal (another word for base<br>
10) numbers can be divided into <em>places</em>.</p>
<p>For example, given the number 42, the number breaks down into the following<br>
<em>places</em>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Place</th>
<th style="text-align:right">1000</th>
<th style="text-align:right">100</th>
<th style="text-align:right">10</th>
<th style="text-align:right">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Digit</strong></td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
<td style="text-align:right">4</td>
<td style="text-align:right">2</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>(4 * 10) + (2 * 1) = 42
</div></code></pre>
<p>For binary, we instead have the following places, and the number 42 breaks down<br>
this way:</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Place</strong></th>
<th style="text-align:right">128</th>
<th style="text-align:right">64</th>
<th style="text-align:right">32</th>
<th style="text-align:right">16</th>
<th style="text-align:right">8</th>
<th style="text-align:right">4</th>
<th style="text-align:right">2</th>
<th style="text-align:right">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Digit</strong></td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div>(128 * 0) + (64 * 0) + (32 * 1) + (16 * 0) + (8 * 1) + (4 * 0) + (2 * 1) = 42
</div></code></pre>
<p>Or since we can simplify the zeros to 0 and the ones to 1, we can calculate this<br>
much more simply by just adding up the places that contain a 1.</p>
<pre class="hljs"><code><div>32 + 8 + 2 = 42
</div></code></pre>
<p>This is a good shorthand way of calculating a binary number in your head as long<br>
as you memorize the bases.</p>
<h2 id="bits-and-bytes">Bits and Bytes</h2>
<p>So inside computers we often call a single digit a <strong>bit</strong>. A bit can be either<br>
<strong>on</strong> (1) or <strong>off</strong> (0).</p>
<p>A sequence of 8 bits is known as a <strong>byte</strong>.</p>
<p>So our 42 example is a single byte since it contained 8 bits:</p>
<p><code>00101010</code></p>
<p>There are also some multiples of bytes computer science borrowed from the metric<br>
system, although with confusing results since the metric system is Base 10,<br>
while computing is Base 2.</p>
<table>
<thead>
<tr>
<th>Unit</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kilobyte</td>
<td>1000 bytes</td>
</tr>
<tr>
<td>Megabyte</td>
<td>1000<sup>2</sup> bytes</td>
</tr>
<tr>
<td>Gigabyte</td>
<td>1000<sup>3</sup> bytes</td>
</tr>
<tr>
<td>Terabyte</td>
<td>1000<sup>4</sup> bytes</td>
</tr>
<tr>
<td>Petabyte</td>
<td>1000<sup>5</sup> bytes</td>
</tr>
<tr>
<td>Exabyte</td>
<td>1000<sup>6</sup> bytes</td>
</tr>
<tr>
<td>Zettabyte</td>
<td>1000<sup>7</sup> bytes</td>
</tr>
<tr>
<td>Yottabyte</td>
<td>1000<sup>8</sup> bytes</td>
</tr>
</tbody>
</table>
<p>This system worked fine until computer storage got very large.  Manufacturers of<br>
hard drives would use Base 10, while Operating Systems would often use Base 2.<br>
The discrepancy between something like the gigabyte in base 2 vs base 10 was<br>
very large.</p>
<blockquote>
<p>1 Gigabyte in base 10 = 1,000,000,000 bytes 1 Gigabyte in base 2 =<br>
1,073,741,824 bytes</p>
</blockquote>
<p>That's 73.7 Megabytes of difference! With a Terabyte it got even worse.</p>
<blockquote>
<p>1 Terabyte in base 10 = 1,000,000,000,000 bytes 1 Terabyte in base 2 =<br>
1,099,511,627,776 bytes</p>
</blockquote>
<p>For a whopping 99.5 Gigabytes of difference.</p>
<p>Something had to be done.  So now we have two different sets of terminology one<br>
for Base 10 and one for Base 2.</p>
<table>
<thead>
<tr>
<th>Base 10</th>
<th>Abbr</th>
<th>Value</th>
<th>Base 2</th>
<th>Abbr</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kilobyte</td>
<td>kB</td>
<td>1000 bytes</td>
<td>Kibibyte</td>
<td>KiB</td>
<td>1024 bytes</td>
</tr>
<tr>
<td>Megabyte</td>
<td>MB</td>
<td>1000<sup>2</sup> bytes</td>
<td>Mebibyte</td>
<td>MiB</td>
<td>1024<sup>2</sup> bytes</td>
</tr>
<tr>
<td>Gigabyte</td>
<td>GB</td>
<td>1000<sup>3</sup> bytes</td>
<td>Gibibyte</td>
<td>GiB</td>
<td>1024<sup>3</sup> bytes</td>
</tr>
<tr>
<td>Terabyte</td>
<td>TB</td>
<td>1000<sup>4</sup> bytes</td>
<td>Tebibyte</td>
<td>TiB</td>
<td>1024<sup>4</sup> bytes</td>
</tr>
<tr>
<td>Petabyte</td>
<td>PB</td>
<td>1000<sup>5</sup> bytes</td>
<td>Pibibyte</td>
<td>PiB</td>
<td>1024<sup>5</sup> bytes</td>
</tr>
<tr>
<td>Exabyte</td>
<td>EB</td>
<td>1000<sup>6</sup> bytes</td>
<td>Exbibyte</td>
<td>EiB</td>
<td>1024<sup>6</sup> bytes</td>
</tr>
<tr>
<td>Zettabyte</td>
<td>ZB</td>
<td>1000<sup>7</sup> bytes</td>
<td>Zebibyte</td>
<td>ZiB</td>
<td>1024<sup>7</sup> bytes</td>
</tr>
<tr>
<td>Yottabyte</td>
<td>YB</td>
<td>1000<sup>8</sup> bytes</td>
<td>Yobibyte</td>
<td>YiB</td>
<td>1024<sup>8</sup> bytes</td>
</tr>
</tbody>
</table>
<p>Still to this day, you will hear people refer to the base 2 versions as Kilobyte<br>
or Megabyte.  Often it's hard to determine what unit is being used when<br>
manufacturers advertise the size of hard drives or memory. Worse, Operating<br>
Systems often display inconsistent numbers throughout their many displays of how<br>
big disks or files are.</p>
<h2 id="another-useful-base">Another useful base</h2>
<p>Another useful base in computing is <strong>Base 16</strong> also known as <em>hexadecimal</em>.</p>
<p>Why is this useful? This is use because hexadecimal can provide a shorter, more<br>
human-readable version of binary.</p>
<p>So if base 10 goes from the digits 0 through 9, what are we going to do? There<br>
aren't 16 digits...</p>
<p>The letters A through F are here to rescue us from this. The available digits<br>
for hexadecimal are <em>0 through F</em>, where <code>A</code> is <code>10</code> decimal and <code>F</code> is <code>15</code><br>
decimal.</p>
<pre class="hljs"><code><div>hexadecimal: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,  A,  B,  C,  D,  E,  F
decimal:     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
</div></code></pre>
<p>It's hard to think of letters as being numbers, but in hexadecimal it's<br>
perfectly normal.</p>
<p>So how does this help us write binary numbers in a shorter form? It's because<br>
there are 8 bits in a byte, which means one byte can be expressed as <em>two</em><br>
hexadecimal digits.</p>
<p>Let's look at the <em>places</em> for hexadecimal for the decimal number 42. There's a<br>
sixteenth's place and a one's place in this example.</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Place</strong></th>
<th style="text-align:right">16</th>
<th style="text-align:right">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Digit</strong></td>
<td style="text-align:right">2</td>
<td style="text-align:right">A</td>
</tr>
</tbody>
</table>
<p>This might seem confusing at first but just like our other base examples, this<br>
is:</p>
<pre class="hljs"><code><div>(16 * 2) + (A * 1)
</div></code></pre>
<p>However, since <code>A</code> is really <code>10</code> in decimal this resolves to this in decimal.</p>
<pre class="hljs"><code><div>(16 * 2) + (10 * 1) = 42
</div></code></pre>
<p>Using this you can see that the maximum value for a two digit hexadecimal number<br>
is <code>FF</code>, which is <code>255</code> in decimal and <code>11111111</code> in binary.</p>
<p>This happens to be the maximum value of one byte.</p>
<pre class="hljs"><code><div>FF = 255 = 11111111 = 1 byte
</div></code></pre>
<p>So instead of typing out an entire string of 1s and 0s we can write bytes as a<br>
sequence of 2 digit hexadecimal numbers. We usually separate these numbers by<br>
spaces or some other delimiter to make it clear they are a sequence of numbers:</p>
<p>For instance this sequence of numbers in decimal:</p>
<pre class="hljs"><code><div>4 8 15 16 23 42
</div></code></pre>
<p>is the following in binary:</p>
<pre class="hljs"><code><div>00000100 00001000 00001111 00010000 00010111 00101010
</div></code></pre>
<p>But in Hexadecimal it's only this:</p>
<pre class="hljs"><code><div>04 08 0F 10 17 2A
</div></code></pre>
<p>I hope you can see that this is a really compact and convenient way to represent<br>
binary numbers. The numbers are always the same length, which is good for data<br>
storage, and they can be easily translated back to binary. It might also help<br>
rescue you from <a href="https://www.businessinsider.com/the-martian-hexidecimal-language-2015-9">Mars</a>.</p>
<h3 id="the-0x-notation">The <code>0x</code> Notation</h3>
<p>Sometimes you will see hexadecimal numbers represented by prepending a <code>0x</code> to<br>
the front of them.  So our 42 would be expressed like this:</p>
<pre class="hljs"><code><div>0x2A
</div></code></pre>
<h2 id="in-javascript">In JavaScript</h2>
<p>In JavaScript, we can use <code>toString</code> on <code>Number</code> objects to convert different<br>
bases to decimal. We can supply a base as an argument to <code>toString</code>.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">Number</span>(<span class="hljs-number">42</span>).toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// 2a</span>
<span class="hljs-built_in">Number</span>(<span class="hljs-number">42</span>).toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// 101010</span>
</div></code></pre>
<p>We can also use our old friend <code>parseInt</code> with an optional second argument to<br>
convert a binary or hexadecimal string to a decimal number.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'101010'</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 42</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'2A'</span>, <span class="hljs-number">16</span>) <span class="hljs-comment">// 42</span>
</div></code></pre>
<h1 id="in-conclusion">In conclusion</h1>
<p>Binary and hexadecimal are often used in computing because computers are<br>
fundamentally base 2. As you move closer to the hardware, you encounter these<br>
more and more often.  In networking, you will see them used for IP Addresses and<br>
MAC Addresses.  We'll learn more about that when we look next at how IP<br>
Networking works in the next section.</p>
<hr>
<h1 id="internet-protocol">Internet Protocol</h1>
<p>As we dive deeper into understanding how computers communicate, a common<br>
question keeps coming up: what is &quot;the Internet&quot;, exactly? To answer this, let's<br>
discuss the <em>Internet Protocol</em>, also known as <em>IP</em>.</p>
<p>We'll cover:</p>
<ul>
<li>What IP is and why it matters to us,</li>
<li>different protocol versions and when to use them,</li>
<li>and how to identify IP data by its formatting.</li>
</ul>
<h2 id="history-of-ip">History of IP</h2>
<p>To understand where we are today, we need to look back to where we came from.<br>
Picture yourself in the United States in the late 1960s. The country is nearing<br>
the end of the &quot;space race&quot; and technology is booming. There are numerous<br>
technical teams and physical networks created as a result of recent research,<br>
but communication between them is limited. There's also a rise of different<br>
proprietary standards which are hampering growth: not every team can afford a<br>
separate terminal of each available type! How can we facilitate better<br>
collaboration with less investment required?</p>
<p>By 1974, two researchers working for <a href="https://www.iso.org/home.html">DARPA</a> think they have the answer. They<br>
propose something called the <em>Transmission Control Program</em>. It's a complex<br>
process that defines exactly how multiple networks can communicate with each<br>
other. This protocol stands out because it is:</p>
<ul>
<li><em>fault tolerant</em>: data transmitted between networks can be cached and re-sent<br>
if it fails the first time.</li>
<li><em>end-to-end</em>: there are no single central systems that can take the whole<br>
network down; each host can send/receive to others.</li>
</ul>
<p>These highlights are critical because DARPA is a military organization. They're<br>
looking for technology that could theoretically withstand a nuclear attack - and<br>
the Transmission Control Program fits the bill!</p>
<h3 id="the-great-divide">The great divide</h3>
<p>It became quickly apparent that that Transmission Control Program was too dense.<br>
The process was complicated and involved many moving parts, and other engineers<br>
raised concerns that it should be extracted into separate parts. Soon, the<br>
Transmission Control Program was divided into two separate sections:<br>
<em>Transmission Control Protocol (TCP)</em>, which was responsible for the<br>
fault-tolerance of joined networks, and <em>Internet Protocol (IP)</em>, which was<br>
responsible for the end-to-end nature of joined networks.</p>
<p>The protocols we use today have been improved over time, but still carry those<br>
names and general purposes. It's amazing to think that modern social media,<br>
video gaming, and streaming content is all dependent on 50+ year old technology!</p>
<h2 id="so-what-is-the-internet-exactly">So what is the Internet, exactly?</h2>
<p>The Internet can be loosely defined as &quot;a series of <em>internetworked</em> systems&quot;.<br>
Here's a practical example of what we mean by that:</p>
<blockquote>
<p>Imagine every building in your town has a parking garage. Each garage is owned<br>
by a different company and uses custom entry sensors. These sensors prefer<br>
certain vehicle types: one garage for luxury sports cars only, another that will<br>
only allow motorcycles. You may need to park in the garage for the vehicle you<br>
own, then walk a lot. Otherwise, you'd have to own a different vehicle for each<br>
garage! Oh no! We'd consider this an &quot;isolated&quot; model: each garage works fine<br>
by itself, but patrons of one garage may not park elsewhere, and none of the<br>
garages are really meeting their full potential.</p>
<p>Now imagine the garages remove their sensors. Suddenly you can park anywhere<br>
you'd like. Your motorcycle and your neighbor's school bus can exist<br>
harmoniously in any garage, and you can travel from garage to garage in any<br>
vehicle you'd like. We'd consider this an &quot;internetworked&quot; model: each garage's<br>
patrons may travel to any other garage and while the particular entrance/exit<br>
policies may differ, drivers can rest assured knowing they'll fit anywhere.</p>
</blockquote>
<p>The Internet Protocol opened the door for this internetworked model in<br>
computing. Now a network in New York City using one vendor's computers could<br>
seamlessly communicate with a network in London from a different vendor! This<br>
connectivity led to the birth of the Internet, which is itself <em>a series of<br>
interconnected networks sharing data</em>.</p>
<h2 id="packet-switching">Packet-Switching</h2>
<p>IP data is transmitted in a format known as a <em>packet</em>. A packet uses a data<br>
format we've seen before: metadata in <em>headers</em>, and a <em>body</em> with content. The<br>
headers are used to get the packet to its destination, while the body contains<br>
the information we'd like to transfer.</p>
<p>We refer to IP's communication style as <em>packet-switching</em>. This is when a<br>
message is split up into separate &quot;packets&quot;, delivered to a destination, and<br>
reassembled as appropriate. Remember that IP's primary responsibility as part of<br>
the Internet's &quot;double threat&quot;, TCP/IP, is maintaining an <em>end-to-end</em> state.<br>
For this reason, IP isn't concerned about whether packets are received by the<br>
client in sequential order, and may sometimes even lose packets altogether while<br>
in transit!</p>
<blockquote>
<h3 id="a-crash-course-in-bits--bytes">A crash course in bits &amp; bytes</h3>
<p>Most of the protocols we'll cover measure their data in <em>bits</em>. We represent a<br>
bit as a single binary digit, either 1 or 0. Since data gets long, we have<br>
some larger units available as well! We'll sometimes describe data sizes in<br>
<em>bytes</em>. A byte is eight bits.</p>
<p>For example, &quot;01001&quot; is five bits, and a piece of data that's 32 bits long<br>
could also be described as &quot;4 bytes&quot;.</p>
</blockquote>
<h2 id="ip-versions">IP Versions</h2>
<p>The Internet Protocol has evolved over time, but two versions stand out as the<br>
most used &amp; important to us: version 4 and version 6. We often refer to these as<br>
<em>IPvX</em>, where <em>X</em>, is the version number.</p>
<h3 id="ipv4">IPv4</h3>
<p>The best known version of the Internet Protocol is <em>IPv4</em>. This version was<br>
used when TCP/IP was finalized by DARPA in 1983, and it's still the most-used<br>
protocol version online.</p>
<p>An IPv4 packet's header consists of at least 13 <em>fields</em>, or sequences of binary<br>
bits. These fields start with a version identifier (<code>0100</code>, or &quot;4&quot; in binary),<br>
continue with 10 sequences that define things like the length of the header and<br>
protocol type contained in the body, and wrap up with source and destination<br>
addresses for the packet. IPv4 also includes an allowance for a 14th optional<br>
header field called &quot;Options&quot; that can contain extra metadata about the packet's<br>
content, but it's not often used. An IPv4 header without options will be 20<br>
bytes (160 bits).</p>
<p>It's hard to visualize a header since it's essentially just a long string of 1s<br>
and 0s. Instead of trying to cram it all into one line to study, we can split<br>
it into specified widths and stack them. Here's a stacked diagram of the IPv4<br>
header:</p>
<p>
  <img src="./image-ip-ipv4-headers.svg" style="width: 100%; height: auto;">
</p>
<h3 id="ipv4-addresses">IPv4 Addresses</h3>
<p>IPv4 addresses are composed of 4 <em>octets</em>, or 8-bit binary numbers. We usually<br>
represent them like this:</p>
<pre class="hljs"><code><div>192.18.1.1
</div></code></pre>
<p>This is the same as <code>11000000.00010010.00000001.00000001</code> in binary notation,<br>
but that's a lot harder to read! IPv4 supports around 4 billion unique<br>
addresses.</p>
<h3 id="ipv6">IPv6</h3>
<p>The &quot;4 billion unique address&quot; limit seemed almost infinite in the earliest days<br>
of the Internet, but today it's easy to see how we might use up that few<br>
addresses! Seeing this <em>address exhaustion</em> on the horizon, Internet researchers<br>
began concocting a new protocol version, one that would allow more addresses, in<br>
the mid 1990's. By 2017, the new protocol was an official standard: <em>IPv6</em>.</p>
<p>IPv6 uses a totally different packet header format than IPv4, though they share<br>
a few fields. It only uses 8 header fields, and supports optional &quot;extension<br>
headers&quot; that come after these 8 fields, as opposed to IPv4's large &quot;Options&quot;<br>
block.</p>
<p>The 8 fields IPv6 uses, in order, are:</p>
<p>
  <img src="./image-ip-ipv6-headers.svg" style="width: 100%; height: auto;">
</p>
<ul>
<li><em>Version</em>
<ul>
<li><code>0110</code>, or &quot;6&quot; in binary notation</li>
</ul>
</li>
<li><em>Traffic Class</em>
<ul>
<li>used to identify different types of packets, like video or phone data</li>
</ul>
</li>
<li><em>Flow Label</em>
<ul>
<li>an experimental option used for adding packet sequencing into IP</li>
</ul>
</li>
<li><em>Payload Length</em>
<ul>
<li>lets the reciever know how large the data in the packet will be</li>
</ul>
</li>
<li><em>Next Header</em>
<ul>
<li>Usually identifies the protocol type of the packet's data, but may<br>
indicate the first extension header (if present)</li>
</ul>
</li>
<li><em>Hop Limit</em>
<ul>
<li>A means of preventing packets from being passed around routers forever,<br>
this field will be decremented by 1 every time the packet passes through<br>
an intermediary (like a router)</li>
</ul>
</li>
<li><em>Source Address</em>
<ul>
<li>Where the packet originated</li>
</ul>
</li>
<li><em>Destination Address</em>
<ul>
<li>Where the packet is heading</li>
</ul>
</li>
</ul>
<p>These headers have a fixed length of 40 bytes (320 bits).</p>
<h3 id="ipv6-addresses">IPv6 Addresses</h3>
<p>Notice that IPv6 packets have fewer headers, but are double the length of IPv4<br>
headers! This is primarily due to IPv6 addressing, which allows <strong>dramatically</strong><br>
more address space than IPv4. How many more addresses?</p>
<p>IPv4 supports <strong>~4 billion (4x10<sup>9</sup>)</strong> addresses.</p>
<p>IPv6 supports <strong>~350 undecillion (3.5×10<sup>38</sup>)</strong> addresses.</p>
<p>That's a billion times a billion more addresses! It's even more addresses than<br>
grains of sand in all the world's beaches &amp; deserts (7.5x10<sup>18</sup>,<br>
according to <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html">the University of Hawaii</a>).</p>
<p>It handles this by quadrupling the number of bits in an address. IPv4 uses 32<br>
bits, while IPv6 uses 128 bits. Remember that these bits are binary, so adding<br>
additional bits exponentially increases the number of permutations.</p>
<p>This new address space also required a new notation. Instead of the &quot;four dotted<br>
decimal&quot; notation of IPv4, IPv6 uses &quot;eight colon-ed hexadecimal&quot;. Here's an<br>
example IPv6 address:</p>
<pre class="hljs"><code><div>2600:6c5e:157f:d48c:138f:e0ba:6fa7:d859
</div></code></pre>
<p>The same address in binary is:</p>
<pre class="hljs"><code><div>0010011000000000:0110110001011110:0001010101111111:1101010010001100:0001001110001111:1110000010111010:0110111110100111:1101100001011001
</div></code></pre>
<p>It's easy to see how we added so many extra addresses! That said, IPv6 is much<br>
more difficult to read by humans. You can read some neat rules for making IPv6<br>
addresses easier to read on <a href="https://en.wikipedia.org/wiki/IPv6#Address_representation">Wikipedia</a>.</p>
<h3 id="special-addresses">Special addresses</h3>
<p>Both popular versions of the Internet Protocol include space for some special<br>
addresses that you should quickly recognize. The main one you'll encounter is<br>
called the <em>loopback</em> address. This is the identifier for your current machine.<br>
You'll see it repeatedly while developing because you'll navigate your browser<br>
there to access your own servers! You may also hear this referred to as<br>
<em>localhost</em>.</p>
<p>In IPv4 the loopback address is <code>127.0.0.1</code>. In IPv6, the loopback is <code>::1</code>.</p>
<p>There's also an <em>&quot;all interfaces&quot;</em> address. This address is used to catch any<br>
incoming requests regardless of intended destination. It's only used by the<br>
local machine: you would never send a packet to the &quot;all interfaces&quot; address,<br>
but a server that is listening on that address would see all incoming packets.</p>
<p>For IPv4, the &quot;all interfaces&quot; address is <code>0.0.0.0</code>. For IPv6, it's simply <code>::</code>.</p>
<p>Remember that the loopback and &quot;all interfaces&quot; address are not interchangeable!<br>
This is a common misconception you may encounter in tutorials online, and might<br>
be a trick question during a technical interview. If you're ever asked to<br>
connect to <code>localhost</code>, make sure you use the loopback.</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>Whew! The Internet Protocol is a dense topic, but a little familiarity will go a<br>
long way when you're debugging server connections. After reading this lesson,<br>
you should be able to:</p>
<ul>
<li>provide a rough history of where the Internet Protocol came from,</li>
<li>compare/contrast the two most popular IP versions (4 &amp; 6),</li>
<li>identify an IP packet's version by its headers,</li>
<li>and name the localhost addresses for both versions.</li>
</ul>
<hr>
<h1 id="transport-protocols">Transport Protocols</h1>
<p>Between HTTP and IP, we find an extra layer of information. We often refer to<br>
this as the <em>transport layer</em> of communication, and protocols used in it are<br>
referred to as <em>transport protocols</em>.</p>
<p>There are myriad of transport protocols available, but we're going to cover the<br>
two biggest: <em>TCP</em> and <em>UDP</em>. We'll dive into:</p>
<ul>
<li>why we need transport protocols,</li>
<li>the differences between TCP and UDP,</li>
<li>and where each protocol is used today.</li>
</ul>
<h2 id="what-exactly-are-we-transporting">What exactly are we transporting?</h2>
<p>We've already briefly mentioned the <em>Transmission Control Protocol (TCP)</em> when<br>
discussing the history of the <em>Internet Protocol (IP)</em>. Both TCP &amp; IP made up<br>
the original <em>Transmission Control Program</em> developed at DARPA in the 1970s.<br>
We've dug deep into IP now, and we have some understanding of HTTP. Why do we<br>
need more protocols?</p>
<p>Let's provide a practical example. Think about the process of delivering a<br>
package. Floor pickers take your package from a warehouse onto the back of a<br>
truck, and a dispatcher sends that truck to your house. There's a place on your<br>
porch just waiting for that package. How, then, does your package make it across<br>
the very last leg of its journey? Whoops - we forgot the delivery person!</p>
<p>Transport protocols act as our &quot;delivery person&quot;. IP is concerned with<br>
machine-to-machine communication, and HTTP is designed for<br>
application-to-application communication. Transport protocols bridge the gap and<br>
help our data cover the last mile between the network and software.</p>
<h3 id="ports">Ports</h3>
<p>Like every other part of the internetworking process, transport protocols use<br>
their own unique form of addressing. We call these <em>ports</em>. Ports are virtual<br>
interfaces that allow a single device to host lots of different applications &amp;<br>
services. By lots, we mean a whole bunch - there are 65536 separate ports<br>
available to each transport protocol!</p>
<p>Ports are represented by numbers: <code>port 80</code>, <code>port 51234</code>, etc. If we know both<br>
the IP address and port we'd like to connect to, we can use a special notation<br>
where both are joined by a colon:</p>
<pre class="hljs"><code><div>192.168.1.1:8080
</div></code></pre>
<p>This would point to port <code>8080</code> on a network interface with an IP address of<br>
<code>192.168.1.1</code>. We refer to an IP address &amp; port written together in this way as<br>
a <em>socket</em>.</p>
<h2 id="tcp">TCP</h2>
<p>The most common transport protocol used is <em>TCP</em>. TCP is a connection-oriented<br>
protocol, meaning it establishes a connection between two sockets. This<br>
connection acts as safeguard from other error-prone protocols underneath it,<br>
including <em>IP</em> and <em>Ethernet</em>. Pieces of data sent via TCP (referred to as<br>
<em>segments</em>) respect a strict order and verify when they have been received. This<br>
means that data can't be &quot;lost&quot; across a TCP connection: if a segment is<br>
received out of order, the receiver will ask the transmitter to re-send the<br>
missing segment. This behavior makes TCP a <em>reliable</em> protocol.</p>
<p>We'll dive deeper into exactly how TCP verifies data &amp; forms connections in a<br>
future lesson. For now, remember that &quot;TCP == reliability&quot;. Any time it's<br>
critical that data arrives ordered and in full, TCP's the way to go! You'll see<br>
TCP used as the underlying connection for HTTP, file transfers, and media<br>
streaming. In all of these cases, missing data would result in corrupt files and<br>
unreadable data.</p>
<p>Because of everything TCP offers us, it's a relatively &quot;heavy&quot; protocol to use.<br>
Messages may take a bit longer to transfer than they would via other protocols,<br>
but you can be confident that your message has been received the way you<br>
intended it. This inherent slowness means applications using TCP may <em>buffer</em><br>
data, or wait until a certain amount has been received before passing it to the<br>
user. You've probably seen this happen on your favorite video sharing sites!</p>
<h2 id="udp">UDP</h2>
<p>The <em>User Datagram Protocol (UDP)</em> arrived on the scene a few years after TCP.<br>
Scientists working with TCP found that they sometimes didn't need all the order<br>
and reliability that TCP provided, and they were willing to trade that for raw<br>
speed. UDP is connection-less and provides no verification for whether data is<br>
received. Because of this, we refer to it as an <em>unreliable</em> protocol.</p>
<p>Hold on, though! By &quot;unreliable&quot;, we certainly don't mean &quot;useless&quot;. UDP is used<br>
in lots of familiar places: real-time video sharing, voice-over-IP phone calls,<br>
and DNS all rely on UDP as their transport protocol of choice. These services<br>
prioritize speed over reliability, so it makes sense that they would forego<br>
TCP's additional lag. If some data is lost along the way, that's okay - for<br>
example, you might just see lower-quality video for a moment.</p>
<p>Unreliable systems are valuable outside the world of transport protocols as<br>
well! Consider the postal service: most letters are sent without any sort of<br>
delivery confirmation or guarantee of arrival. It's up to the sender and/or<br>
recipient to manage expectations of when a letter ought to have arrived. This is<br>
similar to UDP. Data will be transmitted, and most will arrive, but if either<br>
side needs more reliability than that they will have to implement it themselves.</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>Transport protocols fill a gap in our current understanding of networks. They<br>
help us get data up from the network to our applications, and they give us a few<br>
options for fault-tolerance versus performance.</p>
<p>After reading this lesson, you should feel comfortable:</p>
<ul>
<li>explaining what transport protocols are and why we need them,</li>
<li>comparing &amp; contrasting TCP &amp; UDP,</li>
<li>and discussing use cases for each of these two major protocols.</li>
</ul>
<hr>
<h1 id="surveying-your-domain">Surveying Your Domain</h1>
<p>We've covered how connected devices communicate with each other, but we're<br>
missing a key piece: where humans fit into the equation! After all, the Internet<br>
would be a much more boring place if we had to remember the IP address of every<br>
website we chose to visit.</p>
<p>Let's look into the <em>Domain Name System</em>, a method of translating long numeric<br>
identifiers into friendly, human-readable addresses. We'll cover:</p>
<ul>
<li>how the Domain Name System came to be,</li>
<li>how a URL gets translated to an IP address,</li>
<li>and the different types of information stored by the system.</li>
</ul>
<h2 id="what-is-dns">What is DNS?</h2>
<p>The <em>Domain Name System</em> (often just referred to as <em>DNS</em>) is a distributed<br>
approach to providing easily-understood names for internetworked devices.<br>
Practically, it's similar to a phone book: DNS allows us to look up a specific<br>
IP address by its <em>domain</em>.</p>
<p>In the early days of computer networking, connecting to another computer was a<br>
manual, complex process. A user would need very specific addresses to find the<br>
networked resource they were looking for, and those addresses were difficult to<br>
read/remember! A scientist named <a href="https://www.iso.org/home.html">Elizabeth Feinler</a>, working with ARPA in<br>
the early 1970's, saw a way to help. She started out with a simple text file<br>
listing computer names by their numeric addresses. This file grew in size as<br>
more systems joined ARPANET, and Elizabeth expanded her operation from a text<br>
file to a whole organization dedicated to keeping an up-to-date list of<br>
hostnames &amp; IP addresses.</p>
<p>By the 1980's, it was clear that one organization wasn't enough to manage the<br>
growing Internet. The Domain Name System was invented as a way to distribute the<br>
work to numerous organizations, lightening the load and allowing much more rapid<br>
growth. The first DNS name server was written in 1984, and the rest is history!</p>
<p>DNS is one of the most important parts of allowing the Internet to grow so<br>
rapidly. It's perfect for quick scaling because it is both simple (relying on<br>
specifically-formatted text files) and distributed (redundant across numerous<br>
servers).</p>
<h3 id="domains">Domains?</h3>
<p>We've mentioned domains before today, but without much detail. Let's dive a<br>
little deeper into that term. A website's <em>domain</em> refers to the &quot;friendly&quot; name<br>
for the website's <em>host</em>, or the server providing the site's content. A domain<br>
differs from a URL in that the domain is only the server's identifier, not other<br>
application or protocol-related data in the URL.</p>
<p>Here's a breakdown of an average URL. We've highlighted the domain in green and<br>
labelled each part of the URL underneath:</p>
<p>
  <img src="./image-ip-dns-domain.svg" style="width: 100%; height: auto;">
</p>
<p>A <em>domain name</em> can be split into a few parts:</p>
<ul>
<li>
<p>The <em>top-level domain (TLD)</em> is the last part of the domain, appearing just<br>
before the URL begins pointing at application routes (usually indicated with<br>
<code>/</code>'s) or query parameters (indicated with a <code>?</code> and <code>&amp;</code>'s). The best known<br>
TLDs are <code>.com</code>, <code>.net</code>, and <code>.org</code>. TLDs are managed by special organizations<br>
that have demonstrated the ability to handle the immense workload involved,<br>
often known as <em>domain registries</em>. These registries may be government<br>
entities (for example, <code>.gov</code> is managed by the <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html">General Services Agency</a>)<br>
or private companies that were awarded the privilege by <a href="https://en.wikipedia.org/wiki/IPv6#Address_representation">ICANN</a>.</p>
</li>
<li>
<p>To the left of the TLD, separated by a dot, is the <em>second-level domain</em>.<br>
You'll often hear the TLD &amp; second-level domain lumped together as &quot;the<br>
domain&quot;. This is the name most people associate with the website. Through<br>
<em>domain registrars</em>, consumers can purchase second-level domains. The<br>
registrar maintains a listing of each purchase.</p>
</li>
<li>
<p>Some websites will have additional domains to the left of the second-level<br>
domain. These can be referred to by their formal names (<em>third-level domain</em>,<br>
<em>fourth-level domain</em>, etc.) but are often informally referred to as<br>
<em>subdomains</em>. The best-known subdomain is <code>www</code>, though this is less-used on<br>
newer sites. Subdomains can usually be freely created by the consumer.</p>
</li>
</ul>
<h2 id="how-the-magic-happens">How The Magic Happens</h2>
<p>DNS does one thing really well: identifying connected devices by friendly names.<br>
How exactly does this work?</p>
<p>It all goes back to the magic word: <em>domain</em>. Each individual domain is<br>
represented by a set of <em>name servers</em>, which store information about the<br>
domain's registered subdomains. Name servers will direct a client where they<br>
need to go - even if that's another name server! We refer to this process of<br>
working out which name server we need as <em>resolution</em>. Eventually, we'll reach a<br>
name server that can tell us the specific IP address for the full domain. We<br>
refer to this as the <em>authoritative name server</em> for our domain. It has the<br>
final say!</p>
<p>When trying to resolve a domain name, we start from the rightmost part (the TLD)<br>
and work our way to the left. We'll stop once we've reached an authoritative<br>
server that can give a direct address for the domain we're seeking. Intermediate<br>
servers should be able to point us to the most-relevant name server to continue<br>
our search (usually, the next domain to the left). We can think of this as a<br>
conversation between the client and the available name servers for our domain,<br>
each one moving us closer to our goal.</p>
<p>Here's a practical example of how DNS is used to discover the authoritative name<br>
server for the fictional URL <code>https://students.appacademy.io</code>:</p>
<p>
  <img src="./image-ip-dns-resolution-chat.svg" style="width: 100% height: auto;">
</p>
<p>Looking for something a little more whimsical? <a href="https://dnsimple.com/">DNSimple</a> has a <a href="https://howdns.works/ep1/">fantastic<br>
webcomic</a> detailing the journey of a domain resolver. Check it out!</p>
<h2 id="dns-records">DNS Records</h2>
<p>We can see how DNS works, but what does it actually look like? It's not much<br>
different than it was at the very beginning! Each name server maintains a <em>zone<br>
file</em>: a text file containing host names, IP addresses, and resource types.<br>
Here's an example of a simple zone file:</p>
<pre class="hljs"><code><div><span class="hljs-variable">$TTL</span> 299
my-site.com.    IN  SOA     ns1.cloudflare.com. dns.cloudflare.com. 2032032092 10000 2400 604800 3600
my-site.com.    IN  NS      ns1.my-site.com.
my-site.com.    IN  NS      ns2.my-site.com.
my-site.com.    IN  A       104.28.31.159
my-site.com.    IN  A       104.28.30.159
my-site.com.    IN  AAAA    2606:4700:30::681c:1f9f
my-site.com.    IN  AAAA    2606:4700:30::681c:1e9f
www             IN  CNAME   my-site.com.
ns1             IN  A       104.28.31.150
ns2             IN  A       104.28.30.150
my-site.com.    IN  MX      10 mail.google.com.
</div></code></pre>
<p>Each line in a zone file includes the affected domain, type of record on that<br>
line, and the data for that record. Let's discuss some of the most common DNS<br>
record types in the order we see them above:</p>
<h3 id="soa"><code>SOA</code></h3>
<p>The <em>SOA</em> record represents the <strong>S</strong>tart <strong>O</strong>f <strong>A</strong>uthority. This record lets<br>
us know which name server is the <em>master</em>, or primary authority, for the domain<br>
we're querying. The SOA record is the minimum requirement in a zone file - every<br>
name server will return this record, if nothing else!</p>
<h3 id="ns"><code>NS</code></h3>
<p><em>NS</em> records point to name servers for the zone. Most zones will have at least<br>
two NS records for redundancy. Remember that one of DNS's strengths is that it's<br>
distributed. If one name server loses power or becomes disconnected, we don't<br>
lose access to the zone.</p>
<h3 id="a--aaaa"><code>A</code> / <code>AAAA</code></h3>
<p><em>A</em> records are the most important DNS records present. They map a resource<br>
directly to an IP address. This is the core of what DNS is for: connecting the<br>
domain directly to a machine. <code>A</code> records are used for IPv4 addresses, while<br>
<code>AAAA</code> records perform the same function for IPv6.</p>
<h3 id="cname"><code>CNAME</code></h3>
<p>The <em>CNAME</em> record acts as an alias, linking one domain to another. In our<br>
example above, we're saying that <code>www.my-site.com</code> should point at the same<br>
resource as <code>my-site.com</code>. Notice that the <code>www</code> doesn't have a <code>.</code> after it.<br>
This means it's a <em>relative</em> reference, and the additional parts of the domain<br>
for this zone (<code>my-site.com.</code>) are implied. When a domain in zone file ends in a<br>
<code>.</code> we can treat it as an <em>absolute</em> reference with no unwritten subdomains.</p>
<h3 id="mx"><code>MX</code></h3>
<p>DNS: It's not <strong>just</strong> for websites! <em>MX</em> records, short for <strong>M</strong>ail<br>
E<strong>x</strong>changer, are used by e-mail clients to direct messages to the appropriate<br>
mail servers. These records let you send messages to &quot;friend@gmail.com&quot; instead<br>
of having to remember &quot;friend@123.45.67.89&quot;!</p>
<h3 id="metadata">Metadata</h3>
<p>There's one piece we've overlooked in our example zone file above: the first<br>
line. <code>$TTL 299</code> refers to the <em>Time to Live (TTL)</em> for our records. This is a<br>
measure of how long a record should be <em>cached</em> by a DNS name server.</p>
<p>We cache DNS queries because reading from a file can be slow! When a query comes<br>
in for a particular domain, the name server will cache the result in memory so<br>
that subsequent requests are much faster. However, this in-memory copy won't be<br>
updated if the zone file changes - yikes! The TTL lets us set how often a cached<br>
record should be discarded and read from the zone file again. This is especially<br>
important if we are pointing at a service where the IP might change frequently,<br>
like a local development environment or shared hosting service.</p>
<p>In our example, we've set the TTL for all records in the zone file to 299<br>
seconds. This means that if your current web host goes offline and you have to<br>
point your domain at a new server, the downtime won't last more than<br>
approximately five minutes. This <strong>also</strong> means that you'll be re-checking your<br>
zone file for that domain at least once every five minutes. If you're confident<br>
in your hosting and aren't making infrastructure changes, longer TTLs can result<br>
in slightly increased performance.</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>The Domain Name System is a great example of a simple process (linking names to<br>
locations) evolving over time to support greater and greater needs. It's<br>
frightening to think of how difficult navigating around the Internet would be if<br>
we didn't have DNS to make websites easily accessible!</p>
<p>Before we move on, here's a quick tip: <strong>DNS questions are popular fodder for<br>
technical interviews.</strong> You may be asked to define a particular record type or<br>
to walk through a rough outline of what happens when you type a URL into your<br>
browser and click &quot;Go&quot;. Try thinking through this process with your new<br>
knowledge!</p>
<p>After reading this lesson, you should have a better understanding of:</p>
<ul>
<li>the history and intent of DNS,</li>
<li>how to read &amp; break down a domain name,</li>
<li>and what's involved in translating domains into IP addresses.</li>
</ul>
<hr>
<h1 id="networking-hardware-getting-physical">Networking Hardware: Getting Physical</h1>
<p>We've discussed a lot of data- and internal-communication protocols, but what<br>
supports these? Let's examine some of the most important hardware you'll see<br>
while examining computer networks!</p>
<p>We'll cover:</p>
<ul>
<li>networking hardware devices and how they differ,</li>
<li>use cases for each type of device,</li>
<li>and specialized cases with integrated devices</li>
</ul>
<h2 id="three-levels-of-control">Three levels of control</h2>
<p>Network protocols mean very little if we don't have a physical way of connecting<br>
computers together! Whether it's via copper cables, fiber optics, or wireless<br>
networks, we need ways of managing communications to put those protocols into<br>
action. A quick search for &quot;networking hardware&quot; will yield a slew of results,<br>
but don't get overwhelmed! We can boil many of these devices down to three<br>
types: <em>hubs</em>, <em>switches</em>, and <em>routers</em>.</p>
<h3 id="hubs-keeping-it-simple">Hubs: keeping it simple</h3>
<p>
  <img src="./image-ip-networking-hub.svg" style="width: 100%; height: auto;">
</p>
<p>A <em>hub</em> is the simplest networking device you're likely to find in service. It<br>
performs no network management and might be better known as a &quot;signal splitter&quot;.<br>
When a hub receives data, it duplicates that data and broadcasts it to all<br>
connected devices. That's it!</p>
<p>Hubs tend to be cheap and are often found in older networks. They are usually<br>
small metal boxes with a handful of physical connectors. You can get hubs with<br>
lots of connectors, but they're usually a little smaller - think 5 or 10 instead<br>
of 30 or 40. This is due to the natural limitations a hub possesses.</p>
<blockquote>
<p>Heads up! We'll refer to the physical sockets that cables plug into as<br>
<em>connectors</em>, but you'll often hear them called <em>ports</em> instead. This can get<br>
<strong>very</strong> confusing, so be sure you're clear about the difference between<br>
virtual ports used by transport protocols and physical ports used by hardware.<br>
When in doubt, use a clearer term, like &quot;connector&quot; or &quot;jack&quot;.</p>
</blockquote>
<p>For one, a hub can't do any sort of filtering. This means every single data<br>
packet is sent to every single device, all the time. This creates a lot of<br>
unnecessary load on the network. Imagine if every time you called a friend, all<br>
of your other friends' phones rang too. Yikes! Additionally, hubs share<br>
bandwidth across devices, so heavy traffic can result in lower speeds. We'll<br>
sometimes see this problem on overloaded networks with other devices, but on a<br>
hub it's guaranteed.</p>
<p>Hubs were a helpful and necessary piece of hardware for a long time, but today<br>
there's little reason to use them. They may still be slightly cheaper than a<br>
switch, but the limitations outweigh most cost concerns. The best use for a hub<br>
now is as a temporary replacement while replacing a broken device.</p>
<h3 id="switches-traffic-control">Switches: traffic control</h3>
<p>
  <img src="./image-ip-networking-switch.svg" style="width: 100%; height:
  auto;">
</p>
<p>A step up from the hub, we find a network <em>switch</em>. Switches are &quot;intelligent&quot;<br>
hubs: they track devices connected to them, help manage network load, and can<br>
manage separate internal networks with ease! The biggest thing that separates a<br>
switch from a hub is the <em>MAC address table</em>.</p>
<p>A network switch maintains an internal address book containing the MAC addresses<br>
of the devices connected to it. Remember that data frames contain both a source<br>
and destination MAC address? This is how the switch stays up to date! It uses<br>
this data to perform one of three actions with each piece of data it receives:</p>
<ul>
<li>
<p><em>flood</em>: When a destination address is unknown, the switch will <em>flood</em><br>
received data out to all connected devices <strong>except where the data came<br>
from</strong>. When the intended recipient responds, the switch will update its MAC<br>
address table accordingly. This is how switches learn about connected devices,<br>
and it's significantly more efficient than a hub's behavior of flooding all<br>
the time!</p>
</li>
<li>
<p><em>forward</em>: When a switch already has the destination MAC address in its<br>
internal table, it can send data directly to that device. This is called<br>
<em>forwarding</em> the data. No other devices connected to the switch are made aware<br>
of this data.</p>
</li>
<li>
<p><em>filter</em>: Sometimes a switch will receive data on the same connector the data<br>
is destined for. In these cases, the switch will <em>filter</em>, or drop, the data<br>
entirely. This can be a little confusing to think about! If data arrives on<br>
the same connector it would later be sent out of, then we can assume the data<br>
was handled by some other part of our network, and the receiving switch can't<br>
do anything to help. Remember that this is very specifically related to the<br>
physical connector the data is received on: a switch will never act on data<br>
that comes in and goes out the same connector.</p>
</li>
</ul>
<p>Switches often look just like hubs, but come in a much larger range of sizes.<br>
They can be chained together to cover large networks, or a 5-connector switch<br>
might be used for a small home network. Switches have improved on hubs'<br>
limitations: they don't share bandwidth, so you'll see less impact on speed<br>
through a switch than you might through a hub.</p>
<p>If you're building a home or single-location office network today, switches are<br>
your friend. They provide lots of simple management functionality for not much<br>
cash, and they're easy to keep around.</p>
<h3 id="routers-thinking-globally">Routers: thinking globally</h3>
<p>
  <img src="./image-ip-networking-router.svg" style="width: 100%; height:
  auto;">
</p>
<p>Here's a thought experiment: let's think about what a switch for a national<br>
network might look like. Since switches can be chained together, we wouldn't<br>
need thousands of connectors - but we would need <em>lots</em> of memory! The MAC<br>
address table would need to hold entries for every computer in the country. No<br>
way!</p>
<p>Instead of trying to solve this problem with switches, we have a higher-level<br>
device: the <em>router</em>. Routers connect separate networks with each other. Instead<br>
of identifying devices via MAC address, they use IP addresses to make decisions<br>
about data.</p>
<p>A router, like a switch, maintains an internal table of addresses. This <em>routing<br>
table</em> is used to pass received data on through the network. Data may move on to<br>
another router, or the router may recognize the data and pass it to an internal<br>
switch.</p>
<p>Routers also participate in an important process called <em>NAT</em>, short for<br>
<em>Network Address Translation</em>. NAT helps minimize IP address overload by giving<br>
the router a single IP address to use for all external communication. The router<br>
then uses IP ports to map incoming data to internal device IP addresses in its<br>
routing table. Imagine living in an apartment complex with a mail office. The<br>
postal service could bring packages with your apartment number to the front<br>
desk, and the mail officer would dole those packages out, but the sender would<br>
never actually have to know your name or exactly where your apartment is<br>
located! NAT provides a tiny bit of security and allows significantly more<br>
computers to coexist on the Internet simultaneously.</p>
<p>Because of the extra processing power required to handle large routing tables &amp;<br>
filtering, routers tend to cost substantially more than switches. However, most<br>
networks only need one router! We sometimes describe routers as being our<br>
<em>gateway</em> to the Internet.</p>
<p>Physically, routers come in all shapes and sizes. They only need two connectors<br>
(one incoming, one outgoing), but they often come as part of an integrated<br>
device with multiple connectors and functions.</p>
<h2 id="a-practical-example-of-network-hardware">A practical example of network hardware</h2>
<p>That's enough theory! Let's think through a practical example of each of the<br>
pieces of network hardware we've discussed.</p>
<p>Imagine you need to get a message to a friend across the room. There are lots of<br>
people between you and your friend: how might you communicate?</p>
<p>One way might be to shout. If you shout your message to the room, the rest of<br>
the people in the room could repeat it to make sure it's heard! This is going to<br>
result in some ringing ears, but your friend will definitely hear the message.<br>
This is how <em>hubs</em> work: broadcast to everyone, no matter who's listening.</p>
<p>An alternative might be to whisper. You could pass a message to the person right<br>
next to you. Of course, they won't know everyone in the room, so they'll have to<br>
ask the people close to them to pass it along. It may take a bit to get to your<br>
friend the first time, but any responses will be lightning-fast since everyone<br>
now knows who to talk to. This is a <em>switched</em> model: <em>flood</em> the message once<br>
to learn how to get to the destination, then use what we've learned to <em>forward</em><br>
&amp; <em>filter</em> appropriately.</p>
<p>Finally, imagine your friend has left the room. Uh oh! We could still use the<br>
shouting or whispering approach, but none of that matters since we now need to<br>
find the correct room your friend is in. To do this, we'd need people familiar<br>
with each room. We could pass our message to those gatekeepers, who could pass<br>
the message for us from room to room until it reaches the correct one. At that<br>
point, the process will reverse in the new room: the gatekeeper will whisper or<br>
shout, the room will respond accordingly, and responses will come back via the<br>
gatekeepers. The gatekeepers are acting as our <em>routers</em> here: they pass our<br>
messages between rooms, but don't necessarily care how the room communicates<br>
internally.</p>
<p>Notice in this example that each type of communication has a purpose, and all of<br>
them work together. We're simplifying things, but it's easy to concoct an<br>
example where we need all three types, or where we only need one. This is true<br>
of hardware was well. You should choose the correct devices for the network<br>
you're building. Not thinking through your needs may result in a steep cost,<br>
both in terms of performance and in terms of money!</p>
<h2 id="integrated-devices">Integrated devices</h2>
<p>It's easiest to think of these three classes of hardware as separate, distinct<br>
devices. However, this won't always be the case. Let's discuss some situations<br>
where these devices exist in unfamiliar packages.</p>
<p>When you set up Internet at a new home, you usually get a modem from your ISP.<br>
Years ago, this modem was dead simple: one inbound connection for your phone<br>
line or cable, and one outbound connection for your home PC. Today, however, our<br>
homes have multiple devices! Consumers became increasingly frustrated with<br>
getting a modem from one company but still needing a router and/or switch to<br>
connect all their computers.</p>
<p>In response, ISPs upped their game by integrating extra devices in their<br>
&quot;modems&quot;. The average home gateway today includes:</p>
<ul>
<li>a modem to translate the physical signal from the cable/phone line,</li>
<li>a router to manage your internal and external IP addresses,</li>
<li>a wireless antenna for wi-fi connections,</li>
<li>and a 5-connector switch for wired connections.</li>
</ul>
<p>Woah! That's a lot of hardware in one device. This behavior has blurred the<br>
lines between types of hardware and made communication about networked devices<br>
more difficult. Your ISP might call that single device a &quot;modem&quot;, a &quot;router&quot;, a<br>
&quot;gateway&quot;, or an &quot;access point&quot;. All of these are true!</p>
<p>Before making decisions about a network you're investigating, make sure you<br>
understand what each device is doing. Does that router include a switch? Is the<br>
modem a simple modem or does it include a hub as well? As always, make sure<br>
you're using the right tool for the job.</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>There are lots of different types of network hardware out there, but most of<br>
them fall into three separate categories. Hopefully, the next time you see<br>
inside a messy server closet, you'll be curious about which parts you can<br>
identify!</p>
<p>After this reading, you should be comfortable with:</p>
<ul>
<li>the difference between hubs, switches, and routers,</li>
<li>identifying each type of device,</li>
<li>switched internal networking,</li>
<li>and the basic concept of routing on interconnected networks.</li>
</ul>
<hr>
<h1 id="tcp-connections">TCP Connections</h1>
<p>The <em>Transmission Control Protocol (TCP)</em> is the backbone of the Internet. The<br>
majority of services we use rely on it, and a deeper understanding of it will<br>
help you navigate those services with ease.</p>
<p>Let's deep-dive into TCP! We'll cover:</p>
<ul>
<li>TCP segments what information they carry,</li>
<li>&quot;control bits&quot; that manage the TCP lifecycle,</li>
<li>and the process of forming &amp; discarding connections.</li>
</ul>
<h2 id="segments">Segments</h2>
<p>Just like the <em>Internet Protocol (IP)</em> uses <em>packets</em>, TCP uses data units<br>
called <em>segments</em>. Segments are formed from application data: TCP receives this<br>
data, breaks it down into transmittable units, and attaches a <em>header</em> to each<br>
unit. This header contains everything we need to ensure a reliable connection is<br>
established.</p>
<h3 id="segment-header-fields">Segment Header Fields</h3>
<p>As with IP, TCP header fields are critical to understand. They help satisfy two<br>
needs of the protocol: <strong>reliable data transfer</strong> and <strong>consistent<br>
connections</strong>.</p>
<p>Here's an overview of each field in the order they appear:</p>
<p>
  <img src="./image-ip-tcp-header-fields.svg" style="width: 100%; height:
  auto;">
</p>
<ul>
<li>
<p><strong>Source / Destination Port:</strong> The first two fields indicate which port the<br>
request originated on and which port it's directed to. This will be used,<br>
along with the IP address in the IP wrapper containing the segment, to<br>
determine which <em>sockets</em> to use for the TCP connection.</p>
</li>
<li>
<p><strong>Sequence Number:</strong> This number is used to establish the correct ordering of<br>
data. At the start of a connection, TCP sets an <em>Initial Sequence Number<br>
(ISN)</em> that's sufficiently large enough to avoid conflicts. Each byte of data<br>
transferred is then counted, beginning at the ISN, and used to calculate the<br>
sequence number for the segment. Sequence numbers go hand-in-hand with the ...</p>
</li>
<li>
<p><strong>Acknowledgement Number:</strong> This number lets the sender know which sequence is<br>
expected next. Acknowledgement numbers are cumulative, which is how TCP<br>
maintains proper ordering of segments. The receiver will send an<br>
acknowledgement number that's one higher than the last sequence number plus<br>
the length of the last data received. For example: if the last sequence number<br>
received was <code>10</code>, and the accompanying data was 4 bits long, the response<br>
will include an acknowledgement number of <code>15</code> - meaning &quot;I'm ready for<br>
sequence number 15!&quot;.</p>
</li>
<li>
<p><strong>Data Offset:</strong> Defines how long the segment header is. This lets us know if<br>
there are options later on in the header or not.</p>
</li>
<li>
<p><strong>Reserved:</strong> A short range of three bits, held over for later use. These will<br>
always be <code>0</code>.</p>
</li>
<li>
<p><strong>Control Flags:</strong> These nine bits drive the TCP connection process. We'll<br>
break them down in more detail soon.</p>
</li>
<li>
<p><strong>Window Size:</strong> This field is used to let the sender know how much data the<br>
receiver can accept. This helps maintain the reliability of a connection: if a<br>
receiver is getting overloaded, they can lower the window size as a way of<br>
saying &quot;slow down!&quot;. If a slow connection can move faster, a larger window<br>
size is a way of saying &quot;bring it on!&quot;.</p>
</li>
<li>
<p><strong>Checksum:</strong> The <em>checksum</em> is an error-checking mechanism. Checksums are<br>
used to check the validity of a particular segment, not the whole series of<br>
segment (as with sequence/acknowledgement). The TCP client can use the<br>
checksum to ensure the segment has been received correctly. If it doesn't<br>
match expectations, the segment will be discarded &amp; ignored.</p>
</li>
<li>
<p><strong>Urgent Pointer:</strong> TCP allows for data to be marked as <em>urgent</em>. This means<br>
it should be processed right away, regardless of sequence, interrupting any<br>
other transfer in process. This is useful when trying to terminate a long<br>
transfer, as we'd like to kill the connection without waiting for it to<br>
complete. This field indicates how much urgent data to expect, if there is<br>
any.</p>
</li>
<li>
<p><strong>Options:</strong> Like most other protocols, the TCP segment header includes a<br>
range for <em>options</em> at its end. There may be no options, or there may be a<br>
handful! We can verify whether there are options be comparing the length of<br>
the header so far to the <em>data offset</em> field. TCP header options are mostly<br>
used for flow control and may even include <em>padding</em> to fill out the expected<br>
length of the header with empty data.</p>
</li>
</ul>
<p>Immediately after any options (or after the <em>urgent pointer</em>, if no options are<br>
given), the encapsulated data from our application begins.</p>
<h2 id="tcp-connection-lifecycle">TCP Connection Lifecycle</h2>
<p>Remember that TCP is a <em>connection-oriented protocol</em>. This means that it<br>
establishes a long-running line of communication between two points, instead of<br>
just shouting into the Internet void like UDP. Establishing this connection<br>
involves a series of predictable steps, each with specific names. Most of these<br>
steps are driven by the <em>control flags</em> in the segment headers.</p>
<h3 id="control-flag-options">Control Flag Options</h3>
<p>The segment header has 12 bits reserved for control flags. The first three of<br>
these are currently unused and will always be zero, and the next three are all<br>
used by congestion-management extensions to the protocol. The control flags that<br>
most concern us are the final six bits, each known by a short three-letter name.<br>
Let's review them in order:</p>
<p>
  <img src="./image-ip-tcp-header-control-flags.svg" style="width: 100%; height:
  auto;">
</p>
<ul>
<li>
<p><strong>URG:</strong> The &quot;<strong>urg</strong>ent&quot; bit. Lets us know if this segment contains urgent<br>
data.</p>
</li>
<li>
<p><strong>ACK:</strong> The &quot;<strong>ack</strong>nowledgement&quot; bit. Setting this bit means a message has<br>
been received successfully.</p>
</li>
<li>
<p><strong>PSH:</strong> The &quot;<strong>p</strong>u<strong>sh</strong>&quot; bit. This bit is used to indicate that buffered<br>
data should be passed on to the connected application.</p>
</li>
<li>
<p><strong>RST:</strong> The &quot;<strong>r</strong>e<strong>s</strong>e<strong>t</strong>&quot; bit. This bit means we should reset the<br>
connection. Receivers will send an RST segment when they receive unexpected<br>
data, either to a port that's not listening or dramatically out-of-sequence.</p>
</li>
<li>
<p><strong>SYN:</strong> The &quot;<strong>syn</strong>chronize&quot; bit. This flag is set on the the first segment<br>
from each side of the connection, and should include an ISN for the socket to<br>
begin sequencing from.</p>
</li>
<li>
<p><strong>FIN:</strong> The &quot;<strong>fin</strong>ished&quot; bit. This bit lets each side know that<br>
transmission is done and the connection may be closed.</p>
</li>
</ul>
<blockquote>
<p>Note that we mention all twelve bits here as &quot;control bits&quot; even though the<br>
first three are unassigned. While they are currently unused, protocols evolve<br>
frequently! The <a href="https://www.iso.org/home.html">TCP specification</a> lists &quot;six reserved bits, six control<br>
bits&quot;, but newer specs have claimed some of those. For this reason, you should<br>
think of the remaining three reserved bits as &quot;control flags still under<br>
development&quot;.</p>
</blockquote>
<h3 id="getting-to-know-each-other-the-three-way-handshake">Getting to know each other: the three-way handshake</h3>
<p>TCP connections begin with a process called a <em>three-way-handshake</em>, also<br>
sometimes referred to as <em>SYN-SYN-ACK</em>.  This name comes from the three<br>
interactions before the connection is officially &quot;open&quot;:</p>
<ul>
<li>The client notifies the server that data is incoming with a <code>SYN</code> segment.</li>
<li>The server acknowledges that data and sends its own segment, including both an<br>
<code>ACK</code> and its own <code>SYN</code>.</li>
<li>The client <code>ACK</code>nowledges with another segment to the server. Now both sides<br>
are ready to go!</li>
</ul>
<p>Notice that we can send both a <code>SYN</code> and <code>ACK</code> on a single segment. This is<br>
called <em>piggybacking</em> and saves us a ton of requests! The three-way handshake<br>
would become a four-way handshake if we had to send the <code>SYN</code> and <code>ACK</code><br>
separately.</p>
<p>TCP connections are often visualized using <em>ladder diagrams</em>, also sometimes<br>
called <em>timing diagrams</em>. Let's take a look at one for the three-way handshake:</p>
<p>
  <img src="./image-ip-tcp-three-way-opening.svg" style="width: 100%; height:
  auto;">
</p>
<p>This diagram should be read top-to-bottom. Each arrow represents a single<br>
segment being passed between hosts. You can see how the client initiates the<br>
request, but the server mirrors the process. This ensures both sides are ready<br>
to work: if the client's <code>SYN</code> request fell on deaf ears, we would expect an<br>
<code>RST</code> segment back.</p>
<p>You can also see how the <em>sequence number</em> and <em>acknowledgement number</em> are<br>
incremented for each segment. Since these initial segments contain no data, each<br>
only increments by one. During data transfer, the numbers will increment based<br>
on the length of data received so far.</p>
<p>TCP maintains timers for most behaviors to ensure that connections don't hang<br>
empty forever. This is one reason time-based diagrams are so helpful: by<br>
adjusting the angle of the arrows between the client &amp; server, we can indicate a<br>
faster or slower connection. This can be helpful for visualizing connections on<br>
a granular level. For example, here's a simplified diagram of the same three-way<br>
handshake with a slow server response:</p>
<p>
  <img src="./image-ip-tcp-slow-connection.svg" style="width: 100%; height:
  auto;">
</p>
<h3 id="data-transmission--error-handling">Data transmission &amp; error handling</h3>
<p>Once the connection has been <em>established</em>, we're off to the races! The client<br>
will send data segments over and the server will respond with <code>ACK</code> segments.</p>
<p>Remember that the sequence number in each data segment indicates where our data<br>
starts, and the corresponding acknowledgement number should be the next position<br>
after our data ends. For example, a data segment with a sequence number of <code>4</code><br>
and data of length <code>3</code> will be <code>ACK</code>'ed with an acknowledgement number of <code>7</code>:<br>
our data included <code>4</code>, <code>5</code>, and <code>6</code> in the sequence, and the server is letting<br>
us know that it's ready for data beginning at sequence number <code>7</code>.</p>
<p>Here's a fun way of visualizing this concept via text messages between the<br>
client &amp; server:</p>
<p>
  <img src="./image-ip-tcp-seq-ack.svg" style="width: 100%; height:
  auto;">
</p>
<p>Note that there<br>
won't be any more <code>SYN</code> segments unless the connection terminates unexpectedly:<br>
we only send segments with the <code>SYN</code> flag enabled when initializing a<br>
connection.</p>
<p>The acknowledgement number is important for keeping the TCP connection reliable.<br>
It will only increment when a segment is successfully received, so an <code>ACK</code><br>
response to the client with a lower acknowledgement number than the client's<br>
current sequence number means a segment was missed and must be retransmitted.</p>
<p>A diagram is worth a thousand words:</p>
<p>
  <img src="./image-ip-tcp-dropped-segment.svg" style="width: 100%; height:
  auto;">
</p>
<p>This is a <strong>major</strong> part of TCP, and one of the reasons it's both reliable and<br>
slow: data may need to be retransmitted frequently, but the end result is always<br>
a full &amp; correct payload on the server.</p>
<h3 id="saying-goodbye-closing-the-connection">Saying goodbye: closing the connection</h3>
<p>Once we've sent all our data across the wire, it's time to say <em>au revoir</em>. By<br>
default, TCP closes open connections similarly to the way they're opened: lots<br>
of handshakery! By default, this time it's a <em>four-way handshake</em>.</p>
<p>Let's take a look at a diagram of a TCP connection closing:</p>
<p>
  <img src="./image-ip-tcp-four-way-closing.svg" style="width: 100%; height:
  auto;">
</p>
<p>This diagram is similar to the three-way handshake we looked at for connection<br>
establishment, so it may raise a question for you: why the extra handshake? The<br>
reason, as usual, is <em>reliability</em>!</p>
<p>Remember how TCP maintains timers between segments.? This is because no matter<br>
how much reliability we've worked into transport protocols, they're still built<br>
on top of unreliable protocols and infrastructure. The same is true of a closing<br>
connection: we don't want to act too quickly or we may miss a piece of extra<br>
important data.</p>
<p>When closing a connection, both sides wait a beat before actually closing. This<br>
allows any delayed segments to slip in at the last minute! This also means it is<br>
impractical for the server to send a piggybacked <code>FIN</code> &amp; <code>ACK</code> in the same way<br>
it sends a <code>SYN</code> &amp; <code>ACK</code> to open the connection. If the server waited before<br>
sending an <code>ACK</code>, the client may think something went wrong and begin<br>
retransmitting. To prevent this, the server responses are separated:</p>
<ul>
<li>the server returns an <code>ACK</code> to the client's first <code>FIN</code> right away,</li>
<li>it waits a moment to ensure there are no remaining data segments inbound,</li>
<li>and then it sends a corresponding <code>FIN</code> segment to let the client know it's<br>
shutting down.</li>
</ul>
<p>The client will <code>ACK</code>nowledge immediately, but may also wait a bit before truly<br>
closing, just in case. With all the handshaking and waiting around, you might<br>
call TCP a &quot;considerate&quot; protocol as well!</p>
<h3 id="the-tcp-socket-state-lifecycle">The TCP Socket State Lifecycle</h3>
<p>Remember that a TCP connection is between two <em>sockets</em>, or joint IP<br>
address/port pairs. As the connection progresses, these sockets change <em>state</em>.<br>
For example, during the process of data transfer, both sockets are considered to<br>
be in the <code>ESTABLISHED</code> state, while before a connection is established a<br>
server's open socket would be in the <code>LISTEN</code> state.</p>
<p>It's important to remember that this flow isn't identical for the client &amp;<br>
server, too: after the client sends its <code>SYN</code>, it enters a <code>SYN SENT</code> state<br>
while the server enters a <code>SYN RCVD</code> (or &quot;<code>SYN</code> Received&quot;) state of its own.</p>
<p>Here's a diagram of a simple data transfer from start to finish. Notice that<br>
we've added the socket states for each side of the connection outside the<br>
diagram. These may be noted by network tools and can be helpful to reference if<br>
you find yourself debugging a TCP connection problem:</p>
<p>
  <img src="./image-ip-tcp-socket-states.svg" style="width: 100%; height:
  auto;">
</p>
<p>The original TCP specification includes an <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html">alternative text-based chart</a> for<br>
the lifecycle of these socket states, and you can read more about this process<br>
on the <a href="https://en.wikipedia.org/wiki/IPv6#Address_representation">Wikipedia page</a> for TCP.</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>Wow! It's incredible to visualize everything happening across the wire when you<br>
browse the Web. TCP is such a foundational piece of your daily interactions with<br>
the Internet and will only become more so as you begin contributing to the Web<br>
yourself!</p>
<p>After reading this lesson, you should have a clear understanding of:</p>
<ul>
<li>TCP segment headers and how they relate to the segment's contents,</li>
<li>TCP control flags,</li>
<li>the TCP connection process, including the many handshakes,</li>
<li>and basic error handling across TCP connections.</li>
</ul>
<hr>
<h1 id="following-the-trail-with-traceroute">Following The Trail With <code>traceroute</code></h1>
<p>Remember that the Internet is a &quot;network of networks&quot;<a href="https://www.iso.org/home.html">1</a>. This can make it tough<br>
to <em>debug</em> problems between networks: how do we identify the culprit? Enter<br>
<em>traceroute</em>! Let's explore this utility and learn how to find problems with<br>
inter-network connections.</p>
<p>We'll cover:</p>
<ul>
<li>what <code>traceroute</code> is and when to use it,</li>
<li>how to read <code>traceroute</code> output,</li>
<li>and how to use <code>traceroute</code> to solve problems.</li>
</ul>
<h2 id="where-are-we-going">Where are we going?</h2>
<p>When we create connections between networks, they're rarely direct. We've<br>
already discussed how the IP protocol works to connect devices across multiple<br>
intermediaries. While the theory and addressing makes sense, it raises a new<br>
challenge: how do we solve problems when we can't get access to the other<br>
networks involved?</p>
<p>Thankfully, there's a utility that lets us peek at devices along the way. It's<br>
called <code>traceroute</code>. The <code>traceroute</code> utility runs on the command line and uses<br>
UDP packets to monitor each device that data passes through as it moves from the<br>
source location to the target location. Using this utility, we can determine<br>
where a network failure or slowdown might be occurring.</p>
<blockquote>
<p><code>traceroute</code> vs. <code>tracert</code></p>
<p>If you do some research of your own, you may find <code>traceroute</code> referred to as<br>
<code>tracert</code>. These utilities  work slightly differently. <code>tracert</code> is included<br>
with the Windows operating system, and uses <em>ICMP</em> (an alternative protocol<br>
also used by the <code>ping</code> utility) to trace data. <code>traceroute</code> is on Unix-based<br>
operating systems, including macOS, and uses UDP. We'll prefer <code>traceroute</code><br>
here, but the output of both utilities is almost identical! If you find<br>
yourself investigating network problems on a Windows computer, the skills<br>
covered here will translate seamlessly.</p>
</blockquote>
<p>You'll sometimes hear using <code>traceroute</code> referred to as &quot;running a trace&quot;.<br>
Running a trace of your own is easy - enter the following on your command line:</p>
<pre class="hljs"><code><div>&gt; traceroute appacademy.io
</div></code></pre>
<p>Boom! Your first trace! So what does all that gibberish mean? Let's break it<br>
down.</p>
<h2 id="reading-a-trace">Reading a trace</h2>
<p>Here's a screenshot of <code>traceroute appacademy.io</code> from my terminal:</p>
<p>
  <img src="./image-network-tools-traceroute-screenshot.svg" style="width:
  auto;">
</p>
<h3 id="metadata">Metadata</h3>
<p>First, let's look at the overall breakdown. At the top of the trace, you'll see<br>
some general info. There's a warning about &quot;multiple addresses&quot;, meaning that<br>
<code>appacademy.io</code> resolves to more than one IP address. This is common for popular<br>
websites that use multiple servers to reduce traffic and keep speeds high. Next,<br>
you'll see the true beginning of the trace, including the domain we're tracing<br>
to, the IP address it resolved to, and a maximum number of <em>hops</em> (&quot;64&quot;) and<br>
<em>packet size</em> &quot;(52 byte&quot;).</p>
<p>We mentioned <em>hops</em> when discussing networking protocols, but here's a quick<br>
review: a &quot;hop&quot; is one connection to another server. Think of the houses on your<br>
street or apartments on your hall. A single hop would walking to your next door<br>
neighbor's home. Three hops would be walking three doors down. When we run<br>
<code>traceroute</code>, it tracks the location of each hop, but it limits the number of<br>
hops to make sure we're not searching for an unavailable address forever! Our<br>
<code>traceroute</code> won't go more than 64 hops, though this default may differ across<br>
systems.</p>
<p>Below the general info, we see a numbered list of addresses. Each line<br>
represents one hop, and includes some important info about that destination.<br>
Let's check it out!</p>
<h3 id="the-hop">The Hop</h3>
<p>Here's our first hop:</p>
<p>
  <img src="./image-network-tools-traceroute-single-hop-screenshot.svg"
  style="width: auto;">
</p>
<p>We know it's the first because of the <code>1</code> on the left side. Each hop is preceded<br>
by a number indicating how many hops it took to get there.</p>
<p>Next, we see two IP addresses. These identify the network location our trace has<br>
reached. In this case, the location has no resolvable DNS name so we just see<br>
the IP address. If you look ahead a bit, you can see that addresses with a<br>
resolvable name will show that name first instead.</p>
<p>Finally, we see three numbers. These are time intervals, (indicated by the &quot;ms&quot;,<br>
short for &quot;milliseconds&quot;) that let us know how long it took us to reach this<br>
location from our system. When we run a trace, <code>traceroute</code> attempts each hop<br>
three times. This is because UDP (and the Internet beneath it!) is inherently<br>
unreliable. Testing the hop three times ensures we get truly representative data<br>
and not a false reading due to a dropped packet or network congestion. Each of<br>
the three numbers we see is the response time from one of those attempts.<br>
They'll always vary slightly, but we can get a good idea of the average response<br>
time. In this case, the numbers are <strong>very</strong> small: two tenths of a millisecond!<br>
Wow!.</p>
<blockquote>
<p>This first hop is my home internet router! We can tell this not only because<br>
it's the first device reached beyond my own computer, but also because the IP<br>
address is within one of IPv4's <em>reserved ranges</em>, meant for private networks<br>
inside homes and businesses. It's unlikely you'll see reserved addresses<br>
outside of your current network.</p>
</blockquote>
<p>Hops proceed from our own device to the <em>gateway</em> for the device we're trying to<br>
reach. We can analyze each hop using the same breakdown.</p>
<p>The first hop in our trace is straightforward, but that's not always the case!<br>
Let's take a look at a few not-so-standard situations you may see come up.</p>
<h3 id="special-cases">Special cases</h3>
<p>Notice that our second hop doesn't have any of the info we expect from<br>
<code>traceroute</code>. Instead, it has three asterisks:</p>
<p>
  <img src="./image-network-tools-traceroute-empty-hop-screenshot.svg"
  style="width: auto;">
</p>
<p>In <code>traceroute</code>-speak, an asterisk (<code>*</code>) represents a hop with no response. This<br>
doesn't necessarily mean the hop failed, just that our system didn't get a<br>
response back! This could be due to server configuration or a slow connection.<br>
By default, a hop will return a <code>*</code> if there's no response for five seconds.<br>
There are three asterisks in this case to indicate that all three attempts went<br>
unanswered.</p>
<p>Let's also take a look at our eighth hop:</p>
<p>
  <img src="./image-network-tools-traceroute-load-balanced-hop-screenshot.svg"
  style="width: auto;">
</p>
<p>This one entry has multiple addresses! What's going on? This is an example of<br>
<em>load balancing</em> in action. In this case, the router at our seventh hop is<br>
directing traffic to multiple locations. This <em>balances</em> the <em>load</em> and ensures<br>
that one single router isn't handling too much.</p>
<p>In this case, one of our hop attempts went to the <code>atln.ga</code> (Atlanta, Georgia)<br>
router, while the other two went to the <code>snjs.ca</code> (San Jose, California) router.<br>
We still see timestamps for all three hop attempts.</p>
<p>Because of load balancing, your connection to <code>appacademy.io</code> isn't guaranteed<br>
to be the same each time. Try running <code>traceroute appacademy.io</code> again - do you<br>
see the exact same addresses as before?</p>
<h2 id="when-should-i-run-a-trace">When should I run a trace?</h2>
<p>Tracing is most useful for diagnosing network connectivity issues. Imagine your<br>
internet at home suddenly goes down! You can <code>traceroute</code> to a familiar domain<br>
to see if the connection fails before it gets to your own router (in which case,<br>
it's likely a problem on your device), or it fails at a network outside yours.</p>
<p>You can also diagnose slow connections this way! If a hop has a very long<br>
response time (&gt; 50 ms), then it's possible that a previous device in line is<br>
experiencing downtime or network congestion.</p>
<p><code>traceroute</code> is simple to use without them, but does include some command line<br>
arguments that can enhance its abilities. Check out <code>man traceroute</code> to learn<br>
more about what it can do!</p>
<h2 id="what-weve-learned">What we've learned</h2>
<p>When in doubt, <code>trace-</code> the <code>-route</code>! Tracing network traffic using the<br>
<code>traceroute</code> utility is a great way to identify what's happening outside your<br>
own network.</p>
<p>After this lesson, you should be comfortable:</p>
<ul>
<li>using <code>traceroute</code> to diagnose connection problems,</li>
<li>reading the output of a <code>traceroute</code> command,</li>
<li>and knowing when <code>traceroute</code> is the correct tool for the job.</li>
</ul>
<hr>
<h1 id="use-wireshark-to-capture-network-traffic">Use Wireshark To Capture Network Traffic</h1>
<p>Wireshark, a network analysis tool formerly known as Ethereal, captures packets<br>
in real time and display them in human-readable format. Wireshark includes<br>
filters, color coding, and other features that let you dig deep into network<br>
traffic and inspect individual packets.</p>
<p>This tutorial will get you up to speed with the basics of capturing packets,<br>
filtering them, and inspecting them. You can use Wireshark to inspect a<br>
suspicious program's network traffic, analyze the traffic flow on your network,<br>
or troubleshoot network problems.</p>
<h2 id="installing-wireshark">Installing Wireshark</h2>
<p>You can download Wireshark for Windows or macOS from its <a href="https://www.wireshark.org/">official website</a>. If<br>
you're using Linux or another UNIX-like system, you'll probably find Wireshark<br>
in its package repositories. For example, if you're using Ubuntu, you'll find<br>
Wireshark in the Ubuntu Software Center.</p>
<p>Just a quick warning: Many organizations don't allow Wireshark and similar tools<br>
on their networks. Don't use this tool at work unless you have permission.</p>
<h2 id="capturing-packets">Capturing packets</h2>
<p>After downloading and installing Wireshark, you can launch it and double-click<br>
the name of a network interface under Capture to start capturing packets on that<br>
interface. For example, if you want to capture traffic on your wireless network,<br>
click your wireless interface. You can configure advanced features by clicking<br>
Capture &gt; Options, but this isn't necessary for now.</p>
<p><img src="./wireshark-01.png" alt="capturing 1"></p>
<p>As soon as you click the interface's name, you'll see the packets start to<br>
appear in real time. Wireshark captures each packet sent to or from your system.</p>
<p>If you have promiscuous mode enabled—it's enabled by default—you'll also see all<br>
the other packets on the network instead of only packets addressed to your<br>
network adapter. To check if promiscuous mode is enabled, click Capture &gt;<br>
Options and verify the &quot;Enable promiscuous mode on all interfaces&quot; checkbox is<br>
activated at the bottom of this window.</p>
<p><img src="./wireshark-02.png" alt="capturing 2"></p>
<p>Click the red &quot;Stop&quot; button near the top left corner of the window when you want<br>
to stop capturing traffic.</p>
<p><img src="./wireshark-03.png" alt="capturing 3"></p>
<p>The packet list pane, located at the top of the window, shows all packets found<br>
in the active capture file. Each packet has its own row and corresponding number<br>
assigned to it, along with each of these data points:</p>
<ul>
<li><strong>No</strong>: This field indicates which packets are part of the same conversation.<br>
It remains blank until you select a packet.</li>
<li><strong>Time</strong>: The timestamp of when the packet was captured is displayed in this<br>
column. The default format is the number of seconds or partial seconds since<br>
this specific capture file was first created.</li>
<li><strong>Source</strong>: This column contains the address (IP or other) where the packet<br>
originated.</li>
<li><strong>Destination</strong>: This column contains the address that the packet is being<br>
sent to.</li>
<li><strong>Protocol</strong>: The packet's protocol name, such as TCP, can be found in this<br>
column.</li>
<li><strong>Length</strong>: The packet length, in bytes, is displayed in this column.</li>
<li><strong>Info</strong>: Additional details about the packet are presented here. The contents<br>
of this column can vary greatly depending on packet contents.</li>
</ul>
<p>When a packet is selected in the top pane, you may notice one or more symbols<br>
appear in the No. column. Open or closed brackets and a straight horizontal<br>
line indicate whether a packet or group of packets are part of the same<br>
back-and-forth conversation on the network. A broken horizontal line signifies<br>
that a packet is not part of the conversation.</p>
<h2 id="color-coding">Color coding</h2>
<p>You'll probably see packets highlighted in a variety of different colors.<br>
Wireshark uses colors to help you identify the types of traffic at a glance. By<br>
default, light purple is TCP traffic, light blue is UDP traffic, and black<br>
identifies packets with errors—for example, they could have been delivered out<br>
of order.</p>
<p>To view exactly what the color codes mean, click View &gt; Coloring Rules. You can<br>
also customize and modify the coloring rules from here, if you like.</p>
<h2 id="sample-captures">Sample captures</h2>
<p>If there's nothing interesting on your own network to inspect, Wireshark's wiki<br>
has you covered. The wiki contains a <a href="https://wiki.wireshark.org/SampleCaptures">page of sample capture</a> files that you can<br>
load and inspect. Click File &gt; Open in Wireshark and browse for your downloaded<br>
file to open one.</p>
<p>Download, open, and inspect each of these capture files so you can see what it<br>
looks like for that communication to have occurred over a network.</p>
<ul>
<li><a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=http.cap">http.cap</a> A simple HTTP request and response</li>
<li><a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=dns.cap">dns.cap</a> Various DNS lookups</li>
<li><a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=wpa-Induction.pcap">wpa.cap</a> 802.11 capture with WPA data encrypted using the password &quot;Induction&quot;</li>
</ul>
<p>You can also save your own captures in Wireshark and open them later. Click the<br>
File &gt; Save to save your captured packets.</p>
<h2 id="filtering-packets">Filtering packets</h2>
<p>If you're trying to inspect something specific, such as the traffic a program<br>
sends when phoning home, it helps to close down all other applications using the<br>
network so you can narrow down the traffic. Still, you'll likely have a large<br>
amount of packets to sift through. That's where Wireshark's filters come in.</p>
<p>The most basic way to apply a filter is by typing it into the filter box at the<br>
top of the window and clicking Apply (or pressing Enter). For example, type<br>
&quot;dns&quot; and you'll see only DNS packets. When you start typing, Wireshark will<br>
help you autocomplete your filter.</p>
<p><img src="./wireshark-04.png" alt="capturing 4"></p>
<p>You can also click Analyze &gt; Display Filters to choose a filter from among the<br>
default filters included in Wireshark. From here, you can add your own custom<br>
filters and save them to easily access them in the future.</p>
<p>Another interesting thing you can do is right-click a packet and select Follow &gt;<br>
TCP Stream.</p>
<p>You'll see the full TCP conversation between the client and the server. You can<br>
also click other protocols in the Follow menu to see the full conversations for<br>
other protocols, if applicable.</p>
<h2 id="inspecting-packets">Inspecting packets</h2>
<p>Click a packet to select it and you can dig down to view its details.</p>
<p><img src="./wireshark-05.png" alt="capturing 5"></p>
<p>You can also create filters from here — just right-click one of the details and<br>
use the Apply as Filter submenu to create a filter based on it.</p>
<p><img src="./wireshark-06.png" alt="capturing 6"></p>
<p>Wireshark is an extremely powerful tool, and this tutorial is just scratching<br>
the surface of what you can do with it. Professionals use it to debug network<br>
protocol implementations, examine security problems and inspect network protocol<br>
internals.</p>
<h2 id="assignment">Assignment</h2>
<p>Now, start Wireshark, start capturing network traffic, and perform various<br>
tasks on your computer using different applications. You will be surprised by<br>
the number of network requests made by your computer. See if you can identify<br>
the application that makes each request and the significance of each request.</p>
<hr>
<h1 id="diy-flashcards">DIY Flashcards</h1>
<p>There is a lot of terminology and knowledge in today's lessons. These aren't<br>
skills that you can necessarily apply. However, the body of knowledge is<br>
essential to understand how networking works both in ideal and practical senses.</p>
<p>Today, it's up to you to make your own flashcards for studying. You can make<br>
then in your pair and share the Anki files. Use them to study because this will<br>
likely be on your assessment and in some interviews.</p>

</body>
</html>
