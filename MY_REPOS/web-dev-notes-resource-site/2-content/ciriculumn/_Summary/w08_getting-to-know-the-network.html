<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<h1 id="week-8-getting-to-know-the-network" data-ignore="true">WEEK 8<br><em>Getting to Know the Network</em></h1>
<hr />
<!-- code_chunk_output -->
<ul>
<li><a href="#white-boarding-tips"><strong>White-Boarding Tips</strong></a>
<ul>
<li><a href="#why-do-companies-whiteboard">Why do companies whiteboard?</a></li>
<li><a href="#correct-steps">Correct steps</a></li>
<li><a href="#clarification">Clarification</a></li>
<li><a href="#test-io">Test I/O</a></li>
<li><a href="#pseudocode">Pseudocode</a></li>
<li><a href="#during-the-problem">During the Problem</a></li>
<li><a href="#walk-through-an-example-input">Walk through an example input</a></li>
<li><a href="#time-and-space-complexity">Time and space complexity</a></li>
<li><a href="#strategies">Strategies</a></li>
<li><a href="#dont-be-sly">Don’t be Sly</a></li>
<li><a href="#how-to-handle-questions-youve-seen-before">How to handle questions you’ve seen before.</a></li>
</ul></li>
<li><a href="#white-boarding-exercises">White Boarding Exercises</a>
<ul>
<li><a href="#mirror-image-trees">Mirror image trees</a></li>
<li><a href="#reverse-a-linked-list">Reverse a linked list</a></li>
<li><a href="#the-missing-value">The missing value</a></li>
<li><a href="#stack-min">Stack min</a></li>
<li><a href="#test-a-retractable-ballpoint-pen">Test a retractable ballpoint pen</a></li>
<li><a href="#ooparking-lot">OOParking Lot</a></li>
</ul></li>
</ul>
<p><a href="#binary-trees-and-binary-search-trees-learning-objectives"><strong>Binary Trees and Binary Search Trees Learning Objectives</strong></a> - <a href="#binary-trees">Binary Trees</a> - <a href="#traversing-trees">Traversing trees</a> - <a href="#binary-search-trees">Binary Search Trees</a> - <a href="#a-special-traversal-case">A special traversal case</a> - <a href="#binary-tree-project">Binary Tree Project</a> - <a href="#binary-search-tree-project">Binary Search Tree Project</a></p>
<p><a href="#graphs-and-heaps-learning-objectives"><strong>Graphs and Heaps Learning Objectives</strong></a> - <a href="#graphs">Graphs</a> - <a href="#what-is-a-graph-1">What is a Graph?</a> - <a href="#graph-implementations">Graph Implementations</a> - <a href="#graph-traversal">Graph Traversal</a> - <a href="#graph-project">Graph Project</a></p>
<p><a href="#network-models-learning-objectives"><strong>Network Models Learning Objectives</strong></a> <a href="#internet-protocol-suite-learning-objectives"><strong>Internet Protocol Suite Learning Objectives</strong></a> <a href="#network-tools-learning-objectives"><strong>Network Tools Learning Objectives</strong></a> - <a href="#the-osi-network-model">The OSI Network Model</a> - <a href="#more-layers-~~more~~-fewer-problems">More layers, <del>more</del> fewer problems?</a> - <a href="#the-layers-of-the-osi-model">The layers of the OSI model</a> - <a href="#which-model-do-i-use">Which model do I use?</a> - <a href="#tcpip-four-layers">TCP/IP: Four Layers</a> - <a href="#a-layered-approach">A layered approach</a> - <a href="#layers-of-the-tcpip-model">Layers of the TCP/IP model</a> - <a href="#translating-layers-to-data">Translating layers to data</a> - <a href="#a-crash-course-in-binary-and-hexadecimal-notation">A Crash Course in Binary and Hexadecimal Notation</a> - <a href="#binary">Binary</a> - <a href="#bits-and-bytes">Bits and Bytes</a> - <a href="#another-useful-base">Another useful base</a> - <a href="#in-javascript">In JavaScript</a> - <a href="#internet-protocol">Internet Protocol</a> - <a href="#history-of-ip">History of IP</a> - <a href="#so-what-is-the-internet-exactly">So what is the Internet, exactly?</a> - <a href="#packet-switching">Packet-Switching</a> - <a href="#ip-versions">IP Versions</a> - <a href="#transport-protocols">Transport Protocols</a> - <a href="#what-exactly-are-we-transporting">What exactly are we transporting?</a> - <a href="#tcp">TCP</a> - <a href="#udp">UDP</a> - <a href="#surveying-your-domain">Surveying Your Domain</a> - <a href="#what-is-dns">What is DNS?</a> - <a href="#how-the-magic-happens">How The Magic Happens</a> - <a href="#dns-records">DNS Records</a> - <a href="#networking-hardware-getting-physical">Networking Hardware: Getting Physical</a> - <a href="#three-levels-of-control">Three levels of control</a> - <a href="#a-practical-example-of-network-hardware">A practical example of network hardware</a> - <a href="#integrated-devices">Integrated devices</a> - <a href="#tcp-connections">TCP Connections</a> - <a href="#segments">Segments</a> - <a href="#tcp-connection-lifecycle">TCP Connection Lifecycle</a> - <a href="#following-the-trail-with-traceroute">Following The Trail With <code>traceroute</code></a> - <a href="#where-are-we-going">Where are we going?</a> - <a href="#reading-a-trace">Reading a trace</a> - <a href="#when-should-i-run-a-trace">When should I run a trace?</a> - <a href="#practice-use-wireshark-to-capture-network-traffic">Practice: Use Wireshark To Capture Network Traffic</a> - <a href="#installing-wireshark">Installing Wireshark</a> - <a href="#capturing-packets">Capturing packets</a> - <a href="#color-coding">Color coding</a> - <a href="#sample-captures">Sample captures</a> - <a href="#filtering-packets">Filtering packets</a> - <a href="#inspecting-packets">Inspecting packets</a> - <a href="#assignment">Assignment</a></p>
<!-- /code_chunk_output -->
<hr />
<h1 id="week-08-day-1-white-boarding-tips-and-tricks" data-ignore="true">WEEK-08 DAY-1<br><em>White-Boarding Tips and Tricks</em></h1>
<hr />
<h1 id="white-boarding-tips">White-Boarding Tips</h1>
<h2 id="why-do-companies-whiteboard">Why do companies whiteboard?</h2>
<p>Steps to solving white-boarding questions are identical to the steps necessary to solve real-world practical problems.</p>
<p>Companies want to see how you perform as a team member in a real team.</p>
<p>Things the interviewer will be looking for: * Can you think algorithmically? Can you think about efficiency? * Are you a good communicator? Are you someone I want to think through a new feature with? * Can you code? Can you code neatly and correctly?</p>
<h2 id="correct-steps">Correct steps</h2>
<ol type="1">
<li>Clarify the problem &amp; test I/O and edge cases</li>
<li>Formulate your approach(es)</li>
<li>Pseudocode best approach</li>
<li>Code it</li>
<li>Walk through an example input</li>
<li>Determine the Big O time and space complexity</li>
</ol>
<h2 id="clarification">Clarification</h2>
<p>Before you jump into coding, ask questions. Don’t rush, it’s a problem-solving demo, not a speed-coding test.</p>
<ul>
<li>What are we coding?</li>
<li>Are there any constraints on the input/output?</li>
<li>What edge cases can we expect?</li>
</ul>
<h2 id="test-io">Test I/O</h2>
<p>You should start with simple inputs and then slowly build up size or complexity of inputs. Look for patterns and things that remind you of problems you know how to solve.</p>
<p>If you draw a blank, use the following strategies to get started.</p>
<ul>
<li>Make up a sample input and compute it. Do this two or three times.</li>
<li>Go through data structures in your head. Go through algorithms you know simultaneously. If you find one that works for this problem, run with it.</li>
<li>If not, find a naive solution, any solution, to get started. Then you can optimize.</li>
<li>Come up with a simpler version of the problem, solve it, then progressively add complexity.</li>
<li>Think aloud about the likely bounds on efficiency for your solution.
<ul>
<li>This is an easy way to score points.</li>
<li>"What’s sure is I’ll have to iterate through all the points, so it’s at least linear time."</li>
<li>"The problem is trivial when the set is sorted. So it can definitely be done in nLOGn time. Let’s see if we can do better than n Log n."</li>
</ul></li>
</ul>
<h2 id="pseudocode">Pseudocode</h2>
<p>Never skip this step! Companies expect you to be able to pseudocode because it is the English version of your approach to the problem. You need to lay out your strategy step by step, so that when you code, you have something to refer back to. It’s easy to be lost in the intricacies of implementation, so you as well as the interviewer need pseudocode to refer back to when you lose track of your thoughts.</p>
<ul>
<li>Be as detailed as possible</li>
<li>Spend as much time as you want, within reason</li>
<li>Make sure you can reason about implementation of every step</li>
</ul>
<h2 id="during-the-problem">During the Problem</h2>
<p>At this point, you should have spent at least 60% of your time. If you sprinted to coding, you most likely didn’t spend enough time planning and will struggle here. If planned properly, this section should be the easiest part.</p>
<ul>
<li>The nice thing about white boards is you and the interviewer are facing the same direction.</li>
<li>Convince yourself that you are solving the problem together. Say "we" instead of "I".</li>
<li>Don’t stop until they tell you to.</li>
</ul>
<p>Your style definitely makes an impact. Here are tips to how to handle your bearing.</p>
<ul>
<li>Be confident; even if you don’t know the answer, try to engage the problem, don’t give up. If you keep telling an interviewer you don’t know how to do something, they’ll start to believe you.</li>
<li>Talk through the problem; they want to see the process going on in your head. If you don’t talk, the interviewer doesn’t learn how you break-down and analyze a problem. If you can write and talk at the same time, great! If not, tell the interviewer what you’re about to write, write it, and explain what you wrote.</li>
<li>The interviewer may give you hints. They will ask questions to keep you on track. Don’t be flustered or think you’re failing; this is normal.</li>
<li>If they ask you "does this work", take a moment to think. Walk through the steps; out loud is fine. If you say yes, say it like you believe it; interviewers don’t like to think people are just praying they’ll get the answer right.</li>
<li>Listen to the interviewer. They are trying to help you. No one likes someone who doesn’t listen.</li>
</ul>
<h2 id="walk-through-an-example-input">Walk through an example input</h2>
<ul>
<li>Initiate this step - don’t wait to be prompted.</li>
<li>Track all of your variables.</li>
<li>Draw stacks if you’re using a recursive method.</li>
<li>Follow each iteration of your loops.</li>
<li>Reason through your code from input to output.</li>
</ul>
<h2 id="time-and-space-complexity">Time and space complexity</h2>
<ul>
<li>You should know how to do this - refer back to Big O reading if you need to.</li>
<li>Remember time is expensive and space is cheap.</li>
<li>If your approach is naive, attempt to optimize.</li>
<li>If not, ask your interviewer if they’d like you to optimize.</li>
</ul>
<h2 id="strategies">Strategies</h2>
<p>Keep a mental list of general strategies you can turn to. Here are a few:</p>
<ol type="1">
<li>Bucketizing with a hash: If the input set is bounded, try organizing it into a hash.
<ul>
<li>Ex: Sort an array of 100,000 integers that are all in the range 1-100</li>
</ul></li>
<li>Dynamic programming, or "divide and conquer": Divide into smaller and smaller but equal subproblems.
<ul>
<li>Ex: See <a href="http://www.careercup.com/question?id=19286747">this solution</a> for a Google interview question.</li>
</ul></li>
<li>Look for useful mathematical properties.
<ul>
<li>Sometimes you have individual values when really what you care about is their sums.</li>
<li>Ex: For an array of integers 1 - 100 where all elements appear once except one that appears twice, find the repeat.</li>
</ul></li>
<li><a href="http://en.wikipedia.org/wiki/Amortized_analysis">Amortized analysis</a>: it’s ok to do something memory- or space-intensive if you can prove that this cost comes with a greater payoff.
<ul>
<li>Ex: Implement a queue using two stacks.</li>
</ul></li>
<li>Keep a stack or a queue on the side to track values as your algorithm goes through the problem.</li>
<li>Keep two pointers for the same iteration.
<ul>
<li>Ex: Reverse a string in place (ie. using no more memory space than the length of the string).</li>
</ul></li>
<li>Perform an operation twice.
<ul>
<li>Ex: Reverse the word order of a string, but not the letters within the words.</li>
</ul></li>
<li>Sort the input.
<ul>
<li>Ex: Finding anagrams.</li>
</ul></li>
<li>Approach the problem from the other end.
<ul>
<li>Ex: see <a href="http://www.techinterview.org/post/526325766/pirates">this solution</a> for a Fog Creek interview question.</li>
</ul></li>
<li>Use binary numbers instead of decimal numbers.
<ul>
<li>Ex: see the <a href="http://www.techinterview.org/post/526313890/bad-king">famous Bad King</a> problem.</li>
</ul></li>
<li>For efficiency, use binary search instead of incrementation. Esp. good for implementing math operators.
<ul>
<li>Ex: Implement division without using "/", in less than O(n) time.</li>
</ul></li>
</ol>
<h2 id="dont-be-sly">Don’t be Sly</h2>
<p>If you don’t understand the problem, ask for clarification. A well-formulated question is as impressive as a good answer. If you don’t know something, don’t make it up. Tell the interviewer you don’t know and then try your best guess. Many interviewers will really like this. Same thing when you hit a snag. Don’t try to cover things up and make it look like you were on the right track. Explain to the interviewer why you think the current hypothesis actually won’t work.</p>
<h2 id="how-to-handle-questions-youve-seen-before.">How to handle questions you’ve seen before.</h2>
<p>What if you get a whiteboard problem you already know the solution to? Obviously the ethical thing is to tell your interviewer you’ve seen the problem before and you’ll get points for that. Put on a sad face to show you were excited about solving a new problem.</p>
<p>Furthermore, you won’t necessarily perform better on a question you’ve seen. You’ll probably solve it faster, but speed is overrated. On the other hand, it’s much harder to show your interviewer how you think when you’re really just recalling a solution. Note that the easiest parts of a problem are also the hardest to remember. So even if you confound your interviewer, they’ll be left wondering why you breezed through the hardest part of the problem while stumbling on the rest. That’s a failure to demonstrate how you think, which is the real purpose of a whiteboard problem.</p>
<hr />
<h1 id="white-boarding-exercises">White Boarding Exercises</h1>
<p>Work together to "white board" answers to the following problems. Your pair will present one of them at the end of the day.</p>
<p>You may not have real white boards on which to draw. If not, use the Zoom white board or just pen and paper. Talk through the answers. Determine if you are right.</p>
<p>When white boarding, you don’t have to necessarily draw images. You can write code or pseudocode or draw circles and arrows. Just something to indicate that you understand the problem and what it would take to solve it.</p>
<h2 id="mirror-image-trees">Mirror image trees</h2>
<p>Google asks in its interview process for you to draw an algorithm on a board that would return true if a binary tree is a mirror image of another binary tree.</p>
<h2 id="reverse-a-linked-list">Reverse a linked list</h2>
<p>Amazon and Microsoft ask you to show an algorithm that will reverse a singly-linked list, that is, a list that is made of nodes between which there is a unidirectional association as in the following image.</p>
<figure>
<img src="images/Singly-linked-list.svg" alt="singly-linked list" /><figcaption>singly-linked list</figcaption>
</figure>
<h2 id="the-missing-value">The missing value</h2>
<p>Amazon and Microsoft ask you to derive an algorithm that will inspect an array of of numbers that contains the values between 0 and the length of the list, inclusive, and find the missing value. For example, you may be given an array that of length 6 that contains</p>
<pre><code>[0, 2, 3, 4, 5, 6]</code></pre>
<p>It is your job to determine that the missing value from the array is 1.</p>
<h2 id="stack-min">Stack min</h2>
<p>Google and Apple ask you to design a stack that, in addition to the <code>push</code> and <code>pop</code> functions, has a function <code>min</code> that returns the minimum element in the stack <em>without</em> removing it. All three functions <code>push</code>, <code>pop</code>, and <code>min</code> should operate in O(1) time.</p>
<h2 id="test-a-retractable-ballpoint-pen">Test a retractable ballpoint pen</h2>
<p>Facebook asks you to write the tests cases for testing a ballpoint pen. What would you consider to be good tests for the pen? Try to be as exhaustive as possible.</p>
<h2 id="ooparking-lot">OOParking Lot</h2>
<p>Amazon and Microsoft ask you to specify the classes that it would take to write software to manage a paid parking lot. It should know where cars are parked, be able to identify the cars, know where the keys are hanging, how many cars are in the lot, what time the cars come and go, and how much it costs someone when they leave the parking lot based on the following schedule:</p>
<table>
<thead>
<tr class="header">
<th>Time</th>
<th>Rate per hour</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8pm - 6am</td>
<td>$3</td>
</tr>
<tr class="even">
<td>6am - noon</td>
<td>$10</td>
</tr>
<tr class="odd">
<td>noon - 6pm</td>
<td>$8</td>
</tr>
<tr class="even">
<td>6pm - 8pm</td>
<td>$6</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="week-08-day-2-binary-trees" data-ignore="true">WEEK-08 DAY-2<br><em>Binary Trees</em></h1>
<hr />
<h1 id="binary-trees-and-binary-search-trees-learning-objectives">Binary Trees and Binary Search Trees Learning Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to become comfortable with implementing common data structures. This is important because questions about data structures are incredibly likely to be interview questions for software engineers from junior to senior levels. Moreover, understanding how different data structures work will influence the libraries and frameworks that you choose when writing software.</p>
<p>When you are done, you will be able to:</p>
<ol type="1">
<li>Explain and implement a Binary Tree.</li>
<li>Identify the three types of tree traversals: pre-order, in-order, and post-order.</li>
<li>Explain and implement a Binary Search Tree.you to become comfortable with implementing common data structures. This is important because questions about data structures are incredibly likely to be interview questions for software engineers from junior to senior levels. Moreover, understanding how different data structures work will influence the libraries and frameworks that you choose when writing software.</li>
</ol>
<p>When you are done, you will be able to:</p>
<ol type="1">
<li>Explain and implement a Binary Tree.</li>
<li>Identify the three types of tree traversals: pre-order, in-order, and post-order.</li>
<li>Explain and implement a Binary Search Tree.</li>
</ol>
<hr />
<h1 id="binary-trees">Binary Trees</h1>
<p>Binary Trees are perhaps the most pervasive data structure in computer science. Let’s take a moment to go over the basic characteristics of a Binary Tree before we explore algorithms that utilize this structure.</p>
<h3 id="what-is-a-graph">What is a Graph?</h3>
<p>Before we define what a <strong>Tree</strong> is, we must first understand the definition of a <strong>Graph</strong>. A graph is a collection of <strong>nodes</strong> and any <strong>edges</strong> between those nodes. You’ve likely seen depictions of graphs before, they usually exist as circles (nodes) and arrows (edges) between those circles. Below are few examples of graphs:</p>
<figure>
<img src="images/graphs.png" alt="graphs" /><figcaption>graphs</figcaption>
</figure>
<p>For now, you can ignore the blue coloring. Notice how the graphs above vary greatly in their structure. A graph is indeed a very broad, overarching category. In fact, linked lists and trees are both considered subclasses of graphs. We’ll cover algorithms that operate on a general graph structure later, but for now we want to focus on what graphs are trees and what graphs are not. It’s worth mentioning that a single node with no edges (image 1) is considered a graph. The empty graph (a graph with 0 nodes and 0 edges, not pictured :)) is also still a graph. This line of thinking will help us later when we design graph algorithms.</p>
<h3 id="what-is-a-tree">What is a Tree?</h3>
<p>A <strong>Tree</strong> is a <strong>Graph</strong> that does not contain any cycles. A cycle is is defined as a path through edges that begins and ends at the same node. This seems straightforward, but the definition becomes a bit muddled as Mathematicians and Computer Scientists use the term "tree" in slightly different ways. Lets break it down:</p>
<ul>
<li>To a Mathematician, graphs 1, 2, 3, and 4 in the above image are trees.</li>
<li>To a Computer Scientist, only graphs 1 ,2, and 3 are trees.</li>
</ul>
<p>Well, at least both camps agree that graph 5 is most certainly not a tree! This is because of the obvious cycle that spans all three nodes. However, why is there disagreement over graph 4? The reason is this: In computer science, we use to the term "tree" to really refer to a "rooted tree." A "rooted tree" is a "tree" where there exists a special node from which every other node is accessible; we call this special node the "root". Think of the root as ultimate ancestor, the single node that all other nodes inherit from. Above we have colored all roots in blue. Like you’d probably suspect, in this course we’ll subscribe to the Computer Scientist’s interpretation. That is, we won’t consider graph 4 a tree because there is no such root we can label.</p>
<p>You’ve probably heard the term "root" throughout your software engineering career: root directory, root user, etc.. All of these concepts branch† from the humble tree data structure!</p>
<h3 id="what-is-a-binary-tree">What is a Binary Tree?</h3>
<p>A <strong>Binary Tree</strong> is a <strong>Tree</strong> where nodes have <strong>at most 2 children</strong>. This means graphs 1, 2, and 3 are all Binary Trees. There exist ternary trees (at most 3 children) and n-ary trees (at most n children), but you’ll likely encounter binary trees in your job hunt, so we’ll focus on them in this course. Based on our final definition for a binary tree, here is some food for thought:</p>
<ul>
<li>an empty graph of 0 nodes and 0 edges is a binary tree</li>
<li>a graph of 1 node and 0 edges is a binary tree</li>
<li>a linked list is a binary tree</li>
</ul>
<p>Take a moment to use the definitions we explored to verify that each of the three statements above is true. We bring up these three scenarios in particular because they are the simplest types of Binary Trees. We want to eventually build elegant algorithms and these simple scenarios will fuel our design.</p>
<h3 id="representing-a-binary-tree-with-node-instances">Representing a Binary Tree with Node Instances</h3>
<p>Let’s explore a common way to represent binary trees using some object oriented design. A tree is a collection of nodes, so let’s implement a <code>TreeNode</code> class. We’ll use properties of <code>left</code> and <code>right</code> to reference the children of a <code>TreeNode</code>. That is, <code>left</code> and <code>right</code> will reference other <code>TreeNode</code>s:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> TreeNode <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="at">constructor</span>(val) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">this</span>.<span class="at">val</span> <span class="op">=</span> val<span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="kw">this</span>.<span class="at">left</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">this</span>.<span class="at">right</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>Constructing a tree is a matter of creating the nodes and setting <code>left</code> and <code>right</code> however we please. For example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">TreeNode</span>(<span class="st">&#39;a&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">let</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">TreeNode</span>(<span class="st">&#39;b&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">let</span> c <span class="op">=</span> <span class="kw">new</span> <span class="at">TreeNode</span>(<span class="st">&#39;c&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">let</span> d <span class="op">=</span> <span class="kw">new</span> <span class="at">TreeNode</span>(<span class="st">&#39;d&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">let</span> e <span class="op">=</span> <span class="kw">new</span> <span class="at">TreeNode</span>(<span class="st">&#39;e&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">let</span> f <span class="op">=</span> <span class="kw">new</span> <span class="at">TreeNode</span>(<span class="st">&#39;f&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="va">a</span>.<span class="at">left</span> <span class="op">=</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="va">a</span>.<span class="at">right</span> <span class="op">=</span> c<span class="op">;</span></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="va">b</span>.<span class="at">left</span> <span class="op">=</span> d<span class="op">;</span></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="va">b</span>.<span class="at">right</span> <span class="op">=</span> e<span class="op">;</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="va">c</span>.<span class="at">right</span> <span class="op">=</span> f<span class="op">;</span></a></code></pre></div>
<p>The visual representation of the tree is:</p>
<figure>
<img src="images/graph_a.png" alt="graph_a" /><figcaption>graph_a</figcaption>
</figure>
<p>To simplify our diagrams, we’ll omit the arrowheads on the edges. Moving forward you can assume that the top node is the root and the direction of edges points downward. In other words, node A is the Root. Node A can access node B through <code>a.left</code>, but Node B cannot access Node A.</p>
<p>We now have a data structure we can use to explore Binary Tree algorithms! Creating a tree in this way may be tedious and repetitive, however it allows us to decide exactly what nodes are connected and in what direction. This is will be useful as we account for edge cases in our design.</p>
<h3 id="basic-tree-terminology">Basic Tree Terminology</h3>
<ul>
<li>tree - graph with no cycles</li>
<li>binary tree - tree where nodes have at most 2 nodes</li>
<li>root - the ultimate parent, the single node of a tree that can access every other node through edges; by definition the root will not have a parent</li>
<li>internal node - a node that has children</li>
<li>leaf - a node that does not have any children</li>
<li>path - a series of nodes that can be traveled through edges - for example A, B, E is a path through the above tree</li>
</ul>
<p>† Pun Intended</p>
<h2 id="traversing-trees">Traversing trees</h2>
<p>Unlike linked lists, arrays and other linear data structures, which are usually traversed in linear order from front to back or back to front, trees may be traversed in multiple ways. They may be traversed in depth-first or breadth-first order. There are three common ways to traverse them in depth-first order: in-order, pre-order and post-order.</p>
<h3 id="breadth-first-search">Breadth-first search</h3>
<p>Trees can also be traversed level-by-level, where you visit every node on a level before going to a lower level. This search is referred to as breadth-first search (BFS), as the search tree is broadened as much as possible on each depth before going to the next depth.</p>
<figure>
<img src="images/File:Sorted_binary_tree_breadth-first_traversal.svg" alt="breadth-first tree traversal" /><figcaption>breadth-first tree traversal</figcaption>
</figure>
<h3 id="depth-first-searches">Depth-first searches</h3>
<p>These searches are referred to as depth-first search (DFS), since the search tree is deepened as much as possible on each child before going to the next sibling.</p>
<figure>
<img src="images/Sorted_binary_tree_ALL.svg" alt="depth-first tree traversal" /><figcaption>depth-first tree traversal</figcaption>
</figure>
<h4 id="pre-order-traversal">Pre-order traversal</h4>
<p>In the above image, the pre-order is noted by when the dotted line touches the red dot and yields F, B, A, D, C, E, G, I, H. The algorithm is as follows and is "pre-order" because you access the value of the node before recursively descending.</p>
<ul>
<li>Access the data of the current node</li>
<li>Recursively visit the left sub tree</li>
<li>Recursively visit the right sub tree</li>
</ul>
<h4 id="in-order-traversal">In-order traversal</h4>
<p>In the above image, the in-order is noted by when the dotted line touches the yellow dot and yields A, B, C, D, E, F, G, H, I. The algorithm is as follows and is "in-order" because you access the value of the node after descending to the left but before descending to the right.</p>
<ul>
<li>Recursively visit the left sub tree</li>
<li>Access the data of the current node</li>
<li>Recursively visit the right sub tree</li>
</ul>
<h4 id="post-order-traversal">Post-order traversal</h4>
<p>In the above image, the post-order is noted by when the dotted line touches the green dot and yields A, C, E, D, B, H, I, G, F. The algorithm is as follows and is "post-order" because you access the value of the node after descending to both branches.</p>
<ul>
<li>Recursively visit the left sub tree</li>
<li>Recursively visit the right sub tree</li>
<li>Access the data of the current node</li>
</ul>
<hr />
<h1 id="binary-search-trees">Binary Search Trees</h1>
<p>Now that we have a solid grasp of <strong>Binary Trees</strong>, let’s add another constraint to the data structure. A Binary <strong>Search</strong> Tree (BST) has an additional criteria where:</p>
<ul>
<li>given any node of the tree, the values in the left subtree must all be strictly less than the given node’s value.</li>
<li>and the values in the right subtree must all be greater than or equal to the given node’s value</li>
</ul>
<h3 id="bst-definition">BST Definition</h3>
<p>We can also describe a BST using a recursive definition. A <strong>Binary Tree</strong> is a <strong>Binary Search Tree</strong> if:</p>
<ul>
<li>the left subtree contains values less than the root</li>
<li>AND the right subtree contains values greater than or equal to the root</li>
<li>AND the left subtree is a Binary Search Tree</li>
<li>AND the right subtree is a Binary Search Tree</li>
</ul>
<p>It’s worth mentioning that the empty tree (a tree with 0 nodes) is indeed a BST (did someone say base case?).</p>
<p>Here are a few examples of BSTs:</p>
<figure>
<img src="images/bsts.png" alt="bsts" /><figcaption>bsts</figcaption>
</figure>
<p>Take a moment to verify that the above binary trees are BSTs. Note that image 2 has the same chain structure as a linked list. This will come into play later.</p>
<p>Below is an example of a binary tree that is <strong>not</strong> a search tree because a left child (35) is greater than it’s parent (23):</p>
<figure>
<img src="images/not_bst.png" alt="not_bst" /><figcaption>not_bst</figcaption>
</figure>
<h3 id="a-bst-is-a-sorted-data-structure">A BST is a Sorted Data Structure</h3>
<p>So what’s the big deal with BSTs? Well, because of the properties of a BST, we can consider the tree as having an order to the values. That means the values are fully sorted! By looking at the three BST examples above, you are probably not convinced of things being sorted. This is because the ordering is encoded by an in-order traversal. Let’s recall our previous <code>inOrderPrint</code> function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span> <span class="at">inOrderPrint</span>(root) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="cf">if</span> (<span class="op">!</span>root) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="at">inOrderPrint</span>(<span class="va">root</span>.<span class="at">left</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="va">root</span>.<span class="at">val</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="at">inOrderPrint</span>(<span class="va">root</span>.<span class="at">right</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>If we run <code>inOrderPrint</code> on the three BSTs, we will get the following output:</p>
<pre><code>BST 1: 42
BST 2: 4, 5, 6
BST 3: 1, 5, 7, 10, 16, 16</code></pre>
<p>For each tree, we printed out values in increasing order! A binary search tree contains sorted data; this will come into play when we perform algorithms on this data structure.</p>
<p>Once you create a binary search tree class <code>BST</code>, you can call <code>insert</code> to build up the <code>BST</code> without worrying about breaking the search tree property. Here are two different trees built with the <code>BST</code> class that you’ll write.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">let</span> tree1 <span class="op">=</span> <span class="kw">new</span> <span class="at">BST</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="va">tree1</span>.<span class="at">insert</span>(<span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="va">tree1</span>.<span class="at">insert</span>(<span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="va">tree1</span>.<span class="at">insert</span>(<span class="dv">16</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="va">tree1</span>.<span class="at">insert</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="va">tree1</span>.<span class="at">insert</span>(<span class="dv">7</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="va">tree1</span>.<span class="at">insert</span>(<span class="dv">16</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="kw">let</span> tree2 <span class="op">=</span> <span class="kw">new</span> <span class="at">BST</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="va">tree2</span>.<span class="at">insert</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="va">tree2</span>.<span class="at">insert</span>(<span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="va">tree2</span>.<span class="at">insert</span>(<span class="dv">7</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="va">tree2</span>.<span class="at">insert</span>(<span class="dv">10</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="va">tree2</span>.<span class="at">insert</span>(<span class="dv">16</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="va">tree2</span>.<span class="at">insert</span>(<span class="dv">16</span>)<span class="op">;</span></a></code></pre></div>
<p>The insertions above will yield the following trees:</p>
<figure>
<img src="images/good_bad_bst.png" alt="good_bad_bst" /><figcaption>good_bad_bst</figcaption>
</figure>
<p>Are you cringing at <code>tree2</code>? You should be. Although we have the same values in both trees, they display drastically different structures because of the insertion order we used. This is why we have been referring to our <code>BST</code> implementation as <strong>naive</strong>. Both of these trees are Binary Search Trees, however not all BSTs are created equal. A worst case BST degenerates into a linked list. The "best" BSTs are <strong>height balanced</strong>, we’ll explore this concept soon™.</p>
<h2 id="a-special-traversal-case">A special traversal case</h2>
<p>In a binary search tree, in-order traversal retrieves the keys in <strong>ascending sorted order</strong>. Please review the image that you saw before about tree traversal.</p>
<figure>
<img src="images/Sorted_binary_tree_ALL.svg" alt="depth-first tree traversal" /><figcaption>depth-first tree traversal</figcaption>
</figure>
<p>Note that the in-order sort represented by where the dotted line touches the yellow dots results in node visiting in the order A, B, C, D, E, F, G, H, I. In-order traversal <em>always</em> visits the nodes in sequential order in a binary search tree.</p>
<hr />
<h1 id="binary-tree-project">Binary Tree Project</h1>
<p>This project contains a skeleton for you to implement a binary tree. This is a test-driven project. Run the tests and read the top-most error. If it’s not clear what is failing, open the <strong>test/test.js</strong> file to figure out what the test is expecting. Make the top-most test pass.</p>
<p>Keep making the top-most test pass until all tests pass.</p>
<p>The algorithms for the traversal functions are in the files and are reproduced here.</p>
<pre><code>procedure in order array (node)
  parameter node: a tree node

  if the tree node is null, return an empty array

  // get the array for visiting the left node of node
  // get the array for visiting the right node of node

  // return the left array concatenated with the node value
  //   concatenated with the right array
end procedure in order array</code></pre>
<pre><code>procedure post order array (node)
  parameter node: a tree node

  if the tree node is null, return an empty array

  // get the array for visiting the left node of node
  // get the array for visiting the right node of node

  // return the left array concatenated with the right array
  //   concatenated with the node value
end procedure post order array</code></pre>
<h2 id="instructions">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/-starters/data-structures-binary-tree-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>test/test.js</code>. Your job is to write code in
<ul>
<li><strong>lib/tree_node.js</strong> to implement the <code>TreeNode</code> class</li>
<li><strong>lib/tree_order.js</strong> to implement the <code>inOrderArray</code> and <code>postOrderArray</code> functions to traverse a tree</li>
<li><strong>BONUS: lib/leet_code_105.js</strong> as a scratch pad to work on the LeetCode.com problem at https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</li>
</ul></li>
</ul>
<hr />
<h1 id="binary-search-tree-project">Binary Search Tree Project</h1>
<p>This project contains a skeleton for you to implement a binary search tree. This is a test-driven project. Run the tests and read the top-most error. If it’s not clear what is failing, open the <strong>test/test.js</strong> file to figure out what the test is expecting. Make the top-most test pass.</p>
<p>Keep making the top-most test pass until all tests pass.</p>
<h2 id="instructions-1">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/-starters/data-structures-binary-search-tree-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>test/test.js</code>. Your job is to write code in
<ul>
<li><strong>lib/bst.js</strong> to implement the <code>BST</code> class</li>
<li><strong>BONUS: lib/leet_code_108.js</strong> as a scratch pad to work on the LeetCode.com problem at https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</li>
<li><strong>BONUS: lib/leet_code_110.js</strong> as a scratch pad to work on the LeetCode.com problem at https://leetcode.com/problems/balanced-binary-tree/</li>
</ul></li>
</ul>
<hr />
<h1 id="week-08-day-3-graphs" data-ignore="true">WEEK-08 DAY-3<br><em>Graphs</em></h1>
<hr />
<h1 id="graphs-and-heaps-learning-objectives">Graphs and Heaps Learning Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to become comfortable with implementing common data structures. This is important because questions about data structures are incredibly likely to be interview questions for software engineers from junior to senior levels. Moreover, understanding how different data structures work will influence the libraries and frameworks that you choose when writing software.</p>
<p>When you are done, you will be able to:</p>
<ol type="1">
<li>Explain and implement a Heap.</li>
<li>Explain and implement a Graph.table with implementing common data structures. This is important because questions about data structures are incredibly likely to be interview questions for software engineers from junior to senior levels. Moreover, understanding how different data structures work will influence the libraries and frameworks that you choose when writing software.</li>
</ol>
<p>When you are done, you will be able to:</p>
<ol type="1">
<li>Explain and implement a Heap.</li>
<li>Explain and implement a Graph.</li>
</ol>
<hr />
<h1 id="graphs">Graphs</h1>
<p>It’s time to generalize our knowledge! We’ve explored binary trees and the fundamental algorithms that accompany them. Naturally, we implemented these algorithms assuming the constraints of a binary tree. To review, these assumptions include the lack of cycles, a maximum of two children, and a single root node. However, what if we take away these constraints? How can we modify the algorithms to operate on general graphs?</p>
<h2 id="what-is-a-graph-1">What is a Graph?</h2>
<p>A <strong>graph</strong> is <strong>any</strong> collection of nodes and edges. In contrast to our previous trees, a graph is much more relaxed in it’s structure. A graph may:</p>
<ul>
<li>lack a root node</li>
<li>have cycles</li>
<li>have any number edges leaving a node</li>
</ul>
<p>In this section, we will draw heavily from our tree algorithms. The adjustments we will make to those algorithms will be motivated by these core differences.</p>
<p>Below are a few examples of graphs that don’t agree with our CompSci definition of a binary tree:</p>
<figure>
<img src="images/graphs.png" alt="graphs" /><figcaption>graphs</figcaption>
</figure>
<p>Here are some highlights:</p>
<ul>
<li><code>Graph 1</code> lacks a root. This means there is no single node that can access all other nodes in a path through edges. This is important because we previously referenced "entire" trees by referring to the ultimate root. We can no longer do that in a graph. If we provide just <code>T</code>, you can’t access <code>U</code>. If we provide just <code>U</code>, you can’t access <code>T</code>. If we provide just <code>V</code>, you can’t access <code>T</code> or <code>U</code>.</li>
<li><code>Graph 2</code> has a cycle. This means there is no longer a parent-child relationship. Choose any node in <code>Graph 2</code>, its grandchild will also be its parent. Wait - what? From now on we’ll have to use less specific language such as "<code>X</code> is a neighbor of <code>Y</code>." Perhaps even more deadly, imagine we ran a "simple" Depth-First traversal on this graph. We could get trapped in an infinite loop if we are not careful.</li>
<li><code>Graph 3</code> features nodes that have more than 2 edges. Anarchy!</li>
</ul>
<h2 id="graph-implementations">Graph Implementations</h2>
<p>There are many ways to represent a graph programmatically. Let’s take a moment to explore each and describe the tradeoffs we make when choosing among them. We will use <code>Graph 3</code> from above as our candidate. Bear in mind that our graph is directed. For example, this means that <code>C</code> can access <code>D</code>, but <code>D</code> cannot access <code>C</code>.</p>
<h3 id="graphnode-class">GraphNode Class</h3>
<p>This implementation is most similar to how we implemented binary trees. That is, we create a node class that maintains a value and an array of references to neighboring nodes. This easily solves the problem that a node can have any number of neighbors, no longer just a left and right.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">class</span> GraphNode <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="at">constructor</span>(val) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-3" title="3">        <span class="kw">this</span>.<span class="at">val</span> <span class="op">=</span> val<span class="op">;</span></a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="kw">this</span>.<span class="at">neighbors</span> <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="op">}</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="kw">let</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;a&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="kw">let</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;b&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="kw">let</span> c <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;c&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="kw">let</span> d <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;d&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="kw">let</span> e <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;e&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="kw">let</span> f <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;f&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-14" title="14"><span class="va">a</span>.<span class="at">neighbors</span> <span class="op">=</span> [b<span class="op">,</span> c<span class="op">,</span> e]<span class="op">;</span></a>
<a class="sourceLine" id="cb9-15" title="15"><span class="va">c</span>.<span class="at">neighbors</span> <span class="op">=</span> [b<span class="op">,</span> d]<span class="op">;</span></a>
<a class="sourceLine" id="cb9-16" title="16"><span class="va">e</span>.<span class="at">neighbors</span> <span class="op">=</span> [a]<span class="op">;</span></a>
<a class="sourceLine" id="cb9-17" title="17"><span class="va">f</span>.<span class="at">neighbors</span> <span class="op">=</span> [e]<span class="op">;</span></a></code></pre></div>
<p>This implementation is great because it feels familiar to how we implemented trees. However, this implementation is clunky in that we have no easy way to refer to the entire graph. How can we pass this graph to a function? Recall that there is no root to act as the definite starting point.</p>
<h3 id="adjacency-matrix">Adjacency Matrix</h3>
<p>This is the often the mathematician’s preferred way of representing a graph. We use a 2D array to represent edges. We’ll first map each node’s value to an index. This means <code>A -&gt; 0</code>, <code>B -&gt; 1</code>, <code>C -&gt; 2</code>, etc.. Below is the mapping for <code>Graph 3</code>:</p>
<figure>
<img src="images/adj_matrix_graph.png" alt="adj_matrix_graph" /><figcaption>adj_matrix_graph</figcaption>
</figure>
<p>From here, the row index will correspond to the source of an edge and the column index will correspond to its destination. A value of <code>true</code> will mean that there does exist an edge from source to destination.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">let</span> matrix <span class="op">=</span> [</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">/*          A       B       C       D       E       F   */</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">/*A*/</span>    [<span class="kw">true</span><span class="op">,</span>  <span class="kw">true</span><span class="op">,</span>   <span class="kw">true</span><span class="op">,</span>   <span class="kw">false</span><span class="op">,</span>  <span class="kw">true</span><span class="op">,</span>   <span class="kw">false</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">/*B*/</span>    [<span class="kw">false</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span>   <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">/*C*/</span>    [<span class="kw">false</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span>   <span class="kw">true</span><span class="op">,</span>   <span class="kw">true</span><span class="op">,</span>   <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">/*D*/</span>    [<span class="kw">false</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">true</span><span class="op">,</span>   <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co">/*E*/</span>    [<span class="kw">true</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">true</span><span class="op">,</span>   <span class="kw">false</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">/*F*/</span>    [<span class="kw">false</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">false</span><span class="op">,</span>  <span class="kw">true</span><span class="op">,</span>   <span class="kw">true</span>]</a>
<a class="sourceLine" id="cb10-9" title="9">]<span class="op">;</span></a></code></pre></div>
<p>A few things to note about using an adjacency matrix:</p>
<ul>
<li>when the edges have direction, <code>matrix[i][j]</code> may not be the same as <code>matrix[j][i]</code></li>
<li>it is common to say that a node is adjacent to itself, so <code>matrix[x][x] === true</code> for any <code>x</code></li>
</ul>
<p>An advantage of the matrix implementation is that it allows us to refer to the entire graph by simply referring to the 2D array. A huge disadvantage of using a matrix is the space required. To represent a graph of n nodes, we must allocate n<sup>2</sup> space for the 2D array. This is even more upsetting when there are few edges in graph. We will have to use n<sup>2</sup> space, even though the array would be sparse with only a few <code>true</code> elements.</p>
<h3 id="adjacency-list">Adjacency List</h3>
<p>An adjacency list seeks to solve the shortcomings of the matrix implementation. We use an object where keys represent the node labels. The values associated with the keys will be an array containing all adjacent nodes:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">let</span> graph <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="st">&#39;a&#39;</span><span class="op">:</span> [<span class="st">&#39;b&#39;</span><span class="op">,</span> <span class="st">&#39;c&#39;</span><span class="op">,</span> <span class="st">&#39;e&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="st">&#39;b&#39;</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="st">&#39;c&#39;</span><span class="op">:</span> [<span class="st">&#39;b&#39;</span><span class="op">,</span> <span class="st">&#39;d&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="st">&#39;d&#39;</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="st">&#39;e&#39;</span><span class="op">:</span> [<span class="st">&#39;a&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="st">&#39;f&#39;</span><span class="op">:</span> [<span class="st">&#39;e&#39;</span>]</a>
<a class="sourceLine" id="cb11-8" title="8"><span class="op">};</span></a></code></pre></div>
<p>An adjacency list is easy to implement and allows us to refer to the entire graph by simply referencing the object. The space required for an adjacency list is the number of edges in the graph. Since there will be at most n<sup>2</sup> edges in a graph of n nodes, the adjacency list will use at most the same amount of space as the matrix. You’ll find adjacency lists useful when attacking problems that are not explicitly about graphs. We’ll elaborate more on this soon.</p>
<hr />
<h1 id="graph-traversal">Graph Traversal</h1>
<p>Let’s explore our classic Depth-First, but for <strong>graphs</strong> this time! We’ll be utilizing the <code>GraphNode</code> and <code>Adjacency List</code> implementations of the following graph:</p>
<figure>
<img src="images/graph.png" alt="graph" /><figcaption>graph</figcaption>
</figure>
<p>Since we already discussed the differences between Depth-First and Breadth-First, we’ll focus just on Depth-First here. We’ll leave the Breadth-First exploration in the upcoming project.</p>
<h3 id="graph-traversal-w-graphnode">Graph Traversal w/ GraphNode</h3>
<p>Let’s begin by assuming we have our candidate graph implemented using our <code>GraphNode</code> class:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">class</span> GraphNode <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="at">constructor</span>(val) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-3" title="3">        <span class="kw">this</span>.<span class="at">val</span> <span class="op">=</span> val<span class="op">;</span></a>
<a class="sourceLine" id="cb12-4" title="4">        <span class="kw">this</span>.<span class="at">neighbors</span> <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="op">}</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb12-7" title="7"></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="kw">let</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;a&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="kw">let</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;b&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="kw">let</span> c <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;c&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="kw">let</span> d <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;d&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="kw">let</span> e <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;e&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-13" title="13"><span class="kw">let</span> f <span class="op">=</span> <span class="kw">new</span> <span class="at">GraphNode</span>(<span class="st">&#39;f&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="va">a</span>.<span class="at">neighbors</span> <span class="op">=</span> [e<span class="op">,</span> c<span class="op">,</span> b]<span class="op">;</span></a>
<a class="sourceLine" id="cb12-15" title="15"><span class="va">c</span>.<span class="at">neighbors</span> <span class="op">=</span> [b<span class="op">,</span> d]<span class="op">;</span></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="va">e</span>.<span class="at">neighbors</span> <span class="op">=</span> [a]<span class="op">;</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="va">f</span>.<span class="at">neighbors</span> <span class="op">=</span> [e]<span class="op">;</span></a></code></pre></div>
<p>One thing we’ll have to decide on is what node to begin our traversal. Depending on the structure of the graph, there may not be a suitable starting point. Remember that a graph may not have a "root". However in our candidate, <code>F</code> is like a root. It is the only valid choice because it is the only node that may access all other nodes through some path of edges. We admit, the choice of <code>F</code> is somewhat contrived and in a practical setting you may not have a nice starting point like this. We’ll cover how to overcome this obstacle soon. For now we’ll take <code>F</code>.</p>
<p>We want to build a recursive <code>depthFirstRecur</code> function that accepts a node and performs a Depth-First traversal through the graph. Let’s begin with a baseline solution, although it is not yet complete to handle all graphs:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// broken</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">function</span> <span class="at">depthFirstRecur</span>(node) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="va">node</span>.<span class="at">val</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="va">node</span>.<span class="va">neighbors</span>.<span class="at">forEach</span>(neighbor <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-6" title="6">        <span class="at">depthFirstRecur</span>(neighbor)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-7" title="7">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb13-9" title="9"></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="at">depthFirstRecur</span>(f)<span class="op">;</span></a></code></pre></div>
<p>Can you see where this code goes wrong? It will get caught in an infinite cycle <code>f, e, a, e, a, e, a, e, ...</code> ! To fix this, simply store which nodes we have visited already. Whenever we hit a node that has previously been visited, then return early. We’ll use JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Sets</a> to store <code>visited</code> because they allow for constant time lookup.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// using GraphNode representation</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">function</span> <span class="at">depthFirstRecur</span>(node<span class="op">,</span> visited<span class="op">=</span><span class="kw">new</span> <span class="at">Set</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="co">// if this node has already been visited, then return early</span></a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="cf">if</span> (<span class="va">visited</span>.<span class="at">has</span>(<span class="va">node</span>.<span class="at">val</span>)) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">    <span class="co">// otherwise it hasn&#39;t yet been visited,</span></a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="co">// so print it&#39;s val and mark it as visited.</span></a>
<a class="sourceLine" id="cb14-9" title="9">    <span class="va">console</span>.<span class="at">log</span>(<span class="va">node</span>.<span class="at">val</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-10" title="10">    <span class="va">visited</span>.<span class="at">add</span>(<span class="va">node</span>.<span class="at">val</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-11" title="11"></a>
<a class="sourceLine" id="cb14-12" title="12">    <span class="co">// then explore each of its neighbors</span></a>
<a class="sourceLine" id="cb14-13" title="13">    <span class="va">node</span>.<span class="va">neighbors</span>.<span class="at">forEach</span>(neighbor <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-14" title="14">        <span class="at">depthFirstRecur</span>(neighbor<span class="op">,</span> visited)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-15" title="15">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb14-17" title="17"></a>
<a class="sourceLine" id="cb14-18" title="18"><span class="at">depthFirstRecur</span>(f)<span class="op">;</span></a></code></pre></div>
<p>This code works well and will print the values in the order <code>f, e, a, c, b, d</code>. Note that this strategy only works if the values are guaranteed to be unique.</p>
<p>If you are averse to recursion (don’t be), we can write an iterative version using the same principles:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">function</span> <span class="at">depthFirstIter</span>(node) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="kw">let</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="at">Set</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">let</span> stack <span class="op">=</span> [ node ]<span class="op">;</span></a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="cf">while</span> (<span class="va">stack</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-6" title="6">        <span class="kw">let</span> node <span class="op">=</span> <span class="va">stack</span>.<span class="at">pop</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb15-7" title="7"></a>
<a class="sourceLine" id="cb15-8" title="8">        <span class="co">// if this node has already been visited, then skip this node</span></a>
<a class="sourceLine" id="cb15-9" title="9">        <span class="cf">if</span> (<span class="va">visited</span>.<span class="at">has</span>(<span class="va">node</span>.<span class="at">val</span>)) <span class="cf">continue</span><span class="op">;</span></a>
<a class="sourceLine" id="cb15-10" title="10"></a>
<a class="sourceLine" id="cb15-11" title="11">        <span class="co">// otherwise it hasn&#39;t yet been visited,</span></a>
<a class="sourceLine" id="cb15-12" title="12">        <span class="co">// so print it&#39;s val and mark it as visited.</span></a>
<a class="sourceLine" id="cb15-13" title="13">        <span class="va">console</span>.<span class="at">log</span>(<span class="va">node</span>.<span class="at">val</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-14" title="14">        <span class="va">visited</span>.<span class="at">add</span>(<span class="va">node</span>.<span class="at">val</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-15" title="15"></a>
<a class="sourceLine" id="cb15-16" title="16">        <span class="co">// then add its neighbors to the stack to be explored</span></a>
<a class="sourceLine" id="cb15-17" title="17">        <span class="va">stack</span>.<span class="at">push</span>(...<span class="va">node</span>.<span class="at">neighbors</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-18" title="18">    <span class="op">}</span></a>
<a class="sourceLine" id="cb15-19" title="19"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-20" title="20"></a>
<a class="sourceLine" id="cb15-21" title="21"><span class="at">depthFirstIter</span>(f)<span class="op">;</span></a></code></pre></div>
<h3 id="graph-traversal-w-adjacency-list">Graph Traversal w/ Adjacency List</h3>
<p>Let’s now assume our candidate graph in the form of an Adjacency List:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">let</span> graph <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="st">&#39;a&#39;</span><span class="op">:</span> [<span class="st">&#39;b&#39;</span><span class="op">,</span> <span class="st">&#39;c&#39;</span><span class="op">,</span> <span class="st">&#39;e&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="st">&#39;b&#39;</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="st">&#39;c&#39;</span><span class="op">:</span> [<span class="st">&#39;b&#39;</span><span class="op">,</span> <span class="st">&#39;d&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="st">&#39;d&#39;</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="st">&#39;e&#39;</span><span class="op">:</span> [<span class="st">&#39;a&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb16-7" title="7">    <span class="st">&#39;f&#39;</span><span class="op">:</span> [<span class="st">&#39;e&#39;</span>]</a>
<a class="sourceLine" id="cb16-8" title="8"><span class="op">};</span></a></code></pre></div>
<p>Bear in mind that the nodes are just strings now, not <code>GraphNode</code>s. Other than that, the code shares many details from our previous implementations:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// using Adjacency List representation</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="kw">function</span> <span class="at">depthFirstRecur</span>(node<span class="op">,</span> graph<span class="op">,</span> visited<span class="op">=</span><span class="kw">new</span> <span class="at">Set</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="cf">if</span> (<span class="va">visited</span>.<span class="at">has</span>(node)) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="va">console</span>.<span class="at">log</span>(node)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-7" title="7">    <span class="va">visited</span>.<span class="at">add</span>(node)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-8" title="8"></a>
<a class="sourceLine" id="cb17-9" title="9">    graph[node].<span class="at">forEach</span>(neighbor <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-10" title="10">        <span class="at">depthFirstRecur</span>(neighbor<span class="op">,</span> graph<span class="op">,</span> visited)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-11" title="11">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="op">}</span></a>
<a class="sourceLine" id="cb17-13" title="13"></a>
<a class="sourceLine" id="cb17-14" title="14"><span class="at">depthFirstRecur</span>(<span class="st">&#39;f&#39;</span><span class="op">,</span> graph)<span class="op">;</span></a></code></pre></div>
<p>Cool! We print values in the order <code>f, e, a, b, c, d</code>. We’ll leave the iterative version to you as an exercise for later.</p>
<p>Instead, let’s draw our attention to a point from before: having to choose <code>f</code> as the starting point isn’t dynamic enough to be impressive. Also, if we choose a poor initial node, some nodes may be unreachable. For example, choosing <code>a</code> as the starting point with a call to <code>depthFirstRecur('a', graph)</code> will only print <code>a, b, c, d, e</code>. We missed out on <code>f</code>. Bummer.</p>
<p>We can fix this. A big advantage of using an Adjacency List is that it contains the full graph! We can use a surrounding loop to allow our traversal to jump between disconnected regions of the graph. Refactoring our code:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">function</span> <span class="at">depthFirst</span>(graph) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="kw">let</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="at">Set</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="cf">for</span> (<span class="kw">let</span> node <span class="kw">in</span> graph) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-5" title="5">        <span class="at">_depthFirstRecur</span>(node<span class="op">,</span> graph<span class="op">,</span> visited)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb18-8" title="8"></a>
<a class="sourceLine" id="cb18-9" title="9"><span class="kw">function</span> <span class="at">_depthFirstRecur</span>(node<span class="op">,</span> graph<span class="op">,</span> visited) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-10" title="10">    <span class="cf">if</span> (<span class="va">visited</span>.<span class="at">has</span>(node)) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb18-11" title="11"></a>
<a class="sourceLine" id="cb18-12" title="12">    <span class="va">console</span>.<span class="at">log</span>(node)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-13" title="13">    <span class="va">visited</span>.<span class="at">add</span>(node)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-14" title="14"></a>
<a class="sourceLine" id="cb18-15" title="15">    graph[node].<span class="at">forEach</span>(neighbor <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-16" title="16">        <span class="at">_depthFirstRecur</span>(neighbor<span class="op">,</span> graph<span class="op">,</span> visited)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-17" title="17">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-18" title="18"><span class="op">}</span></a>
<a class="sourceLine" id="cb18-19" title="19"></a>
<a class="sourceLine" id="cb18-20" title="20"><span class="at">depthFirst</span>(graph)<span class="op">;</span></a></code></pre></div>
<p>Notice that our main function <code>depthFirst</code> is iterative and accepts the entire Adjacency List as an Argo. Our helper <code>_depthFirstRecur</code> is recursive. <code>_depthFirstRecur</code> serves the same job as before, it will explore a full connected region in a graph. The main <code>depthFirst</code> method will allow us to "bridge" the gap between connection regions.</p>
<p>Still fuzzy? Imagine we had the following graph. Before you ask, these are not two separate graphs. This is a <strong>single</strong> graph that contains two connected components. Another term for a graph of this structure is a "Forest" because it contains multiple "Trees", ha:</p>
<figure>
<img src="images/forest.png" alt="forest" /><figcaption>forest</figcaption>
</figure>
<p>It is easy to represent this graph using an Adjacency List. We can then pass the graph into our <code>depthFirst</code> from above:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">let</span> graph <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-2" title="2">    <span class="st">&#39;h&#39;</span><span class="op">:</span> [<span class="st">&#39;i&#39;</span><span class="op">,</span> <span class="st">&#39;j&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="st">&#39;i&#39;</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="st">&#39;j&#39;</span><span class="op">:</span> [<span class="st">&#39;k&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="st">&#39;k&#39;</span><span class="op">:</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="st">&#39;l&#39;</span><span class="op">:</span> [<span class="st">&#39;m&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb19-7" title="7">    <span class="st">&#39;m&#39;</span><span class="op">:</span> []</a>
<a class="sourceLine" id="cb19-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb19-9" title="9"></a>
<a class="sourceLine" id="cb19-10" title="10"><span class="at">depthFirst</span>(graph)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-11" title="11"><span class="co">// prints h, i, j, k, l, m</span></a></code></pre></div>
<p>Here’s the description for how <code>depthFirst</code> operates above. We enter <code>depthFirst</code> and the for loop begins on <code>h</code>. This means we enter our <code>_depthFirstRecur</code>, which will continue to explore the "local" region as far as possible. When this recursion ends, we would have explored the entire connected region of <code>h, i, j, k</code> (note that we add these nodes to visited as well). Our recursive call then returns to the main <code>depthFirst</code> function, where we continue the for loop. We iterate it until we hit an unvisited node (<code>l</code>) and then explore it’s local region as far as possible using <code>_depthFirstRecur</code>, hitting the last node <code>m</code>.</p>
<hr />
<h1 id="graph-project">Graph Project</h1>
<p>This project contains a skeleton for you to implement some graph functionality. This is a test-driven project. Run the tests and read the top-most error. If it’s not clear what is failing, open the <strong>test/test.js</strong> file to figure out what the test is expecting. Make the top-most test pass.</p>
<p>Keep making the top-most test pass until all tests pass.</p>
<p>After the instructions, there is an in-depth explanation of the "friends of" problem.</p>
<h2 id="instructions-2">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/-starters/data-structures-graph-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>test/test.js</code>. Your job is to write code in
<ul>
<li><strong>lib/breadth_first_search.js</strong> to implement the <code>breadthFirstSearch</code> function for graphs</li>
<li><strong>lib/max_value.js</strong> to implement the <code>maxValue</code> function for graphs</li>
<li><strong>lib/num_regions.js</strong> to implement the <code>numRegions</code> function for graphs</li>
<li><strong>lib/friends-of.js</strong> to implement <code>friendsOf</code> and <code>friendsOfRecursion</code> to find connected nodes in a graph less than or equal to a specified distance away from the start node (please see the explanation after these instructions)</li>
<li><strong>lib/leet_code_207.js</strong> to implement the <code>canFinish</code> function located at https://leetcode.com/problems/course-schedule/</li>
</ul></li>
</ul>
<h2 id="friends-of">Friends of</h2>
<p>The set of tests in <strong>test/friends-of-spec.js</strong> asks you to write a function named <code>friendsOf</code> that finds the total set of friends a specified distance away from a person. It will take as parameters</p>
<ol type="1">
<li>The adjacency list (which will always be an object with keys that always have arrays as values)</li>
<li>The name of the person whose friends you need to return</li>
<li>The distance away from the person that you’ll use to collect the friends (this value will always be greater than or equal to 1)</li>
</ol>
<p>The following table interprets the distance parameter:</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Distance</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td>Immediate friends</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td>Immediate friends and friends of friends</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td>Immediate friends, friends of friends, and the friends of friends of friends</td>
</tr>
<tr class="even">
<td style="text-align: center;">n</td>
<td>All the people accessible <em>n</em> steps away from the indicated person</td>
</tr>
</tbody>
</table>
<p>For example, say you had the following dependency graph.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">const</span> graph <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="st">&#39;carrie&#39;</span><span class="op">:</span>  [<span class="st">&#39;humza&#39;</span><span class="op">,</span> <span class="st">&#39;jun&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-3" title="3">  <span class="st">&#39;farrah&#39;</span><span class="op">:</span>  [<span class="st">&#39;humza&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="st">&#39;humza&#39;</span><span class="op">:</span>   [<span class="st">&#39;carrie&#39;</span><span class="op">,</span> <span class="st">&#39;farrah&#39;</span><span class="op">,</span> <span class="st">&#39;jun&#39;</span><span class="op">,</span> <span class="st">&#39;silla&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-5" title="5">  <span class="st">&#39;jun&#39;</span><span class="op">:</span>     [<span class="st">&#39;carrie&#39;</span><span class="op">,</span> <span class="st">&#39;silla&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-6" title="6">  <span class="st">&#39;ophelia&#39;</span><span class="op">:</span> [<span class="st">&#39;travis&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-7" title="7">  <span class="st">&#39;silla&#39;</span><span class="op">:</span>   [<span class="st">&#39;humza&#39;</span><span class="op">,</span> <span class="st">&#39;yervand&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-8" title="8">  <span class="st">&#39;travis&#39;</span><span class="op">:</span>  [<span class="st">&#39;ophelia&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-9" title="9">  <span class="st">&#39;yervand&#39;</span><span class="op">:</span> [<span class="st">&#39;silla&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="op">};</span></a></code></pre></div>
<p>Then, the following table shows the expected results for the person <strong>jun</strong> at different distances.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Distance</th>
<th>List of people returned by <code>friendsOf</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td>carrie and silla</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td>carrie, silla, humza, yervand</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td>carrie, silla, humza, yervand, farrah</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td>carrie, silla, humza, yervand, farrah</td>
</tr>
</tbody>
</table>
<p>At distance 1, your traversal algorithm will find the friends of <strong>jun</strong>, carrie and silla and return them.</p>
<p>At distance 2, your traversal algorithm will find carrie and silla, then find their friends, humza and jun for carrie, and humza and yervand for silla. But, jun is the person that you started with, so you don’t include them in the return value. Humza is both carrie’s <em>and</em> silla’s friend, but you only include that name once.</p>
<p>At a distance 3, you find carrie and silla, then humza and yervand. Then, looking at humza’s friends, you see that humza knows carrie, farrah, hun, and silla. Only farrah is new, so that name will end up in the return value. When your traversal looks at yervand, it sees that silla is that person’s friend, but is not a new value and does not end up getting added again to the return value.</p>
<p>At a distance four, you find carrie and silla, then humza and yervand, then farrah. From there, you look at farrah’s friends which is just humza. You already have that name, so it doesn’t get duplicated in the return value.</p>
<p>All distances 3 and greater will return the same list because you’ve exhausted all of the distinct names of people. You’ve captured the entire circle of friends.</p>
<p>The order in which you return the names is not important.</p>
<p>The tests also define edge cases that you also have to handle that are not in this explanation.</p>
<hr />
<h1 id="week-08-day-4-network-knowledge" data-ignore="true">WEEK-08 DAY-4<br><em>Network Knowledge</em></h1>
<hr />
<h1 id="network-models-learning-objectives">Network Models Learning Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to get a basic understanding of network models. This lesson is relevant because any network-connected software that you write will implementations of these models to communicate with other computers. Questions about network models are popular interviewing topics, too.</p>
<p>When you finish, you should be able to</p>
<ol type="1">
<li>Describe the structure and function of network models from the perspective of a developer.a basic understanding of network models. This lesson is relevant because any network-connected software that you write will implementations of these models to communicate with other computers. Questions about network models are popular interviewing topics, too.</li>
</ol>
<p>When you finish, you should be able to</p>
<ol type="1">
<li>Describe the structure and function of network models from the perspective of a developer.</li>
</ol>
<hr />
<h1 id="internet-protocol-suite-learning-objectives">Internet Protocol Suite Learning Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to understand the different parts of the Internet Protocols. This lesson is relevant because knowledge of internet protocols is expected for all Software Engineers that write code that connects to a network. Moreover, internet protocols are popular interviewing topics.</p>
<p>When you complete this content, you should be able to do the following.</p>
<ol type="1">
<li>Identify the correct fields of an IPv6 header.</li>
<li>Distinguish an IPv4 packet from an IPv6.</li>
<li>Describe the following subjects and how they relate to one another: IP Addresses, Domain Names, and DNS.</li>
<li>Identify use cases for the TCP and UDP protocols.</li>
<li>Describe the following subjects and how they relate to one another: MAC Address, IP Address, and a port.</li>
<li>Identify the fields of a TCP segment.</li>
<li>Describe how a TCP connection is negotiated.</li>
<li>Explaining the difference between network devices like a router and a switch.u to understand the different parts of the Internet Protocols. This lesson is relevant because knowledge of internet protocols is expected for all Software Engineers that write code that connects to a network. Moreover, internet protocols are popular interviewing topics.</li>
</ol>
<p>When you complete this content, you should be able to do the following.</p>
<ol type="1">
<li>Identify the correct fields of an IPv6 header.</li>
<li>Distinguish an IPv4 packet from an IPv6.</li>
<li>Describe the following subjects and how they relate to one another: IP Addresses, Domain Names, and DNS.</li>
<li>Identify use cases for the TCP and UDP protocols.</li>
<li>Describe the following subjects and how they relate to one another: MAC Address, IP Address, and a port.</li>
<li>Identify the fields of a TCP segment.</li>
<li>Describe how a TCP connection is negotiated.</li>
<li>Explaining the difference between network devices like a router and a switch.</li>
</ol>
<hr />
<h1 id="network-tools-learning-objectives">Network Tools Learning Objectives</h1>
<p><strong>The objective of this lesson</strong> is for you to have a basic understanding of commonly-used network analysis utilities. This lesson is relevant because interacting with networks via different tools is essential for every software developer on the web. When you are done, you should be able to use <code>traceroute</code> to show routes between your computer and other computers. You should also be able to use <code>Wireshark</code> to show inspect network traffic.erstanding of commonly-used network analysis utilities. This lesson is relevant because interacting with networks via different tools is essential for every software developer on the web. When you are done, you should be able to use <code>traceroute</code> to show routes between your computer and other computers. You should also be able to use <code>Wireshark</code> to show inspect network traffic.</p>
<hr />
<h1 id="the-osi-network-model">The OSI Network Model</h1>
<p>One challenge with mental models is that everyone thinks about things differently! While we’ve discussed the <em>TCP/IP reference model</em> at length, we haven’t introduced any others. Let’s take a look at one other very well-known reference model for networks: the <em>OSI Model</em>.</p>
<p>We’ll cover:</p>
<ul>
<li>the origin of the OSI reference model,</li>
<li>each OSI layer and its properties,</li>
<li>and how to choose between OSI &amp; TCP/IP.</li>
</ul>
<h2 id="more-layers-more-fewer-problems">More layers, <del>more</del> fewer problems?</h2>
<p>Around the same time computer scientists in the United States were hammering out the layers of the TCP/IP reference model, a similar discussion was happening a world away in the United Kingdom. Researchers in the UK decided that a clear reference model needed to be available to others worldwide, so they began working with the <a href="https://www.encyclopedia.com/computing/news-wires-white-papers-and-books/network-networks">International Standards Organization (ISO)</a>. The ISO published a document called <strong>The Basic Reference Model for Open Systems Interconnection</strong> (or <a href="https://tools.ietf.org/html/rfc793.html#page-23"><strong>ISO 7498</strong></a>), including a seven layer reference model for networking, in the early 1980s.</p>
<p>The <em>Open Systems Interconnection (OSI)</em> reference model differs from the TCP/IP model by its focus on standardization. The TCP/IP model is mostly focused on practical networking concepts and isn’t tightly tied to particular protocols (other than those for which it’s named). The OSI model, however, has both conceptual layers <strong>and</strong> suggested protocols for each. This idea was well-intentioned: make these protocols the standard so that computer scientists have less to think about! This standardization could help prevent <em>vendor lock-in</em> as well, since all major vendors would (hopefully) follow the standards.</p>
<h2 id="the-layers-of-the-osi-model">The layers of the OSI model</h2>
<p>Here’s an overview of the seven layers of the OSI model, along with some well-known protocols for each layer:</p>
<p>
<img src="images/image-network-models-osi.svg" style="width: 100%; height: auto;">
</p>
<p>Let’s dig into each layer, starting from the top.</p>
<h3 id="application">Application</h3>
<p>The OSI <em>Application Layer</em> includes information used by client-side software. Data transmitted on this layer will interact directly with applications, as the name suggests, and can be displayed to the user with limited translation. <strong>HTTP</strong> is an example of a common Application Layer protocol.</p>
<h3 id="presentation">Presentation</h3>
<p>The OSI <em>Presentation Layer</em> is where data gets translated into a presentable format. This is often called the <em>syntax layer</em> since data is converted between machine-readable &amp; human-readable syntax here as well. As a result, the Presentation Layer may include data compression, encryption, and character encoding. Many image formats, including <strong>JPEG</strong> and <strong>GIF</strong>, use well-known Presentation Layer protocols.</p>
<h3 id="session">Session</h3>
<p>The OSI <em>Session Layer</em> includes protocols responsible for authentication and data continuity. Session Layer protocols may authorize a client with the server or re-establish a dropped connection. An example protocol you may find on this layer is <strong>RPC (Remote Procedure Call)</strong>, a mechanism for one device to initiate a command on another.</p>
<h3 id="transport">Transport</h3>
<p>Now we’re on familiar turf! The OSI <em>Transport Layer</em>, like the layer of the same name in the TCP/IP reference model, utilizes transport protocols. Processes here are focused on data integrity and connectivity. Our old friends <strong>TCP</strong> and <strong>UDP</strong> are the two most-used transport protocols.</p>
<h3 id="network">Network</h3>
<p>The OSI <em>Network Layer</em> mirrors TCP/IP’s <em>Internet Layer</em>. This layer manages connections between remote networks, transferring packets across intermediary devices. The best-known protocol at the Network Layer is <strong>IP</strong>.</p>
<h3 id="data-link">Data Link</h3>
<p>Protocols at the OSI <em>Data Link Layer</em> deal with connections directly from one machine’s network interface to another. Frames targeting different MAC addresses are transferred here, and the Data Link Layer is primarily used by machines in local networks. The most recognizable protocol on this layer is <strong>Ethernet</strong>.</p>
<h3 id="physical">Physical</h3>
<p>OSI’s <em>Physical Layer</em> goes a little deeper than the TCP/IP reference model. Physical Layer protocols have to do with translating from raw electrical signals to bits &amp; bytes of data. You may recognize <strong>Wi-Fi</strong> (technically known as <strong>802.11</strong>) and <strong>DSL</strong> as common Physical Layer protocols.</p>
<h2 id="which-model-do-i-use">Which model do I use?</h2>
<p>That’s a lot of layers! It can be a little overwhelming to think of networks from the two complementary but differing perspectives of the TCP/IP and OSI reference models. Let’s discuss when we might want to use each.</p>
<p>The OSI model is <em>conceptual</em>, meaning its practical uses are limited. We can see this when we look at protocols that cross layers. For example, HTTP primarily works on the OSI Application Layer, but includes the ability to manage character encoding, a Presentation Layer concern. Uh-oh! This makes OSI good for <strong>understanding concepts</strong>, but too restrictive for <strong>building new protocols</strong>.</p>
<p>The TCP/IP reference model, on the other hand, is almost purely practical. It was extracted from real, functional networks used by DARPA in the 1970s. Instead of concerns with minutiae like signal-to-data conversions, TCP/IP focuses on the core of networking: getting data from one place to another. For this reason, it’s most often used when <strong>building new systems</strong> or <strong>analyzing real networks</strong>.</p>
<p>Of course, two popular models means most engineers will flip-flop between them! You’ll often hear both models used in the same conversation. We’ll discuss some techniques to differentiate between these two models in an upcoming lesson.</p>
<h2 id="what-weve-learned">What we’ve learned</h2>
<p>We’ve examined two ways of thinking about network design &amp; functionality: first, the TCP/IP reference model, and now the OSI model. Next up, we’ll compare these two models in greater detail.</p>
<p>After this lesson, you should feel comfortable:</p>
<ul>
<li>describing the layers of the OSI reference model,</li>
<li>giving examples of protocols used at each layer,</li>
<li>and explaining where one model may be more applicable than the other.</li>
</ul>
<hr />
<h1 id="tcpip-four-layers">TCP/IP: Four Layers</h1>
<p>We’ve investigated TCP/IP in great detail, and we’ve seen how broad a scope it covers. Now let’s step back and think about the whole networking process. We’re breaking the TCP/IP stack down and categorizing our protocols - are you ready?</p>
<p>We’ll cover:</p>
<ul>
<li>The TCP/IP four-layer reference model,</li>
<li>separation of concerns in networking,</li>
<li>and data encapsulation.</li>
</ul>
<h2 id="a-layered-approach">A layered approach</h2>
<p>Remember that when TCP/IP was first being crafted, researchers felt it was too large and separated the <em>Transmission Control Protocol</em> from the <em>Internet Protocol</em>. This separation was a boon; it made the protocols easier to implement individually and led to the Internet we know and love today!</p>
<p>We sometimes refer to this approach as <em>separation of concerns</em>. We divide up complex processes so that many connected concepts can work independently. This makes it easier to consider each concept in detail on its own and means each concept can grow at its own unique pace.</p>
<p>The developers of TCP/IP took this separation even farther in 1989 when they published <a href="https://www.encyclopedia.com/computing/news-wires-white-papers-and-books/network-networks">RFC 1122</a>. This spec, also titled "Requirements for Internet Hosts – Communication Layers", provided a new way of thinking about the whole TCP/IP process. According to the RFC, we can separate the connection out into four distinct <em>layers</em>, or separate areas of interest. These are:</p>
<ul>
<li><em>Application</em></li>
<li><em>Transport</em></li>
<li><em>Internet</em></li>
<li>and <em>Link</em></li>
</ul>
<p>We refer to this as a <em>reference model</em>: a high-level overview of a complex topic provided by an organization that manages it. The four-layer model presented in RFC 112 is often called the <em>TCP/IP reference model</em>, simply <em>TCP/IP model</em>, or even the <em>Department of Defense (DoD) model</em>, referring to the original research being done at DARPA.</p>
<h2 id="layers-of-the-tcpip-model">Layers of the TCP/IP model</h2>
<p>Here’s a visual summary of the four layers of the TCP/IP reference model, along with some well-known protocols for each layer:</p>
<p>
<img src="images/image-network-models-tcp-ip.svg" style="width: 100%; height:
  auto;">
</p>
<p>Let’s look at what each layer of the reference model includes.</p>
<h3 id="application-1">Application</h3>
<p>The <em>Application Layer</em> includes protocols related to user-facing data. Some of the protocols that’s we’ve discussed, like <em>HTTP</em> and <em>FTP</em>, operate in this layer. The TCP/IP model doesn’t care what type of application data is used; <strong>whatever</strong> is transmitted from the Transport Layer is considered Application Layer data.</p>
<h3 id="transport-1">Transport</h3>
<p>The <em>Transport Layer</em> includes (you guessed it) transport protocols! We’ve already discussed the two best-known: <em>TCP</em> and <em>UDP</em>. This layer focuses on connectivity between clients and servers, and relies on the lower layers to establish network connectivity.</p>
<h3 id="internet">Internet</h3>
<p>The <em>Internet Layer</em> is where IP lives. Data is processed in <em>packets</em> on this layer, and routing is primarily handled with IP addresses. The Internet layer focuses mostly on connecting separate networks together.</p>
<h3 id="link">Link</h3>
<p>The <em>Link Layer</em> includes our lower-level communication standards. Link Layer protocols aren’t concerned with the type of data being transported, but instead focus on getting data from one local network resource to another. We jump up to the Internet layer when dealing with resources on other networks.</p>
<blockquote>
<h3 id="fifth-layer">Fifth layer?</h3>
<p>Despite the RFC specifying four layers for the TCP/IP model, you may encounter resources detailing a five layer model for TCP/IP instead! The "fifth layer" is usually the <em>Physical</em> layer. This helps us separate electrical concepts like transmission across wires from data-oriented concepts like MAC addresses, but isn’t an official reference model from the IETF. TCP/IP doesn’t explicitly include any physical mediums, so thinking of this as a fifth layer can be helpful.</p>
</blockquote>
<h2 id="translating-layers-to-data">Translating layers to data</h2>
<p>Layers provide a mental model we can use to think about how interactions across networks occur. It’s important to remember that these are "best fit" models, though: they translate loosely to our actual data. Some protocols may cross layers, and some companies will adjust these models to fit their own internal implementations. Ultimately, these layers provide a form of shared communication between professionals. You can count on another engineer understanding what an "Application Layer issue" means, even if your own definitions differ slightly!</p>
<p>We often refer to <em>encapsulation</em> when describing how layers map to our data. This means higher layers are <em>encapsulated</em>, or wrapped, in lower layers. For example, a Transport Layer <em>segment</em> includes Application Layer data in its payload, and a Link Layer <em>frame</em> includes the whole stack! Here’s an example:</p>
<p>
<img src="images/image-network-models-encapsulation.svg" style="width: 100%;
  height: auto;">
</p>
<p>As we’ll see, alternative networking reference models may define layers as beginning/ending at different points in our data. However, the general idea is shared across models: lower layer data units include data for higher layers in their payloads.</p>
<h2 id="what-weve-learned-1">What we’ve learned</h2>
<p>When it comes to technical concepts, it’s <a href="https://tools.ietf.org/html/rfc793.html#page-23">"reference models all the way down"</a>! These new ways of thinking about topics we’ve already explored will help you communicate the concepts more clearly, and help you navigate problems that may be deeper than your own code.</p>
<p>You should feel confident:</p>
<ul>
<li>naming each of the four canonical TCP/IP reference model layers,</li>
<li>explaining why these layers were defined,</li>
<li>and relating these layers to the data being transferred on a network.</li>
</ul>
<hr />
<h1 id="a-crash-course-in-binary-and-hexadecimal-notation">A Crash Course in Binary and Hexadecimal Notation</h1>
<p>As we study networking we are going to be investigating a very low level of computing compared to the JavaScript programming we’ve been doing so far. We are moving closer to hardware, and so we will be exposed to some new numbers, formatted as binary or hexadecimal.</p>
<h2 id="binary">Binary</h2>
<p>At the lowest level, a computer just speaks two values, <code>1</code> and <code>0</code>. These are usually represented by two different voltages inside an integrated circuit known as a CPU (Central Processing Unit). Everything that you do on a computer, writing and running your JavaScript code, watching videos online, chatting or posting on social media, or playing a video game, are at a fundamental level just 1’s and 0’s being processed by an integrated circuit.</p>
<p>So, what is binary? To understand this, we need to talk about bases.</p>
<h3 id="bases">Bases</h3>
<p>What’s a base? It turns out there’s not just one number system. The number system human beings have used for thousands of years is <strong>base 10</strong>. This means we count using the Arabic digits 0 through 9. The reason we use base 10? It should be pretty obvious. The majority of human beings have ten fingers. So naturally we invented a counting system that used 10 digits. If we ever meet aliens from another planet that only have say, six digits, they might indeed use <strong>base 6</strong>.</p>
<p>As it turns out, the base that computers speak is <strong>base 2</strong>. This derives directly from the fact that transistors (which is what all integrated circuits are made of) have two voltage states. You can use <strong>base 2</strong> to perform mathematical calculations and because of this all computing at a fundamental level is base 2.</p>
<h3 id="base-2">Base 2</h3>
<p>So what does base 2 look like? Well if base 10 contains the digits 0 through 9, then base 2 contains the digits 0 through 1.</p>
<p>If you remember from your early math education, decimal (another word for base 10) numbers can be divided into <em>places</em>.</p>
<p>For example, given the number 42, the number breaks down into the following <em>places</em>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Place</th>
<th style="text-align: right;">1000</th>
<th style="text-align: right;">100</th>
<th style="text-align: right;">10</th>
<th style="text-align: right;">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Digit</strong></td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">2</td>
</tr>
</tbody>
</table>
<pre><code>(4 * 10) + (2 * 1) = 42</code></pre>
<p>For binary, we instead have the following places, and the number 42 breaks down this way:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Place</strong></th>
<th style="text-align: right;">128</th>
<th style="text-align: right;">64</th>
<th style="text-align: right;">32</th>
<th style="text-align: right;">16</th>
<th style="text-align: right;">8</th>
<th style="text-align: right;">4</th>
<th style="text-align: right;">2</th>
<th style="text-align: right;">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Digit</strong></td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
</tr>
</tbody>
</table>
<pre><code>(128 * 0) + (64 * 0) + (32 * 1) + (16 * 0) + (8 * 1) + (4 * 0) + (2 * 1) = 42</code></pre>
<p>Or since we can simplify the zeros to 0 and the ones to 1, we can calculate this much more simply by just adding up the places that contain a 1.</p>
<pre><code>32 + 8 + 2 = 42</code></pre>
<p>This is a good shorthand way of calculating a binary number in your head as long as you memorize the bases.</p>
<h2 id="bits-and-bytes">Bits and Bytes</h2>
<p>So inside computers we often call a single digit a <strong>bit</strong>. A bit can be either <strong>on</strong> (1) or <strong>off</strong> (0).</p>
<p>A sequence of 8 bits is known as a <strong>byte</strong>.</p>
<p>So our 42 example is a single byte since it contained 8 bits:</p>
<p><code>00101010</code></p>
<p>There are also some multiples of bytes computer science borrowed from the metric system, although with confusing results since the metric system is Base 10, while computing is Base 2.</p>
<table>
<thead>
<tr class="header">
<th>Unit</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kilobyte</td>
<td>1000 bytes</td>
</tr>
<tr class="even">
<td>Megabyte</td>
<td>1000<sup>2</sup> bytes</td>
</tr>
<tr class="odd">
<td>Gigabyte</td>
<td>1000<sup>3</sup> bytes</td>
</tr>
<tr class="even">
<td>Terabyte</td>
<td>1000<sup>4</sup> bytes</td>
</tr>
<tr class="odd">
<td>Petabyte</td>
<td>1000<sup>5</sup> bytes</td>
</tr>
<tr class="even">
<td>Exabyte</td>
<td>1000<sup>6</sup> bytes</td>
</tr>
<tr class="odd">
<td>Zettabyte</td>
<td>1000<sup>7</sup> bytes</td>
</tr>
<tr class="even">
<td>Yottabyte</td>
<td>1000<sup>8</sup> bytes</td>
</tr>
</tbody>
</table>
<p>This system worked fine until computer storage got very large. Manufacturers of hard drives would use Base 10, while Operating Systems would often use Base 2. The discrepancy between something like the gigabyte in base 2 vs base 10 was very large.</p>
<blockquote>
<p>1 Gigabyte in base 10 = 1,000,000,000 bytes 1 Gigabyte in base 2 = 1,073,741,824 bytes</p>
</blockquote>
<p>That’s 73.7 Megabytes of difference! With a Terabyte it got even worse.</p>
<blockquote>
<p>1 Terabyte in base 10 = 1,000,000,000,000 bytes 1 Terabyte in base 2 = 1,099,511,627,776 bytes</p>
</blockquote>
<p>For a whopping 99.5 Gigabytes of difference.</p>
<p>Something had to be done. So now we have two different sets of terminology one for Base 10 and one for Base 2.</p>
<table>
<thead>
<tr class="header">
<th>Base 10</th>
<th>Abbr</th>
<th>Value</th>
<th>Base 2</th>
<th>Abbr</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kilobyte</td>
<td>kB</td>
<td>1000 bytes</td>
<td>Kibibyte</td>
<td>KiB</td>
<td>1024 bytes</td>
</tr>
<tr class="even">
<td>Megabyte</td>
<td>MB</td>
<td>1000<sup>2</sup> bytes</td>
<td>Mebibyte</td>
<td>MiB</td>
<td>1024<sup>2</sup> bytes</td>
</tr>
<tr class="odd">
<td>Gigabyte</td>
<td>GB</td>
<td>1000<sup>3</sup> bytes</td>
<td>Gibibyte</td>
<td>GiB</td>
<td>1024<sup>3</sup> bytes</td>
</tr>
<tr class="even">
<td>Terabyte</td>
<td>TB</td>
<td>1000<sup>4</sup> bytes</td>
<td>Tebibyte</td>
<td>TiB</td>
<td>1024<sup>4</sup> bytes</td>
</tr>
<tr class="odd">
<td>Petabyte</td>
<td>PB</td>
<td>1000<sup>5</sup> bytes</td>
<td>Pibibyte</td>
<td>PiB</td>
<td>1024<sup>5</sup> bytes</td>
</tr>
<tr class="even">
<td>Exabyte</td>
<td>EB</td>
<td>1000<sup>6</sup> bytes</td>
<td>Exbibyte</td>
<td>EiB</td>
<td>1024<sup>6</sup> bytes</td>
</tr>
<tr class="odd">
<td>Zettabyte</td>
<td>ZB</td>
<td>1000<sup>7</sup> bytes</td>
<td>Zebibyte</td>
<td>ZiB</td>
<td>1024<sup>7</sup> bytes</td>
</tr>
<tr class="even">
<td>Yottabyte</td>
<td>YB</td>
<td>1000<sup>8</sup> bytes</td>
<td>Yobibyte</td>
<td>YiB</td>
<td>1024<sup>8</sup> bytes</td>
</tr>
</tbody>
</table>
<p>Still to this day, you will hear people refer to the base 2 versions as Kilobyte or Megabyte. Often it’s hard to determine what unit is being used when manufacturers advertise the size of hard drives or memory. Worse, Operating Systems often display inconsistent numbers throughout their many displays of how big disks or files are.</p>
<h2 id="another-useful-base">Another useful base</h2>
<p>Another useful base in computing is <strong>Base 16</strong> also known as <em>hexadecimal</em>.</p>
<p>Why is this useful? This is use because hexadecimal can provide a shorter, more human-readable version of binary.</p>
<p>So if base 10 goes from the digits 0 through 9, what are we going to do? There aren’t 16 digits…</p>
<p>The letters A through F are here to rescue us from this. The available digits for hexadecimal are <em>0 through F</em>, where <code>A</code> is <code>10</code> decimal and <code>F</code> is <code>15</code> decimal.</p>
<pre><code>hexadecimal: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,  A,  B,  C,  D,  E,  F
decimal:     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15</code></pre>
<p>It’s hard to think of letters as being numbers, but in hexadecimal it’s perfectly normal.</p>
<p>So how does this help us write binary numbers in a shorter form? It’s because there are 8 bits in a byte, which means one byte can be expressed as <em>two</em> hexadecimal digits.</p>
<p>Let’s look at the <em>places</em> for hexadecimal for the decimal number 42. There’s a sixteenth’s place and a one’s place in this example.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Place</strong></th>
<th style="text-align: right;">16</th>
<th style="text-align: right;">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Digit</strong></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">A</td>
</tr>
</tbody>
</table>
<p>This might seem confusing at first but just like our other base examples, this is:</p>
<pre><code>(16 * 2) + (A * 1)</code></pre>
<p>However, since <code>A</code> is really <code>10</code> in decimal this resolves to this in decimal.</p>
<pre><code>(16 * 2) + (10 * 1) = 42</code></pre>
<p>Using this you can see that the maximum value for a two digit hexadecimal number is <code>FF</code>, which is <code>255</code> in decimal and <code>11111111</code> in binary.</p>
<p>This happens to be the maximum value of one byte.</p>
<pre><code>FF = 255 = 11111111 = 1 byte</code></pre>
<p>So instead of typing out an entire string of 1s and 0s we can write bytes as a sequence of 2 digit hexadecimal numbers. We usually separate these numbers by spaces or some other delimiter to make it clear they are a sequence of numbers:</p>
<p>For instance this sequence of numbers in decimal:</p>
<pre><code>4 8 15 16 23 42</code></pre>
<p>is the following in binary:</p>
<pre><code>00000100 00001000 00001111 00010000 00010111 00101010</code></pre>
<p>But in Hexadecimal it’s only this:</p>
<pre><code>04 08 0F 10 17 2A</code></pre>
<p>I hope you can see that this is a really compact and convenient way to represent binary numbers. The numbers are always the same length, which is good for data storage, and they can be easily translated back to binary. It might also help rescue you from <a href="https://www.businessinsider.com/the-martian-hexidecimal-language-2015-9">Mars</a>.</p>
<h3 id="the-0x-notation">The <code>0x</code> Notation</h3>
<p>Sometimes you will see hexadecimal numbers represented by prepending a <code>0x</code> to the front of them. So our 42 would be expressed like this:</p>
<pre><code>0x2A</code></pre>
<h2 id="in-javascript">In JavaScript</h2>
<p>In JavaScript, we can use <code>toString</code> on <code>Number</code> objects to convert different bases to decimal. We can supply a base as an argument to <code>toString</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb32-1" title="1"><span class="at">Number</span>(<span class="dv">42</span>).<span class="at">toString</span>(<span class="dv">16</span>) <span class="co">// 2a</span></a>
<a class="sourceLine" id="cb32-2" title="2"><span class="at">Number</span>(<span class="dv">42</span>).<span class="at">toString</span>(<span class="dv">2</span>) <span class="co">// 101010</span></a></code></pre></div>
<p>We can also use our old friend <code>parseInt</code> with an optional second argument to convert a binary or hexadecimal string to a decimal number.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb33-1" title="1"><span class="at">parseInt</span>(<span class="st">&#39;101010&#39;</span><span class="op">,</span> <span class="dv">2</span>) <span class="co">// 42</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="at">parseInt</span>(<span class="st">&#39;2A&#39;</span><span class="op">,</span> <span class="dv">16</span>) <span class="co">// 42</span></a></code></pre></div>
<h1 id="in-conclusion">In conclusion</h1>
<p>Binary and hexadecimal are often used in computing because computers are fundamentally base 2. As you move closer to the hardware, you encounter these more and more often. In networking, you will see them used for IP Addresses and MAC Addresses. We’ll learn more about that when we look next at how IP Networking works in the next section.</p>
<hr />
<h1 id="internet-protocol">Internet Protocol</h1>
<p>As we dive deeper into understanding how computers communicate, a common question keeps coming up: what is "the Internet", exactly? To answer this, let’s discuss the <em>Internet Protocol</em>, also known as <em>IP</em>.</p>
<p>We’ll cover: - What IP is and why it matters to us, - different protocol versions and when to use them, - and how to identify IP data by its formatting.</p>
<h2 id="history-of-ip">History of IP</h2>
<p>To understand where we are today, we need to look back to where we came from. Picture yourself in the United States in the late 1960s. The country is nearing the end of the "space race" and technology is booming. There are numerous technical teams and physical networks created as a result of recent research, but communication between them is limited. There’s also a rise of different proprietary standards which are hampering growth: not every team can afford a separate terminal of each available type! How can we facilitate better collaboration with less investment required?</p>
<p>By 1974, two researchers working for <a href="https://www.encyclopedia.com/computing/news-wires-white-papers-and-books/network-networks">DARPA</a> think they have the answer. They propose something called the <em>Transmission Control Program</em>. It’s a complex process that defines exactly how multiple networks can communicate with each other. This protocol stands out because it is:</p>
<ul>
<li><em>fault tolerant</em>: data transmitted between networks can be cached and re-sent if it fails the first time.</li>
<li><em>end-to-end</em>: there are no single central systems that can take the whole network down; each host can send/receive to others.</li>
</ul>
<p>These highlights are critical because DARPA is a military organization. They’re looking for technology that could theoretically withstand a nuclear attack - and the Transmission Control Program fits the bill!</p>
<h3 id="the-great-divide">The great divide</h3>
<p>It became quickly apparent that that Transmission Control Program was too dense. The process was complicated and involved many moving parts, and other engineers raised concerns that it should be extracted into separate parts. Soon, the Transmission Control Program was divided into two separate sections: <em>Transmission Control Protocol (TCP)</em>, which was responsible for the fault-tolerance of joined networks, and <em>Internet Protocol (IP)</em>, which was responsible for the end-to-end nature of joined networks.</p>
<p>The protocols we use today have been improved over time, but still carry those names and general purposes. It’s amazing to think that modern social media, video gaming, and streaming content is all dependent on 50+ year old technology!</p>
<h2 id="so-what-is-the-internet-exactly">So what is the Internet, exactly?</h2>
<p>The Internet can be loosely defined as "a series of <em>internetworked</em> systems". Here’s a practical example of what we mean by that:</p>
<blockquote>
<p>Imagine every building in your town has a parking garage. Each garage is owned by a different company and uses custom entry sensors. These sensors prefer certain vehicle types: one garage for luxury sports cars only, another that will only allow motorcycles. You may need to park in the garage for the vehicle you own, then walk a lot. Otherwise, you’d have to own a different vehicle for each garage! Oh no! We’d consider this an "isolated" model: each garage works fine by itself, but patrons of one garage may not park elsewhere, and none of the garages are really meeting their full potential.</p>
<p>Now imagine the garages remove their sensors. Suddenly you can park anywhere you’d like. Your motorcycle and your neighbor’s school bus can exist harmoniously in any garage, and you can travel from garage to garage in any vehicle you’d like. We’d consider this an "internetworked" model: each garage’s patrons may travel to any other garage and while the particular entrance/exit policies may differ, drivers can rest assured knowing they’ll fit anywhere.</p>
</blockquote>
<p>The Internet Protocol opened the door for this internetworked model in computing. Now a network in New York City using one vendor’s computers could seamlessly communicate with a network in London from a different vendor! This connectivity led to the birth of the Internet, which is itself <em>a series of interconnected networks sharing data</em>.</p>
<h2 id="packet-switching">Packet-Switching</h2>
<p>IP data is transmitted in a format known as a <em>packet</em>. A packet uses a data format we’ve seen before: metadata in <em>headers</em>, and a <em>body</em> with content. The headers are used to get the packet to its destination, while the body contains the information we’d like to transfer.</p>
<p>We refer to IP’s communication style as <em>packet-switching</em>. This is when a message is split up into separate "packets", delivered to a destination, and reassembled as appropriate. Remember that IP’s primary responsibility as part of the Internet’s "double threat", TCP/IP, is maintaining an <em>end-to-end</em> state. For this reason, IP isn’t concerned about whether packets are received by the client in sequential order, and may sometimes even lose packets altogether while in transit!</p>
<blockquote>
<h3 id="a-crash-course-in-bits-bytes">A crash course in bits &amp; bytes</h3>
<p>Most of the protocols we’ll cover measure their data in <em>bits</em>. We represent a bit as a single binary digit, either 1 or 0. Since data gets long, we have some larger units available as well! We’ll sometimes describe data sizes in <em>bytes</em>. A byte is eight bits.</p>
<p>For example, "01001" is five bits, and a piece of data that’s 32 bits long could also be described as "4 bytes".</p>
</blockquote>
<h2 id="ip-versions">IP Versions</h2>
<p>The Internet Protocol has evolved over time, but two versions stand out as the most used &amp; important to us: version 4 and version 6. We often refer to these as <em>IPvX</em>, where <em>X</em>, is the version number.</p>
<h3 id="ipv4">IPv4</h3>
<p>The best known version of the Internet Protocol is <em>IPv4</em>. This version was used when TCP/IP was finalized by DARPA in 1983, and it’s still the most-used protocol version online.</p>
<p>An IPv4 packet’s header consists of at least 13 <em>fields</em>, or sequences of binary bits. These fields start with a version identifier (<code>0100</code>, or "4" in binary), continue with 10 sequences that define things like the length of the header and protocol type contained in the body, and wrap up with source and destination addresses for the packet. IPv4 also includes an allowance for a 14th optional header field called "Options" that can contain extra metadata about the packet’s content, but it’s not often used. An IPv4 header without options will be 20 bytes (160 bits).</p>
<p>It’s hard to visualize a header since it’s essentially just a long string of 1s and 0s. Instead of trying to cram it all into one line to study, we can split it into specified widths and stack them. Here’s a stacked diagram of the IPv4 header:</p>
<p>
<img src="images/image-ip-ipv4-headers.svg" style="width: 100%; height: auto;">
</p>
<h3 id="ipv4-addresses">IPv4 Addresses</h3>
<p>IPv4 addresses are composed of 4 <em>octets</em>, or 8-bit binary numbers. We usually represent them like this:</p>
<pre><code>192.18.1.1</code></pre>
<p>This is the same as <code>11000000.00010010.00000001.00000001</code> in binary notation, but that’s a lot harder to read! IPv4 supports around 4 billion unique addresses.</p>
<h3 id="ipv6">IPv6</h3>
<p>The "4 billion unique address" limit seemed almost infinite in the earliest days of the Internet, but today it’s easy to see how we might use up that few addresses! Seeing this <em>address exhaustion</em> on the horizon, Internet researchers began concocting a new protocol version, one that would allow more addresses, in the mid 1990’s. By 2017, the new protocol was an official standard: <em>IPv6</em>.</p>
<p>IPv6 uses a totally different packet header format than IPv4, though they share a few fields. It only uses 8 header fields, and supports optional "extension headers" that come after these 8 fields, as opposed to IPv4’s large "Options" block.</p>
<p>The 8 fields IPv6 uses, in order, are:</p>
<p>
<img src="images/image-ip-ipv6-headers.svg" style="width: 100%; height: auto;">
</p>
<ul>
<li><em>Version</em>
<ul>
<li><code>0110</code>, or "6" in binary notation</li>
</ul></li>
<li><em>Traffic Class</em>
<ul>
<li>used to identify different types of packets, like video or phone data</li>
</ul></li>
<li><em>Flow Label</em>
<ul>
<li>an experimental option used for adding packet sequencing into IP</li>
</ul></li>
<li><em>Payload Length</em>
<ul>
<li>lets the reciever know how large the data in the packet will be</li>
</ul></li>
<li><em>Next Header</em>
<ul>
<li>Usually identifies the protocol type of the packet’s data, but may indicate the first extension header (if present)</li>
</ul></li>
<li><em>Hop Limit</em>
<ul>
<li>A means of preventing packets from being passed around routers forever, this field will be decremented by 1 every time the packet passes through an intermediary (like a router)</li>
</ul></li>
<li><em>Source Address</em>
<ul>
<li>Where the packet originated</li>
</ul></li>
<li><em>Destination Address</em>
<ul>
<li>Where the packet is heading</li>
</ul></li>
</ul>
<p>These headers have a fixed length of 40 bytes (320 bits).</p>
<h3 id="ipv6-addresses">IPv6 Addresses</h3>
<p>Notice that IPv6 packets have fewer headers, but are double the length of IPv4 headers! This is primarily due to IPv6 addressing, which allows <strong>dramatically</strong> more address space than IPv4. How many more addresses?</p>
<p>IPv4 supports <strong>~4 billion (4x10<sup>9</sup>)</strong> addresses.</p>
<p>IPv6 supports <strong>~350 undecillion (3.5×10<sup>38</sup>)</strong> addresses.</p>
<p>That’s a billion times a billion more addresses! It’s even more addresses than grains of sand in all the world’s beaches &amp; deserts (7.5x10<sup>18</sup>, according to <a href="https://tools.ietf.org/html/rfc793.html#page-23">the University of Hawaii</a>).</p>
<p>It handles this by quadrupling the number of bits in an address. IPv4 uses 32 bits, while IPv6 uses 128 bits. Remember that these bits are binary, so adding additional bits exponentially increases the number of permutations.</p>
<p>This new address space also required a new notation. Instead of the "four dotted decimal" notation of IPv4, IPv6 uses "eight colon-ed hexadecimal". Here’s an example IPv6 address:</p>
<pre><code>2600:6c5e:157f:d48c:138f:e0ba:6fa7:d859</code></pre>
<p>The same address in binary is:</p>
<pre><code>0010011000000000:0110110001011110:0001010101111111:1101010010001100:0001001110001111:1110000010111010:0110111110100111:1101100001011001</code></pre>
<p>It’s easy to see how we added so many extra addresses! That said, IPv6 is much more difficult to read by humans. You can read some neat rules for making IPv6 addresses easier to read on <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Protocol_operation">Wikipedia</a>.</p>
<h3 id="special-addresses">Special addresses</h3>
<p>Both popular versions of the Internet Protocol include space for some special addresses that you should quickly recognize. The main one you’ll encounter is called the <em>loopback</em> address. This is the identifier for your current machine. You’ll see it repeatedly while developing because you’ll navigate your browser there to access your own servers! You may also hear this referred to as <em>localhost</em>.</p>
<p>In IPv4 the loopback address is <code>127.0.0.1</code>. In IPv6, the loopback is <code>::1</code>.</p>
<p>There’s also an <em>"all interfaces"</em> address. This address is used to catch any incoming requests regardless of intended destination. It’s only used by the local machine: you would never send a packet to the "all interfaces" address, but a server that is listening on that address would see all incoming packets.</p>
<p>For IPv4, the "all interfaces" address is <code>0.0.0.0</code>. For IPv6, it’s simply <code>::</code>.</p>
<p>Remember that the loopback and "all interfaces" address are not interchangeable! This is a common misconception you may encounter in tutorials online, and might be a trick question during a technical interview. If you’re ever asked to connect to <code>localhost</code>, make sure you use the loopback.</p>
<h2 id="what-weve-learned-2">What we’ve learned</h2>
<p>Whew! The Internet Protocol is a dense topic, but a little familiarity will go a long way when you’re debugging server connections. After reading this lesson, you should be able to:</p>
<ul>
<li>provide a rough history of where the Internet Protocol came from,</li>
<li>compare/contrast the two most popular IP versions (4 &amp; 6),</li>
<li>identify an IP packet’s version by its headers,</li>
<li>and name the localhost addresses for both versions.</li>
</ul>
<hr />
<h1 id="transport-protocols">Transport Protocols</h1>
<p>Between HTTP and IP, we find an extra layer of information. We often refer to this as the <em>transport layer</em> of communication, and protocols used in it are referred to as <em>transport protocols</em>.</p>
<p>There are myriad of transport protocols available, but we’re going to cover the two biggest: <em>TCP</em> and <em>UDP</em>. We’ll dive into:</p>
<ul>
<li>why we need transport protocols,</li>
<li>the differences between TCP and UDP,</li>
<li>and where each protocol is used today.</li>
</ul>
<h2 id="what-exactly-are-we-transporting">What exactly are we transporting?</h2>
<p>We’ve already briefly mentioned the <em>Transmission Control Protocol (TCP)</em> when discussing the history of the <em>Internet Protocol (IP)</em>. Both TCP &amp; IP made up the original <em>Transmission Control Program</em> developed at DARPA in the 1970s. We’ve dug deep into IP now, and we have some understanding of HTTP. Why do we need more protocols?</p>
<p>Let’s provide a practical example. Think about the process of delivering a package. Floor pickers take your package from a warehouse onto the back of a truck, and a dispatcher sends that truck to your house. There’s a place on your porch just waiting for that package. How, then, does your package make it across the very last leg of its journey? Whoops - we forgot the delivery person!</p>
<p>Transport protocols act as our "delivery person". IP is concerned with machine-to-machine communication, and HTTP is designed for application-to-application communication. Transport protocols bridge the gap and help our data cover the last mile between the network and software.</p>
<h3 id="ports">Ports</h3>
<p>Like every other part of the internetworking process, transport protocols use their own unique form of addressing. We call these <em>ports</em>. Ports are virtual interfaces that allow a single device to host lots of different applications &amp; services. By lots, we mean a whole bunch - there are 65536 separate ports available to each transport protocol!</p>
<p>Ports are represented by numbers: <code>port 80</code>, <code>port 51234</code>, etc. If we know both the IP address and port we’d like to connect to, we can use a special notation where both are joined by a colon:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb37-1" title="1"><span class="ex">192.168.1.1</span>:8080</a></code></pre></div>
<p>This would point to port <code>8080</code> on a network interface with an IP address of <code>192.168.1.1</code>. We refer to an IP address &amp; port written together in this way as a <em>socket</em>.</p>
<h2 id="tcp">TCP</h2>
<p>The most common transport protocol used is <em>TCP</em>. TCP is a connection-oriented protocol, meaning it establishes a connection between two sockets. This connection acts as safeguard from other error-prone protocols underneath it, including <em>IP</em> and <em>Ethernet</em>. Pieces of data sent via TCP (referred to as <em>segments</em>) respect a strict order and verify when they have been received. This means that data can’t be "lost" across a TCP connection: if a segment is received out of order, the receiver will ask the transmitter to re-send the missing segment. This behavior makes TCP a <em>reliable</em> protocol.</p>
<p>We’ll dive deeper into exactly how TCP verifies data &amp; forms connections in a future lesson. For now, remember that "TCP == reliability". Any time it’s critical that data arrives ordered and in full, TCP’s the way to go! You’ll see TCP used as the underlying connection for HTTP, file transfers, and media streaming. In all of these cases, missing data would result in corrupt files and unreadable data.</p>
<p>Because of everything TCP offers us, it’s a relatively "heavy" protocol to use. Messages may take a bit longer to transfer than they would via other protocols, but you can be confident that your message has been received the way you intended it. This inherent slowness means applications using TCP may <em>buffer</em> data, or wait until a certain amount has been received before passing it to the user. You’ve probably seen this happen on your favorite video sharing sites!</p>
<h2 id="udp">UDP</h2>
<p>The <em>User Datagram Protocol (UDP)</em> arrived on the scene a few years after TCP. Scientists working with TCP found that they sometimes didn’t need all the order and reliability that TCP provided, and they were willing to trade that for raw speed. UDP is connection-less and provides no verification for whether data is received. Because of this, we refer to it as an <em>unreliable</em> protocol.</p>
<p>Hold on, though! By "unreliable", we certainly don’t mean "useless". UDP is used in lots of familiar places: real-time video sharing, voice-over-IP phone calls, and DNS all rely on UDP as their transport protocol of choice. These services prioritize speed over reliability, so it makes sense that they would forego TCP’s additional lag. If some data is lost along the way, that’s okay - for example, you might just see lower-quality video for a moment.</p>
<p>Unreliable systems are valuable outside the world of transport protocols as well! Consider the postal service: most letters are sent without any sort of delivery confirmation or guarantee of arrival. It’s up to the sender and/or recipient to manage expectations of when a letter ought to have arrived. This is similar to UDP. Data will be transmitted, and most will arrive, but if either side needs more reliability than that they will have to implement it themselves.</p>
<h2 id="what-weve-learned-3">What we’ve learned</h2>
<p>Transport protocols fill a gap in our current understanding of networks. They help us get data up from the network to our applications, and they give us a few options for fault-tolerance versus performance.</p>
<p>After reading this lesson, you should feel comfortable: - explaining what transport protocols are and why we need them, - comparing &amp; contrasting TCP &amp; UDP, - and discussing use cases for each of these two major protocols.</p>
<hr />
<h1 id="surveying-your-domain">Surveying Your Domain</h1>
<p>We’ve covered how connected devices communicate with each other, but we’re missing a key piece: where humans fit into the equation! After all, the Internet would be a much more boring place if we had to remember the IP address of every website we chose to visit.</p>
<p>Let’s look into the <em>Domain Name System</em>, a method of translating long numeric identifiers into friendly, human-readable addresses. We’ll cover:</p>
<ul>
<li>how the Domain Name System came to be,</li>
<li>how a URL gets translated to an IP address,</li>
<li>and the different types of information stored by the system.</li>
</ul>
<h2 id="what-is-dns">What is DNS?</h2>
<p>The <em>Domain Name System</em> (often just referred to as <em>DNS</em>) is a distributed approach to providing easily-understood names for internetworked devices. Practically, it’s similar to a phone book: DNS allows us to look up a specific IP address by its <em>domain</em>.</p>
<p>In the early days of computer networking, connecting to another computer was a manual, complex process. A user would need very specific addresses to find the networked resource they were looking for, and those addresses were difficult to read/remember! A scientist named <a href="https://www.encyclopedia.com/computing/news-wires-white-papers-and-books/network-networks">Elizabeth Feinler</a>, working with ARPA in the early 1970’s, saw a way to help. She started out with a simple text file listing computer names by their numeric addresses. This file grew in size as more systems joined ARPANET, and Elizabeth expanded her operation from a text file to a whole organization dedicated to keeping an up-to-date list of hostnames &amp; IP addresses.</p>
<p>By the 1980’s, it was clear that one organization wasn’t enough to manage the growing Internet. The Domain Name System was invented as a way to distribute the work to numerous organizations, lightening the load and allowing much more rapid growth. The first DNS name server was written in 1984, and the rest is history!</p>
<p>DNS is one of the most important parts of allowing the Internet to grow so rapidly. It’s perfect for quick scaling because it is both simple (relying on specifically-formatted text files) and distributed (redundant across numerous servers).</p>
<h3 id="domains">Domains?</h3>
<p>We’ve mentioned domains before today, but without much detail. Let’s dive a little deeper into that term. A website’s <em>domain</em> refers to the "friendly" name for the website’s <em>host</em>, or the server providing the site’s content. A domain differs from a URL in that the domain is only the server’s identifier, not other application or protocol-related data in the URL.</p>
<p>Here’s a breakdown of an average URL. We’ve highlighted the domain in green and labelled each part of the URL underneath:</p>
<p>
<img src="images/image-ip-dns-domain.svg" style="width: 100%; height: auto;">
</p>
<p>A <em>domain name</em> can be split into a few parts:</p>
<ul>
<li><p>The <em>top-level domain (TLD)</em> is the last part of the domain, appearing just before the URL begins pointing at application routes (usually indicated with <code>/</code>’s) or query parameters (indicated with a <code>?</code> and <code>&amp;</code>’s). The best known TLDs are <code>.com</code>, <code>.net</code>, and <code>.org</code>. TLDs are managed by special organizations that have demonstrated the ability to handle the immense workload involved, often known as <em>domain registries</em>. These registries may be government entities (for example, <code>.gov</code> is managed by the <a href="https://tools.ietf.org/html/rfc793.html#page-23">General Services Agency</a>) or private companies that were awarded the privilege by <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Protocol_operation">ICANN</a>.</p></li>
<li><p>To the left of the TLD, separated by a dot, is the <em>second-level domain</em>. You’ll often hear the TLD &amp; second-level domain lumped together as "the domain". This is the name most people associate with the website. Through <em>domain registrars</em>, consumers can purchase second-level domains. The registrar maintains a listing of each purchase.</p></li>
<li><p>Some websites will have additional domains to the left of the second-level domain. These can be referred to by their formal names (<em>third-level domain</em>, <em>fourth-level domain</em>, etc.) but are often informally referred to as <em>subdomains</em>. The best-known subdomain is <code>www</code>, though this is less-used on newer sites. Subdomains can usually be freely created by the consumer.</p></li>
</ul>
<h2 id="how-the-magic-happens">How The Magic Happens</h2>
<p>DNS does one thing really well: identifying connected devices by friendly names. How exactly does this work?</p>
<p>It all goes back to the magic word: <em>domain</em>. Each individual domain is represented by a set of <em>name servers</em>, which store information about the domain’s registered subdomains. Name servers will direct a client where they need to go - even if that’s another name server! We refer to this process of working out which name server we need as <em>resolution</em>. Eventually, we’ll reach a name server that can tell us the specific IP address for the full domain. We refer to this as the <em>authoritative name server</em> for our domain. It has the final say!</p>
<p>When trying to resolve a domain name, we start from the rightmost part (the TLD) and work our way to the left. We’ll stop once we’ve reached an authoritative server that can give a direct address for the domain we’re seeking. Intermediate servers should be able to point us to the most-relevant name server to continue our search (usually, the next domain to the left). We can think of this as a conversation between the client and the available name servers for our domain, each one moving us closer to our goal.</p>
<p>Here’s a practical example of how DNS is used to discover the authoritative name server for the fictional URL <code>https://students..io</code>:</p>
<p>
<img src="images/image-ip-dns-resolution-chat.svg" style="width: 100% height: auto;">
</p>
<p>Looking for something a little more whimsical? <a href="https://dnsimple.com/">DNSimple</a> has a <a href="https://howdns.works/ep1/">fantastic webcomic</a> detailing the journey of a domain resolver. Check it out!</p>
<h2 id="dns-records">DNS Records</h2>
<p>We can see how DNS works, but what does it actually look like? It’s not much different than it was at the very beginning! Each name server maintains a <em>zone file</em>: a text file containing host names, IP addresses, and resource types. Here’s an example of a simple zone file:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb38-1" title="1"><span class="va">$TTL</span> <span class="ex">299</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="ex">my-site.com.</span>    IN  SOA     ns1.cloudflare.com. dns.cloudflare.com. 2032032092 10000 2400 604800 3600</a>
<a class="sourceLine" id="cb38-3" title="3"><span class="ex">my-site.com.</span>    IN  NS      ns1.my-site.com.</a>
<a class="sourceLine" id="cb38-4" title="4"><span class="ex">my-site.com.</span>    IN  NS      ns2.my-site.com.</a>
<a class="sourceLine" id="cb38-5" title="5"><span class="ex">my-site.com.</span>    IN  A       104.28.31.159</a>
<a class="sourceLine" id="cb38-6" title="6"><span class="ex">my-site.com.</span>    IN  A       104.28.30.159</a>
<a class="sourceLine" id="cb38-7" title="7"><span class="ex">my-site.com.</span>    IN  AAAA    2606:4700:30::681c:1f9f</a>
<a class="sourceLine" id="cb38-8" title="8"><span class="ex">my-site.com.</span>    IN  AAAA    2606:4700:30::681c:1e9f</a>
<a class="sourceLine" id="cb38-9" title="9"><span class="ex">www</span>             IN  CNAME   my-site.com.</a>
<a class="sourceLine" id="cb38-10" title="10"><span class="ex">ns1</span>             IN  A       104.28.31.150</a>
<a class="sourceLine" id="cb38-11" title="11"><span class="ex">ns2</span>             IN  A       104.28.30.150</a>
<a class="sourceLine" id="cb38-12" title="12"><span class="ex">my-site.com.</span>    IN  MX      10 mail.google.com.</a></code></pre></div>
<p>Each line in a zone file includes the affected domain, type of record on that line, and the data for that record. Let’s discuss some of the most common DNS record types in the order we see them above:</p>
<h3 id="soa"><code>SOA</code></h3>
<p>The <em>SOA</em> record represents the <strong>S</strong>tart <strong>O</strong>f <strong>A</strong>uthority. This record lets us know which name server is the <em>master</em>, or primary authority, for the domain we’re querying. The SOA record is the minimum requirement in a zone file - every name server will return this record, if nothing else!</p>
<h3 id="ns"><code>NS</code></h3>
<p><em>NS</em> records point to name servers for the zone. Most zones will have at least two NS records for redundancy. Remember that one of DNS’s strengths is that it’s distributed. If one name server loses power or becomes disconnected, we don’t lose access to the zone.</p>
<h3 id="a-aaaa"><code>A</code> / <code>AAAA</code></h3>
<p><em>A</em> records are the most important DNS records present. They map a resource directly to an IP address. This is the core of what DNS is for: connecting the domain directly to a machine. <code>A</code> records are used for IPv4 addresses, while <code>AAAA</code> records perform the same function for IPv6.</p>
<h3 id="cname"><code>CNAME</code></h3>
<p>The <em>CNAME</em> record acts as an alias, linking one domain to another. In our example above, we’re saying that <code>www.my-site.com</code> should point at the same resource as <code>my-site.com</code>. Notice that the <code>www</code> doesn’t have a <code>.</code> after it. This means it’s a <em>relative</em> reference, and the additional parts of the domain for this zone (<code>my-site.com.</code>) are implied. When a domain in zone file ends in a <code>.</code> we can treat it as an <em>absolute</em> reference with no unwritten subdomains.</p>
<h3 id="mx"><code>MX</code></h3>
<p>DNS: It’s not <strong>just</strong> for websites! <em>MX</em> records, short for <strong>M</strong>ail E<strong>x</strong>changer, are used by e-mail clients to direct messages to the appropriate mail servers. These records let you send messages to "friend@gmail.com" instead of having to remember "friend@123.45.67.89"!</p>
<h3 id="metadata">Metadata</h3>
<p>There’s one piece we’ve overlooked in our example zone file above: the first line. <code>$TTL 299</code> refers to the <em>Time to Live (TTL)</em> for our records. This is a measure of how long a record should be <em>cached</em> by a DNS name server.</p>
<p>We cache DNS queries because reading from a file can be slow! When a query comes in for a particular domain, the name server will cache the result in memory so that subsequent requests are much faster. However, this in-memory copy won’t be updated if the zone file changes - yikes! The TTL lets us set how often a cached record should be discarded and read from the zone file again. This is especially important if we are pointing at a service where the IP might change frequently, like a local development environment or shared hosting service.</p>
<p>In our example, we’ve set the TTL for all records in the zone file to 299 seconds. This means that if your current web host goes offline and you have to point your domain at a new server, the downtime won’t last more than approximately five minutes. This <strong>also</strong> means that you’ll be re-checking your zone file for that domain at least once every five minutes. If you’re confident in your hosting and aren’t making infrastructure changes, longer TTLs can result in slightly increased performance.</p>
<h2 id="what-weve-learned-4">What we’ve learned</h2>
<p>The Domain Name System is a great example of a simple process (linking names to locations) evolving over time to support greater and greater needs. It’s frightening to think of how difficult navigating around the Internet would be if we didn’t have DNS to make websites easily accessible!</p>
<p>Before we move on, here’s a quick tip: <strong>DNS questions are popular fodder for technical interviews.</strong> You may be asked to define a particular record type or to walk through a rough outline of what happens when you type a URL into your browser and click "Go". Try thinking through this process with your new knowledge!</p>
<p>After reading this lesson, you should have a better understanding of:</p>
<ul>
<li>the history and intent of DNS,</li>
<li>how to read &amp; break down a domain name,</li>
<li>and what’s involved in translating domains into IP addresses.</li>
</ul>
<hr />
<h1 id="networking-hardware-getting-physical">Networking Hardware: Getting Physical</h1>
<p>We’ve discussed a lot of data- and internal-communication protocols, but what supports these? Let’s examine some of the most important hardware you’ll see while examining computer networks!</p>
<p>We’ll cover:</p>
<ul>
<li>networking hardware devices and how they differ,</li>
<li>use cases for each type of device,</li>
<li>and specialized cases with integrated devices</li>
</ul>
<h2 id="three-levels-of-control">Three levels of control</h2>
<p>Network protocols mean very little if we don’t have a physical way of connecting computers together! Whether it’s via copper cables, fiber optics, or wireless networks, we need ways of managing communications to put those protocols into action. A quick search for "networking hardware" will yield a slew of results, but don’t get overwhelmed! We can boil many of these devices down to three types: <em>hubs</em>, <em>switches</em>, and <em>routers</em>.</p>
<h3 id="hubs-keeping-it-simple">Hubs: keeping it simple</h3>
<p>
<img src="images/image-ip-networking-hub.svg" style="width: 100%; height: auto;">
</p>
<p>A <em>hub</em> is the simplest networking device you’re likely to find in service. It performs no network management and might be better known as a "signal splitter". When a hub receives data, it duplicates that data and broadcasts it to all connected devices. That’s it!</p>
<p>Hubs tend to be cheap and are often found in older networks. They are usually small metal boxes with a handful of physical connectors. You can get hubs with lots of connectors, but they’re usually a little smaller - think 5 or 10 instead of 30 or 40. This is due to the natural limitations a hub possesses.</p>
<blockquote>
<p>Heads up! We’ll refer to the physical sockets that cables plug into as <em>connectors</em>, but you’ll often hear them called <em>ports</em> instead. This can get <strong>very</strong> confusing, so be sure you’re clear about the difference between virtual ports used by transport protocols and physical ports used by hardware. When in doubt, use a clearer term, like "connector" or "jack".</p>
</blockquote>
<p>For one, a hub can’t do any sort of filtering. This means every single data packet is sent to every single device, all the time. This creates a lot of unnecessary load on the network. Imagine if every time you called a friend, all of your other friends’ phones rang too. Yikes! Additionally, hubs share bandwidth across devices, so heavy traffic can result in lower speeds. We’ll sometimes see this problem on overloaded networks with other devices, but on a hub it’s guaranteed.</p>
<p>Hubs were a helpful and necessary piece of hardware for a long time, but today there’s little reason to use them. They may still be slightly cheaper than a switch, but the limitations outweigh most cost concerns. The best use for a hub now is as a temporary replacement while replacing a broken device.</p>
<h3 id="switches-traffic-control">Switches: traffic control</h3>
<p>
<img src="images/image-ip-networking-switch.svg" style="width: 100%; height:
  auto;">
</p>
<p>A step up from the hub, we find a network <em>switch</em>. Switches are "intelligent" hubs: they track devices connected to them, help manage network load, and can manage separate internal networks with ease! The biggest thing that separates a switch from a hub is the <em>MAC address table</em>.</p>
<p>A network switch maintains an internal address book containing the MAC addresses of the devices connected to it. Remember that data frames contain both a source and destination MAC address? This is how the switch stays up to date! It uses this data to perform one of three actions with each piece of data it receives:</p>
<ul>
<li><p><em>flood</em>: When a destination address is unknown, the switch will <em>flood</em> received data out to all connected devices <strong>except where the data came from</strong>. When the intended recipient responds, the switch will update its MAC address table accordingly. This is how switches learn about connected devices, and it’s significantly more efficient than a hub’s behavior of flooding all the time!</p></li>
<li><p><em>forward</em>: When a switch already has the destination MAC address in its internal table, it can send data directly to that device. This is called <em>forwarding</em> the data. No other devices connected to the switch are made aware of this data.</p></li>
<li><p><em>filter</em>: Sometimes a switch will receive data on the same connector the data is destined for. In these cases, the switch will <em>filter</em>, or drop, the data entirely. This can be a little confusing to think about! If data arrives on the same connector it would later be sent out of, then we can assume the data was handled by some other part of our network, and the receiving switch can’t do anything to help. Remember that this is very specifically related to the physical connector the data is received on: a switch will never act on data that comes in and goes out the same connector.</p></li>
</ul>
<p>Switches often look just like hubs, but come in a much larger range of sizes. They can be chained together to cover large networks, or a 5-connector switch might be used for a small home network. Switches have improved on hubs’ limitations: they don’t share bandwidth, so you’ll see less impact on speed through a switch than you might through a hub.</p>
<p>If you’re building a home or single-location office network today, switches are your friend. They provide lots of simple management functionality for not much cash, and they’re easy to keep around.</p>
<h3 id="routers-thinking-globally">Routers: thinking globally</h3>
<p>
<img src="images/image-ip-networking-router.svg" style="width: 100%; height:
  auto;">
</p>
<p>Here’s a thought experiment: let’s think about what a switch for a national network might look like. Since switches can be chained together, we wouldn’t need thousands of connectors - but we would need <em>lots</em> of memory! The MAC address table would need to hold entries for every computer in the country. No way!</p>
<p>Instead of trying to solve this problem with switches, we have a higher-level device: the <em>router</em>. Routers connect separate networks with each other. Instead of identifying devices via MAC address, they use IP addresses to make decisions about data.</p>
<p>A router, like a switch, maintains an internal table of addresses. This <em>routing table</em> is used to pass received data on through the network. Data may move on to another router, or the router may recognize the data and pass it to an internal switch.</p>
<p>Routers also participate in an important process called <em>NAT</em>, short for <em>Network Address Translation</em>. NAT helps minimize IP address overload by giving the router a single IP address to use for all external communication. The router then uses IP ports to map incoming data to internal device IP addresses in its routing table. Imagine living in an apartment complex with a mail office. The postal service could bring packages with your apartment number to the front desk, and the mail officer would dole those packages out, but the sender would never actually have to know your name or exactly where your apartment is located! NAT provides a tiny bit of security and allows significantly more computers to coexist on the Internet simultaneously.</p>
<p>Because of the extra processing power required to handle large routing tables &amp; filtering, routers tend to cost substantially more than switches. However, most networks only need one router! We sometimes describe routers as being our <em>gateway</em> to the Internet.</p>
<p>Physically, routers come in all shapes and sizes. They only need two connectors (one incoming, one outgoing), but they often come as part of an integrated device with multiple connectors and functions.</p>
<h2 id="a-practical-example-of-network-hardware">A practical example of network hardware</h2>
<p>That’s enough theory! Let’s think through a practical example of each of the pieces of network hardware we’ve discussed.</p>
<p>Imagine you need to get a message to a friend across the room. There are lots of people between you and your friend: how might you communicate?</p>
<p>One way might be to shout. If you shout your message to the room, the rest of the people in the room could repeat it to make sure it’s heard! This is going to result in some ringing ears, but your friend will definitely hear the message. This is how <em>hubs</em> work: broadcast to everyone, no matter who’s listening.</p>
<p>An alternative might be to whisper. You could pass a message to the person right next to you. Of course, they won’t know everyone in the room, so they’ll have to ask the people close to them to pass it along. It may take a bit to get to your friend the first time, but any responses will be lightning-fast since everyone now knows who to talk to. This is a <em>switched</em> model: <em>flood</em> the message once to learn how to get to the destination, then use what we’ve learned to <em>forward</em> &amp; <em>filter</em> appropriately.</p>
<p>Finally, imagine your friend has left the room. Uh oh! We could still use the shouting or whispering approach, but none of that matters since we now need to find the correct room your friend is in. To do this, we’d need people familiar with each room. We could pass our message to those gatekeepers, who could pass the message for us from room to room until it reaches the correct one. At that point, the process will reverse in the new room: the gatekeeper will whisper or shout, the room will respond accordingly, and responses will come back via the gatekeepers. The gatekeepers are acting as our <em>routers</em> here: they pass our messages between rooms, but don’t necessarily care how the room communicates internally.</p>
<p>Notice in this example that each type of communication has a purpose, and all of them work together. We’re simplifying things, but it’s easy to concoct an example where we need all three types, or where we only need one. This is true of hardware was well. You should choose the correct devices for the network you’re building. Not thinking through your needs may result in a steep cost, both in terms of performance and in terms of money!</p>
<h2 id="integrated-devices">Integrated devices</h2>
<p>It’s easiest to think of these three classes of hardware as separate, distinct devices. However, this won’t always be the case. Let’s discuss some situations where these devices exist in unfamiliar packages.</p>
<p>When you set up Internet at a new home, you usually get a modem from your ISP. Years ago, this modem was dead simple: one inbound connection for your phone line or cable, and one outbound connection for your home PC. Today, however, our homes have multiple devices! Consumers became increasingly frustrated with getting a modem from one company but still needing a router and/or switch to connect all their computers.</p>
<p>In response, ISPs upped their game by integrating extra devices in their "modems". The average home gateway today includes:</p>
<ul>
<li>a modem to translate the physical signal from the cable/phone line,</li>
<li>a router to manage your internal and external IP addresses,</li>
<li>a wireless antenna for wi-fi connections,</li>
<li>and a 5-connector switch for wired connections.</li>
</ul>
<p>Woah! That’s a lot of hardware in one device. This behavior has blurred the lines between types of hardware and made communication about networked devices more difficult. Your ISP might call that single device a "modem", a "router", a "gateway", or an "access point". All of these are true!</p>
<p>Before making decisions about a network you’re investigating, make sure you understand what each device is doing. Does that router include a switch? Is the modem a simple modem or does it include a hub as well? As always, make sure you’re using the right tool for the job.</p>
<h2 id="what-weve-learned-5">What we’ve learned</h2>
<p>There are lots of different types of network hardware out there, but most of them fall into three separate categories. Hopefully, the next time you see inside a messy server closet, you’ll be curious about which parts you can identify!</p>
<p>After this reading, you should be comfortable with:</p>
<ul>
<li>the difference between hubs, switches, and routers,</li>
<li>identifying each type of device,</li>
<li>switched internal networking,</li>
<li>and the basic concept of routing on interconnected networks.</li>
</ul>
<hr />
<h1 id="tcp-connections">TCP Connections</h1>
<p>The <em>Transmission Control Protocol (TCP)</em> is the backbone of the Internet. The majority of services we use rely on it, and a deeper understanding of it will help you navigate those services with ease.</p>
<p>Let’s deep-dive into TCP! We’ll cover:</p>
<ul>
<li>TCP segments what information they carry,</li>
<li>"control bits" that manage the TCP lifecycle,</li>
<li>and the process of forming &amp; discarding connections.</li>
</ul>
<h2 id="segments">Segments</h2>
<p>Just like the <em>Internet Protocol (IP)</em> uses <em>packets</em>, TCP uses data units called <em>segments</em>. Segments are formed from application data: TCP receives this data, breaks it down into transmittable units, and attaches a <em>header</em> to each unit. This header contains everything we need to ensure a reliable connection is established.</p>
<h3 id="segment-header-fields">Segment Header Fields</h3>
<p>As with IP, TCP header fields are critical to understand. They help satisfy two needs of the protocol: <strong>reliable data transfer</strong> and <strong>consistent connections</strong>.</p>
<p>Here’s an overview of each field in the order they appear:</p>
<p>
<img src="images/image-ip-tcp-header-fields.svg" style="width: 100%; height:
  auto;">
</p>
<ul>
<li><p><strong>Source / Destination Port:</strong> The first two fields indicate which port the request originated on and which port it’s directed to. This will be used, along with the IP address in the IP wrapper containing the segment, to determine which <em>sockets</em> to use for the TCP connection.</p></li>
<li><p><strong>Sequence Number:</strong> This number is used to establish the correct ordering of data. At the start of a connection, TCP sets an <em>Initial Sequence Number (ISN)</em> that’s sufficiently large enough to avoid conflicts. Each byte of data transferred is then counted, beginning at the ISN, and used to calculate the sequence number for the segment. Sequence numbers go hand-in-hand with the …</p></li>
<li><p><strong>Acknowledgement Number:</strong> This number lets the sender know which sequence is expected next. Acknowledgement numbers are cumulative, which is how TCP maintains proper ordering of segments. The receiver will send an acknowledgement number that’s one higher than the last sequence number plus the length of the last data received. For example: if the last sequence number received was <code>10</code>, and the accompanying data was 4 bits long, the response will include an acknowledgement number of <code>15</code> - meaning "I’m ready for sequence number 15!".</p></li>
<li><p><strong>Data Offset:</strong> Defines how long the segment header is. This lets us know if there are options later on in the header or not.</p></li>
<li><p><strong>Reserved:</strong> A short range of three bits, held over for later use. These will always be <code>0</code>.</p></li>
<li><p><strong>Control Flags:</strong> These nine bits drive the TCP connection process. We’ll break them down in more detail soon.</p></li>
<li><p><strong>Window Size:</strong> This field is used to let the sender know how much data the receiver can accept. This helps maintain the reliability of a connection: if a receiver is getting overloaded, they can lower the window size as a way of saying "slow down!". If a slow connection can move faster, a larger window size is a way of saying "bring it on!".</p></li>
<li><p><strong>Checksum:</strong> The <em>checksum</em> is an error-checking mechanism. Checksums are used to check the validity of a particular segment, not the whole series of segment (as with sequence/acknowledgement). The TCP client can use the checksum to ensure the segment has been received correctly. If it doesn’t match expectations, the segment will be discarded &amp; ignored.</p></li>
<li><p><strong>Urgent Pointer:</strong> TCP allows for data to be marked as <em>urgent</em>. This means it should be processed right away, regardless of sequence, interrupting any other transfer in process. This is useful when trying to terminate a long transfer, as we’d like to kill the connection without waiting for it to complete. This field indicates how much urgent data to expect, if there is any.</p></li>
<li><p><strong>Options:</strong> Like most other protocols, the TCP segment header includes a range for <em>options</em> at its end. There may be no options, or there may be a handful! We can verify whether there are options be comparing the length of the header so far to the <em>data offset</em> field. TCP header options are mostly used for flow control and may even include <em>padding</em> to fill out the expected length of the header with empty data.</p></li>
</ul>
<p>Immediately after any options (or after the <em>urgent pointer</em>, if no options are given), the encapsulated data from our application begins.</p>
<h2 id="tcp-connection-lifecycle">TCP Connection Lifecycle</h2>
<p>Remember that TCP is a <em>connection-oriented protocol</em>. This means that it establishes a long-running line of communication between two points, instead of just shouting into the Internet void like UDP. Establishing this connection involves a series of predictable steps, each with specific names. Most of these steps are driven by the <em>control flags</em> in the segment headers.</p>
<h3 id="control-flag-options">Control Flag Options</h3>
<p>The segment header has 12 bits reserved for control flags. The first three of these are currently unused and will always be zero, and the next three are all used by congestion-management extensions to the protocol. The control flags that most concern us are the final six bits, each known by a short three-letter name. Let’s review them in order:</p>
<p>
<img src="images/image-ip-tcp-header-control-flags.svg" style="width: 100%; height:
  auto;">
</p>
<ul>
<li><p><strong>URG:</strong> The "<strong>urg</strong>ent" bit. Lets us know if this segment contains urgent data.</p></li>
<li><p><strong>ACK:</strong> The "<strong>ack</strong>nowledgement" bit. Setting this bit means a message has been received successfully.</p></li>
<li><p><strong>PSH:</strong> The "<strong>p</strong>u<strong>sh</strong>" bit. This bit is used to indicate that buffered data should be passed on to the connected application.</p></li>
<li><p><strong>RST:</strong> The "<strong>r</strong>e<strong>s</strong>e<strong>t</strong>" bit. This bit means we should reset the connection. Receivers will send an RST segment when they receive unexpected data, either to a port that’s not listening or dramatically out-of-sequence.</p></li>
<li><p><strong>SYN:</strong> The "<strong>syn</strong>chronize" bit. This flag is set on the the first segment from each side of the connection, and should include an ISN for the socket to begin sequencing from.</p></li>
<li><p><strong>FIN:</strong> The "<strong>fin</strong>ished" bit. This bit lets each side know that transmission is done and the connection may be closed.</p></li>
</ul>
<blockquote>
<p>Note that we mention all twelve bits here as "control bits" even though the first three are unassigned. While they are currently unused, protocols evolve frequently! The <a href="https://www.encyclopedia.com/computing/news-wires-white-papers-and-books/network-networks">TCP specification</a> lists "six reserved bits, six control bits", but newer specs have claimed some of those. For this reason, you should think of the remaining three reserved bits as "control flags still under development".</p>
</blockquote>
<h3 id="getting-to-know-each-other-the-three-way-handshake">Getting to know each other: the three-way handshake</h3>
<p>TCP connections begin with a process called a <em>three-way-handshake</em>, also sometimes referred to as <em>SYN-SYN-ACK</em>. This name comes from the three interactions before the connection is officially "open":</p>
<ul>
<li>The client notifies the server that data is incoming with a <code>SYN</code> segment.</li>
<li>The server acknowledges that data and sends its own segment, including both an <code>ACK</code> and its own <code>SYN</code>.</li>
<li>The client <code>ACK</code>nowledges with another segment to the server. Now both sides are ready to go!</li>
</ul>
<p>Notice that we can send both a <code>SYN</code> and <code>ACK</code> on a single segment. This is called <em>piggybacking</em> and saves us a ton of requests! The three-way handshake would become a four-way handshake if we had to send the <code>SYN</code> and <code>ACK</code> separately.</p>
<p>TCP connections are often visualized using <em>ladder diagrams</em>, also sometimes called <em>timing diagrams</em>. Let’s take a look at one for the three-way handshake:</p>
<p>
<img src="images/image-ip-tcp-three-way-opening.svg" style="width: 100%; height:
  auto;">
</p>
<p>This diagram should be read top-to-bottom. Each arrow represents a single segment being passed between hosts. You can see how the client initiates the request, but the server mirrors the process. This ensures both sides are ready to work: if the client’s <code>SYN</code> request fell on deaf ears, we would expect an <code>RST</code> segment back.</p>
<p>You can also see how the <em>sequence number</em> and <em>acknowledgement number</em> are incremented for each segment. Since these initial segments contain no data, each only increments by one. During data transfer, the numbers will increment based on the length of data received so far.</p>
<p>TCP maintains timers for most behaviors to ensure that connections don’t hang empty forever. This is one reason time-based diagrams are so helpful: by adjusting the angle of the arrows between the client &amp; server, we can indicate a faster or slower connection. This can be helpful for visualizing connections on a granular level. For example, here’s a simplified diagram of the same three-way handshake with a slow server response:</p>
<p>
<img src="images/image-ip-tcp-slow-connection.svg" style="width: 100%; height:
  auto;">
</p>
<h3 id="data-transmission-error-handling">Data transmission &amp; error handling</h3>
<p>Once the connection has been <em>established</em>, we’re off to the races! The client will send data segments over and the server will respond with <code>ACK</code> segments.</p>
<p>Remember that the sequence number in each data segment indicates where our data starts, and the corresponding acknowledgement number should be the next position after our data ends. For example, a data segment with a sequence number of <code>4</code> and data of length <code>3</code> will be <code>ACK</code>’ed with an acknowledgement number of <code>7</code>: our data included <code>4</code>, <code>5</code>, and <code>6</code> in the sequence, and the server is letting us know that it’s ready for data beginning at sequence number <code>7</code>.</p>
<p>Here’s a fun way of visualizing this concept via text messages between the client &amp; server:</p>
<p>
<img src="images/image-ip-tcp-seq-ack.svg" style="width: 100%; height:
  auto;">
</p>
<p>Note that there won’t be any more <code>SYN</code> segments unless the connection terminates unexpectedly: we only send segments with the <code>SYN</code> flag enabled when initializing a connection.</p>
<p>The acknowledgement number is important for keeping the TCP connection reliable. It will only increment when a segment is successfully received, so an <code>ACK</code> response to the client with a lower acknowledgement number than the client’s current sequence number means a segment was missed and must be retransmitted.</p>
<p>A diagram is worth a thousand words:</p>
<p>
<img src="images/image-ip-tcp-dropped-segment.svg" style="width: 100%; height:
  auto;">
</p>
<p>This is a <strong>major</strong> part of TCP, and one of the reasons it’s both reliable and slow: data may need to be retransmitted frequently, but the end result is always a full &amp; correct payload on the server.</p>
<h3 id="saying-goodbye-closing-the-connection">Saying goodbye: closing the connection</h3>
<p>Once we’ve sent all our data across the wire, it’s time to say <em>au revoir</em>. By default, TCP closes open connections similarly to the way they’re opened: lots of handshakery! By default, this time it’s a <em>four-way handshake</em>.</p>
<p>Let’s take a look at a diagram of a TCP connection closing:</p>
<p>
<img src="images/image-ip-tcp-four-way-closing.svg" style="width: 100%; height:
  auto;">
</p>
<p>This diagram is similar to the three-way handshake we looked at for connection establishment, so it may raise a question for you: why the extra handshake? The reason, as usual, is <em>reliability</em>!</p>
<p>Remember how TCP maintains timers between segments.? This is because no matter how much reliability we’ve worked into transport protocols, they’re still built on top of unreliable protocols and infrastructure. The same is true of a closing connection: we don’t want to act too quickly or we may miss a piece of extra important data.</p>
<p>When closing a connection, both sides wait a beat before actually closing. This allows any delayed segments to slip in at the last minute! This also means it is impractical for the server to send a piggybacked <code>FIN</code> &amp; <code>ACK</code> in the same way it sends a <code>SYN</code> &amp; <code>ACK</code> to open the connection. If the server waited before sending an <code>ACK</code>, the client may think something went wrong and begin retransmitting. To prevent this, the server responses are separated:</p>
<ul>
<li>the server returns an <code>ACK</code> to the client’s first <code>FIN</code> right away,</li>
<li>it waits a moment to ensure there are no remaining data segments inbound,</li>
<li>and then it sends a corresponding <code>FIN</code> segment to let the client know it’s shutting down.</li>
</ul>
<p>The client will <code>ACK</code>nowledge immediately, but may also wait a bit before truly closing, just in case. With all the handshaking and waiting around, you might call TCP a "considerate" protocol as well!</p>
<h3 id="the-tcp-socket-state-lifecycle">The TCP Socket State Lifecycle</h3>
<p>Remember that a TCP connection is between two <em>sockets</em>, or joint IP address/port pairs. As the connection progresses, these sockets change <em>state</em>. For example, during the process of data transfer, both sockets are considered to be in the <code>ESTABLISHED</code> state, while before a connection is established a server’s open socket would be in the <code>LISTEN</code> state.</p>
<p>It’s important to remember that this flow isn’t identical for the client &amp; server, too: after the client sends its <code>SYN</code>, it enters a <code>SYN SENT</code> state while the server enters a <code>SYN RCVD</code> (or "<code>SYN</code> Received") state of its own.</p>
<p>Here’s a diagram of a simple data transfer from start to finish. Notice that we’ve added the socket states for each side of the connection outside the diagram. These may be noted by network tools and can be helpful to reference if you find yourself debugging a TCP connection problem:</p>
<p>
<img src="images/image-ip-tcp-socket-states.svg" style="width: 100%; height:
  auto;">
</p>
<p>The original TCP specification includes an <a href="https://tools.ietf.org/html/rfc793.html#page-23">alternative text-based chart</a> for the lifecycle of these socket states, and you can read more about this process on the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Protocol_operation">Wikipedia page</a> for TCP.</p>
<h2 id="what-weve-learned-6">What we’ve learned</h2>
<p>Wow! It’s incredible to visualize everything happening across the wire when you browse the Web. TCP is such a foundational piece of your daily interactions with the Internet and will only become more so as you begin contributing to the Web yourself!</p>
<p>After reading this lesson, you should have a clear understanding of:</p>
<ul>
<li>TCP segment headers and how they relate to the segment’s contents,</li>
<li>TCP control flags,</li>
<li>the TCP connection process, including the many handshakes,</li>
<li>and basic error handling across TCP connections.</li>
</ul>
<hr />
<h1 id="following-the-trail-with-traceroute">Following The Trail With <code>traceroute</code></h1>
<p>Remember that the Internet is a "network of networks"<a href="https://www.encyclopedia.com/computing/news-wires-white-papers-and-books/network-networks">1</a>. This can make it tough to <em>debug</em> problems between networks: how do we identify the culprit? Enter <em>traceroute</em>! Let’s explore this utility and learn how to find problems with inter-network connections.</p>
<p>We’ll cover: - what <code>traceroute</code> is and when to use it, - how to read <code>traceroute</code> output, - and how to use <code>traceroute</code> to solve problems.</p>
<h2 id="where-are-we-going">Where are we going?</h2>
<p>When we create connections between networks, they’re rarely direct. We’ve already discussed how the IP protocol works to connect devices across multiple intermediaries. While the theory and addressing makes sense, it raises a new challenge: how do we solve problems when we can’t get access to the other networks involved?</p>
<p>Thankfully, there’s a utility that lets us peek at devices along the way. It’s called <code>traceroute</code>. The <code>traceroute</code> utility runs on the command line and uses UDP packets to monitor each device that data passes through as it moves from the source location to the target location. Using this utility, we can determine where a network failure or slowdown might be occurring.</p>
<blockquote>
<p><code>traceroute</code> vs. <code>tracert</code></p>
<p>If you do some research of your own, you may find <code>traceroute</code> referred to as <code>tracert</code>. These utilities work slightly differently. <code>tracert</code> is included with the Windows operating system, and uses <em>ICMP</em> (an alternative protocol also used by the <code>ping</code> utility) to trace data. <code>traceroute</code> is on Unix-based operating systems, including macOS, and uses UDP. We’ll prefer <code>traceroute</code> here, but the output of both utilities is almost identical! If you find yourself investigating network problems on a Windows computer, the skills covered here will translate seamlessly.</p>
</blockquote>
<p>You’ll sometimes hear using <code>traceroute</code> referred to as "running a trace". Running a trace of your own is easy - enter the following on your command line:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb39-1" title="1"><span class="op">&gt;</span> <span class="ex">traceroute</span> .io</a></code></pre></div>
<p>Boom! Your first trace! So what does all that gibberish mean? Let’s break it down.</p>
<h2 id="reading-a-trace">Reading a trace</h2>
<p>Here’s a screenshot of <code>traceroute .io</code> from my terminal:</p>
<p>
<img src="images/image-network-tools-traceroute-screenshot.svg" style="width:
  auto;">
</p>
<h3 id="metadata-1">Metadata</h3>
<p>First, let’s look at the overall breakdown. At the top of the trace, you’ll see some general info. There’s a warning about "multiple addresses", meaning that <code>.io</code> resolves to more than one IP address. This is common for popular websites that use multiple servers to reduce traffic and keep speeds high. Next, you’ll see the true beginning of the trace, including the domain we’re tracing to, the IP address it resolved to, and a maximum number of <em>hops</em> ("64") and <em>packet size</em> "(52 byte").</p>
<p>We mentioned <em>hops</em> when discussing networking protocols, but here’s a quick review: a "hop" is one connection to another server. Think of the houses on your street or apartments on your hall. A single hop would walking to your next door neighbor’s home. Three hops would be walking three doors down. When we run <code>traceroute</code>, it tracks the location of each hop, but it limits the number of hops to make sure we’re not searching for an unavailable address forever! Our <code>traceroute</code> won’t go more than 64 hops, though this default may differ across systems.</p>
<p>Below the general info, we see a numbered list of addresses. Each line represents one hop, and includes some important info about that destination. Let’s check it out!</p>
<h3 id="the-hop">The Hop</h3>
<p>Here’s our first hop:</p>
<p>
<img src="images/image-network-tools-traceroute-single-hop-screenshot.svg"
  style="width: auto;">
</p>
<p>We know it’s the first because of the <code>1</code> on the left side. Each hop is preceded by a number indicating how many hops it took to get there.</p>
<p>Next, we see two IP addresses. These identify the network location our trace has reached. In this case, the location has no resolvable DNS name so we just see the IP address. If you look ahead a bit, you can see that addresses with a resolvable name will show that name first instead.</p>
<p>Finally, we see three numbers. These are time intervals, (indicated by the "ms", short for "milliseconds") that let us know how long it took us to reach this location from our system. When we run a trace, <code>traceroute</code> attempts each hop three times. This is because UDP (and the Internet beneath it!) is inherently unreliable. Testing the hop three times ensures we get truly representative data and not a false reading due to a dropped packet or network congestion. Each of the three numbers we see is the response time from one of those attempts. They’ll always vary slightly, but we can get a good idea of the average response time. In this case, the numbers are <strong>very</strong> small: two tenths of a millisecond! Wow!.</p>
<blockquote>
<p>This first hop is my home internet router! We can tell this not only because it’s the first device reached beyond my own computer, but also because the IP address is within one of IPv4’s <em>reserved ranges</em>, meant for private networks inside homes and businesses. It’s unlikely you’ll see reserved addresses outside of your current network.</p>
</blockquote>
<p>Hops proceed from our own device to the <em>gateway</em> for the device we’re trying to reach. We can analyze each hop using the same breakdown.</p>
<p>The first hop in our trace is straightforward, but that’s not always the case! Let’s take a look at a few not-so-standard situations you may see come up.</p>
<h3 id="special-cases">Special cases</h3>
<p>Notice that our second hop doesn’t have any of the info we expect from <code>traceroute</code>. Instead, it has three asterisks:</p>
<p>
<img src="images/image-network-tools-traceroute-empty-hop-screenshot.svg"
  style="width: auto;">
</p>
<p>In <code>traceroute</code>-speak, an asterisk (<code>*</code>) represents a hop with no response. This doesn’t necessarily mean the hop failed, just that our system didn’t get a response back! This could be due to server configuration or a slow connection. By default, a hop will return a <code>*</code> if there’s no response for five seconds. There are three asterisks in this case to indicate that all three attempts went unanswered.</p>
<p>Let’s also take a look at our eighth hop:</p>
<p>
<img src="images/image-network-tools-traceroute-load-balanced-hop-screenshot.svg"
  style="width: auto;">
</p>
<p>This one entry has multiple addresses! What’s going on? This is an example of <em>load balancing</em> in action. In this case, the router at our seventh hop is directing traffic to multiple locations. This <em>balances</em> the <em>load</em> and ensures that one single router isn’t handling too much.</p>
<p>In this case, one of our hop attempts went to the <code>atln.ga</code> (Atlanta, Georgia) router, while the other two went to the <code>snjs.ca</code> (San Jose, California) router. We still see timestamps for all three hop attempts.</p>
<p>Because of load balancing, your connection to <code>.io</code> isn’t guaranteed to be the same each time. Try running <code>traceroute .io</code> again - do you see the exact same addresses as before?</p>
<h2 id="when-should-i-run-a-trace">When should I run a trace?</h2>
<p>Tracing is most useful for diagnosing network connectivity issues. Imagine your internet at home suddenly goes down! You can <code>traceroute</code> to a familiar domain to see if the connection fails before it gets to your own router (in which case, it’s likely a problem on your device), or it fails at a network outside yours.</p>
<p>You can also diagnose slow connections this way! If a hop has a very long response time (&gt; 50 ms), then it’s possible that a previous device in line is experiencing downtime or network congestion.</p>
<p><code>traceroute</code> is simple to use without them, but does include some command line arguments that can enhance its abilities. Check out <code>man traceroute</code> to learn more about what it can do!</p>
<h2 id="what-weve-learned-7">What we’ve learned</h2>
<p>When in doubt, <code>trace-</code> the <code>-route</code>! Tracing network traffic using the <code>traceroute</code> utility is a great way to identify what’s happening outside your own network.</p>
<p>After this lesson, you should be comfortable: - using <code>traceroute</code> to diagnose connection problems, - reading the output of a <code>traceroute</code> command, - and knowing when <code>traceroute</code> is the correct tool for the job.</p>
<hr />
<h1 id="practice-use-wireshark-to-capture-network-traffic">Practice: Use Wireshark To Capture Network Traffic</h1>
<p>Wireshark, a network analysis tool formerly known as Ethereal, captures packets in real time and display them in human-readable format. Wireshark includes filters, color coding, and other features that let you dig deep into network traffic and inspect individual packets.</p>
<p>This tutorial will get you up to speed with the basics of capturing packets, filtering them, and inspecting them. You can use Wireshark to inspect a suspicious program’s network traffic, analyze the traffic flow on your network, or troubleshoot network problems.</p>
<h2 id="installing-wireshark">Installing Wireshark</h2>
<p>You can download Wireshark for Windows or macOS from its <a href="https://www.wireshark.org/">official website</a>. If you’re using Linux or another UNIX-like system, you’ll probably find Wireshark in its package repositories. For example, if you’re using Ubuntu, you’ll find Wireshark in the Ubuntu Software Center.</p>
<p>Just a quick warning: Many organizations don’t allow Wireshark and similar tools on their networks. Don’t use this tool at work unless you have permission.</p>
<h2 id="capturing-packets">Capturing packets</h2>
<p>After downloading and installing Wireshark, you can launch it and double-click the name of a network interface under Capture to start capturing packets on that interface. For example, if you want to capture traffic on your wireless network, click your wireless interface. You can configure advanced features by clicking Capture &gt; Options, but this isn’t necessary for now.</p>
<figure>
<img src="images/wireshark-01.png" alt="capturing 1" /><figcaption>capturing 1</figcaption>
</figure>
<p>As soon as you click the interface’s name, you’ll see the packets start to appear in real time. Wireshark captures each packet sent to or from your system.</p>
<p>If you have promiscuous mode enabled—it’s enabled by default—you’ll also see all the other packets on the network instead of only packets addressed to your network adapter. To check if promiscuous mode is enabled, click Capture &gt; Options and verify the "Enable promiscuous mode on all interfaces" checkbox is activated at the bottom of this window.</p>
<figure>
<img src="images/wireshark-02.png" alt="capturing 2" /><figcaption>capturing 2</figcaption>
</figure>
<p>Click the red "Stop" button near the top left corner of the window when you want to stop capturing traffic.</p>
<figure>
<img src="images/wireshark-03.png" alt="capturing 3" /><figcaption>capturing 3</figcaption>
</figure>
<p>The packet list pane, located at the top of the window, shows all packets found in the active capture file. Each packet has its own row and corresponding number assigned to it, along with each of these data points:</p>
<ul>
<li><strong>No</strong>: This field indicates which packets are part of the same conversation. It remains blank until you select a packet.</li>
<li><strong>Time</strong>: The timestamp of when the packet was captured is displayed in this column. The default format is the number of seconds or partial seconds since this specific capture file was first created.</li>
<li><strong>Source</strong>: This column contains the address (IP or other) where the packet originated.</li>
<li><strong>Destination</strong>: This column contains the address that the packet is being sent to.</li>
<li><strong>Protocol</strong>: The packet’s protocol name, such as TCP, can be found in this column.</li>
<li><strong>Length</strong>: The packet length, in bytes, is displayed in this column.</li>
<li><strong>Info</strong>: Additional details about the packet are presented here. The contents of this column can vary greatly depending on packet contents.</li>
</ul>
<p>When a packet is selected in the top pane, you may notice one or more symbols appear in the No. column. Open or closed brackets and a straight horizontal line indicate whether a packet or group of packets are part of the same back-and-forth conversation on the network. A broken horizontal line signifies that a packet is not part of the conversation.</p>
<h2 id="color-coding">Color coding</h2>
<p>You’ll probably see packets highlighted in a variety of different colors. Wireshark uses colors to help you identify the types of traffic at a glance. By default, light purple is TCP traffic, light blue is UDP traffic, and black identifies packets with errors—for example, they could have been delivered out of order.</p>
<p>To view exactly what the color codes mean, click View &gt; Coloring Rules. You can also customize and modify the coloring rules from here, if you like.</p>
<h2 id="sample-captures">Sample captures</h2>
<p>If there’s nothing interesting on your own network to inspect, Wireshark’s wiki has you covered. The wiki contains a <a href="https://wiki.wireshark.org/SampleCaptures">page of sample capture</a> files that you can load and inspect. Click File &gt; Open in Wireshark and browse for your downloaded file to open one.</p>
<p>Download, open, and inspect each of these capture files so you can see what it looks like for that communication to have occurred over a network.</p>
<ul>
<li><a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=http.cap">http.cap</a> A simple HTTP request and response</li>
<li><a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=dns.cap">dns.cap</a> Various DNS lookups</li>
<li><a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=wpa-Induction.pcap">wpa.cap</a> 802.11 capture with WPA data encrypted using the password "Induction"</li>
</ul>
<p>You can also save your own captures in Wireshark and open them later. Click the File &gt; Save to save your captured packets.</p>
<h2 id="filtering-packets">Filtering packets</h2>
<p>If you’re trying to inspect something specific, such as the traffic a program sends when phoning home, it helps to close down all other applications using the network so you can narrow down the traffic. Still, you’ll likely have a large amount of packets to sift through. That’s where Wireshark’s filters come in.</p>
<p>The most basic way to apply a filter is by typing it into the filter box at the top of the window and clicking Apply (or pressing Enter). For example, type "dns" and you’ll see only DNS packets. When you start typing, Wireshark will help you autocomplete your filter.</p>
<figure>
<img src="images/wireshark-04.png" alt="capturing 4" /><figcaption>capturing 4</figcaption>
</figure>
<p>You can also click Analyze &gt; Display Filters to choose a filter from among the default filters included in Wireshark. From here, you can add your own custom filters and save them to easily access them in the future.</p>
<p>Another interesting thing you can do is right-click a packet and select Follow &gt; TCP Stream.</p>
<p>You’ll see the full TCP conversation between the client and the server. You can also click other protocols in the Follow menu to see the full conversations for other protocols, if applicable.</p>
<h2 id="inspecting-packets">Inspecting packets</h2>
<p>Click a packet to select it and you can dig down to view its details.</p>
<figure>
<img src="images/wireshark-05.png" alt="capturing 5" /><figcaption>capturing 5</figcaption>
</figure>
<p>You can also create filters from here — just right-click one of the details and use the Apply as Filter submenu to create a filter based on it.</p>
<figure>
<img src="images/wireshark-06.png" alt="capturing 6" /><figcaption>capturing 6</figcaption>
</figure>
<p>Wireshark is an extremely powerful tool, and this tutorial is just scratching the surface of what you can do with it. Professionals use it to debug network protocol implementations, examine security problems and inspect network protocol internals.</p>
<h2 id="assignment">Assignment</h2>
<p>Now, start Wireshark, start capturing network traffic, and perform various tasks on your computer using different applications. You will be surprised by the number of network requests made by your computer. See if you can identify the application that makes each request and the significance of each request.</p>
</body></html>
