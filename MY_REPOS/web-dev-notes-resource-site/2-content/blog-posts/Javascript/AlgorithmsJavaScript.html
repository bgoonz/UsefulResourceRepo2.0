<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<h1 id="algorithms-in-javascript">Algorithms in JavaScript</h1>
<blockquote>
<p>40 Problems, Solutions, and Explanations</p>
</blockquote>
<h2 id="problems-solutions-and-explanations">40 Problems, Solutions, and Explanations</h2>
<p><a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/@thonly?source=post_page-----b0bed68f4038--------------------------------"><img src="https://miro.medium.com/fit/c/96/96/1*GEKuz1L4KPVBovXQLXM6sA.jpeg" alt="Thon Ly" /></a></p>
<figure>
<img src="https://miro.medium.com/max/60/1*CMYOFHdAKR7pNWE2F-zIHA.jpeg?q=20" alt="Image for post" /><figcaption>Image for post</figcaption>
</figure>
<figure>
<img src="https://miro.medium.com/max/3840/1*CMYOFHdAKR7pNWE2F-zIHA.jpeg" alt="Image for post" /><figcaption>Image for post</figcaption>
</figure>
<p>The <strong>interview process</strong> usually begins with an initial <em>phone screen</em> and then an all-day <em>on-site</em> that check for <em>coding skills</em> and <em>cultural fit</em>. Almost without exception, the deciding factor is <strong>coding aptitude</strong>. After all, engineers are paid to deliver working software at the end of the day. Traditionally, <em>whiteboarding</em> is used to test for this aptitude. More than getting the answer right is the thought process clearly articulated. In code as in life, the right answer is not always clear, but good reasoning is usually good enough. The ability to <em>reason</em> <em>effectively</em> signals the potential to learn, adapt, and evolve. The best engineers are always growing, and the best companies are always innovating.</p>
<p><strong>Algorithm challenges</strong> are effective because there are more than one way to solve them. This opens the
  possibility for decisions to be made and the calculus of those decisions. When solving an algorithm problem, we should
  challenge ourselves to look at the <em>problem definition</em> from multiple perspectives, then weigh the
  <em>benefits</em> and <em>demerits</em> of various approaches. With enough practice, we might even glimpse a universal
  truth: <em>thereâ€™s no â€œperfect" solution.</em></p>
<p>To truly master <strong>Algorithms</strong> is to understand them in relationship to <strong>Data</strong>
  <strong>Structures</strong>. Data structures and algorithms go hand-in-hand like Yin and Yang, the <em>glass</em> and
  the <em>water</em>. Without the glass, water cannot be contained. Without data structures, we have no objects by which
  to apply logic. Without water, the glass is empty and devoid of sustenance. Without algorithms, objects cannot be
  transformed or â€œconsumed".</p>
<p><em>For a quick high-level analysis of</em> <a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/siliconwat/data-structures-in-javascript-1b9aed0ea17c"><em>Data Structures in JavaScript</em></a><em>:</em></p>
<p>Applied to code, an algorithm is just a <code>function</code> that transforms a certain <strong>input</strong> <em>data structure</em> into a certain <strong>output</strong> <em>data structure</em>. The <strong>logic</strong> <em>inside</em> decides the transformation. First and foremost, the inputs and outputs should <em>clearly</em> be defined, ideally, as <strong>unit tests</strong>. This requires fully understanding the problem at hand, which is not to be underestimated, because a thorough analysis of the problem can surface the solution naturally, without needing to write any code.</p>
<p>Once the problem domain is thoroughly grasped, <strong>brainstorming</strong> of the solution space can begin. <em>What variables will be needed? How many loops and what kinds? Are there any clever built-in methods that can help? Edge cases to consider?</em> Complex or repeated logic can be difficult to read and understand. <em>Can helper functions be extracted or abstracted?</em> An algorithm usually needs to be scalable. <em>As input sizes grow, how will the function perform?</em> <em>Should there be some kind of caching mechanisms?</em> Generally, memory optimizations (space) will need to be sacrificed for performance gains (time).</p>
<blockquote>
<p>To make the problem more concrete, draw <strong>diagrams</strong>!</p>
</blockquote>
<p>When a high-level structure of the solution begins to appear, the <strong>pseudocode</strong> can begin. To really impress the interviewer, look <em>ahead</em> for opportunities to refactor and <strong>reuse</strong> code. Sometimes, similar-behaving functions can be combined into a more general function that accepts an extra parameter. Other times, de-parametrization through <strong>currying</strong> is better. Keeping functions <strong>pure</strong> to ease testing and maintenance also shows foresight. In other words, consider <strong>architectural</strong> and <strong>design patterns</strong> in the calculus of your decisions.</p>
<blockquote>
<p>If anything is unclear, <em>ask</em> for clarification!</p>
</blockquote>
<h2 id="big-o">Big O</h2>
<p>To assist in the calculus of runtime complexities, we approximate the scalability of an algorithm by extrapolating its <em>input sizes</em> toward infinity before counting the <em>number of operations</em> required. At this worst-case runtime upper bound, we can drop coefficients and additive terms, retaining only factors that dominate the function. Consequently, just a few categories can describe the scalability of almost any algorithm.</p>
<p>The most optimum algorithm scales in <em>constant</em> time and space. This means it does not care at all about the growth of its inputs. Next best is <em>logarithmic</em> time or space, then <em>linear</em>, <em>linearithmic</em>, <em>quadratic</em>, and <em>exponential</em>. The worst is <em>factorial</em> time or space. In <strong>Big-O</strong> notation:</p>
<ol type="1">
<li><strong>Constant</strong>: O(1)</li>
<li><strong>Logarithmic</strong>: O(log n)</li>
<li><strong>Linear</strong>: O(n)</li>
<li><strong>Linearithmic</strong>: O(n log n)</li>
<li><strong>Quadratic</strong>: O(nÂ²)</li>
<li><strong>Expontential</strong>: O(2^n)</li>
<li><strong>Factorial</strong>: O(n!)</li>
</ol>
<figure>
<img src="https://miro.medium.com/max/60/1*-j3Q4EiyBgc1tDTR5uKTnQ.png?q=20" alt="Image for post" /><figcaption>Image for post</figcaption>
</figure>
<figure>
<img src="https://miro.medium.com/max/3364/1*-j3Q4EiyBgc1tDTR5uKTnQ.png" alt="Image for post" /><figcaption>Image for post</figcaption>
</figure>
<p>Graph: <a href="http://bigocheatsheet.com/">http://bigocheatsheet.com</a></p>
<p>Big-O <em>asymptotic analysis</em> is an indispensable tool as we consider the tradeoff between time and space complexities of an algorithm. However, Big O ignores constant factors when in actual practice may matter. Moreover, optimizing for time and space may increase implementation time or negatively impact code readability. When designing the structure and logic of an algorithm, the intuitive feel for what is truly negligible is as important.</p>
<h2 id="arrays">Arrays</h2>
<p>The cleanest algorithm usually takes advantage of <em>standard</em> <strong>objects</strong> inherent in the language. Arguably the most important in computer science is <code>Arrays</code>. In JavaScript, no other object has more utility methods than arrays. Array methods worth remembering are: <code>sort</code>, <code>reverse</code>, <code>slice</code>, and <code>splice</code>. Array elements are inserted beginning at the <em>0th index</em>. This means the last element is at <code>array.length â€” 1</code>. Arrays are the most optimal for <em>indexing</em> (pushing), but can be terrible at <em>inserting</em>, <em>deleting</em> (not popping), and <em>searching</em>. In JavaScript, arrays can grow <em>dynamically</em>.</p>
<p>In <strong>Big O</strong>:</p>
<ul>
<li><strong>Indexing</strong>: O(1)</li>
<li><strong>Inserting</strong>: O(n)</li>
<li><strong>Deleting</strong>: O(n)</li>
<li><strong>Brute-Force Searching</strong>: O(n)</li>
<li><strong>Optimized Searching</strong>: O(log n)</li>
</ul>
<p>Examples of these <code>Array</code> methods in code:</p>
<p>Itâ€™s also worthwhile to read the full documentation on MDN about <code>Arrays</code>:</p>
<p>Similar to arrays are <code>Sets</code> and <code>Maps</code>. In a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">set</a>, items are guaranteed to be <em>unique</em>. In a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">map</a>, items consist of <em>keys</em> and <em>values</em> in a dictionary-like relationship. Of course, <code>Objects</code> (and their literals) can also be used to store key-value pairs, but the keys must be <code>strings</code>.</p>
<h2 id="iterations">Iterations</h2>
<p>Intimately associated with <code>Arrays</code> is <strong>iterating</strong> through them using loops. In JavaScript, we can use <em>five</em> different <em>control structures</em> for iterations. The most customizable is the <code>for</code> loop, which we can use to iterate through array <em>indexes</em> in almost any order. If the <em>number of iterations</em> cannot be determined, we can use <code>while</code> and <code>do while</code> loops until a certain condition is met. For any object, we can use the <code>for in</code> and <code>for of</code> loops to iterate through its keys and values, respectively. To get both simultaneously, we can loop through its <code>entries()</code>. We can also <em>break out</em> of a loop at any time using a <code>break</code> statement, or <em>skip</em> <em>ahead</em> to the next iteration using a <code>continue</code> statement. For the most control, iterating through <code>generator</code> functions is the best.</p>
<p>Native array methods that iterate through all its items are: <code>indexOf</code>, <code>lastIndexOf</code>, <code>includes</code>, <code>fill</code>, and <code>join</code>. Additionally, we can provide a <code>callback</code> function to the following methods: <code>findIndex</code>, <code>find</code>, <code>filter</code>, <code>forEach</code>, <code>map</code>, <code>some</code>, <code>every</code>, and <code>reduce</code>.</p>
<p>Examples of these <code>Array</code> methods in code:</p>
<h2 id="recursions">Recursions</h2>
<p>In a seminal paper, the <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing Thesis</a> proves that any iterative function can be reproduced with a recursive one, and vice versa. Sometimes, a recursive approach is cleaner, clearer, and more elegant. Take this iterative <code>factorial</code> function for example:</p>
<p>const <strong>factorial</strong> = number =&gt; {<br />
let product = 1;<br />
for (let i = 2; i &lt;= number; i++) {<br />
product *= i;<br />
}<br />
return product;<br />
};</p>
<p>Expressed as a <code>recursive</code> function, only <em>one</em> line of code is needed!</p>
<p>const <strong>factorial</strong> = number =&gt; {<br />
return number &lt; 2 ? 1 : number * factorial(number - 1);<br />
};</p>
<p>All recursive functions share a <em>common pattern</em>. They are made from creating a <em>recursive part</em> that calls itself, and a <em>base case</em> that does not. Whenever a <code>function</code> calls itself, it pushes a new <code>execution context</code> to the <code>execution stack</code>. This continues until the <em>base case</em> is met, then the <em>stack</em> unwinds as <em>contexts</em> are popped off one by one. For this reason, careless dependence on recursion can lead to the dreaded <code>stack overflow</code> runtime error.</p>
<p>The <code>factorial</code> function in live code:</p>
<p>Finally, we are ready to take on any algorithm challenge! ðŸ˜‰</p>
<p>In this section, we will walk through 22 <em>commonly-asked</em> algorithm questions in order of difficulty. Alternate approaches will be discussed as well their tradeoffs and runtime complexities. Usually, the most elegant solution utilizes a special â€œtrick" or key insight. With this in mind, letâ€™s begin!</p>
<h2 id="string-reversal">1. String Reversal</h2>
<p>Given a <code>string of characters</code> as <em>input</em>, write a <code>function</code> that returns it with the characters <em>reversed</em>.</p>
<p>describe(â€œString Reversal", () =&gt; {<br />
it(â€œ<strong>Should reverse string</strong>", () =&gt; {<br />
assert.equal(reverse(â€œHello World!"), â€œ!dlroW olleH");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>If we know the â€œtrick", the solution is trivial. That trick is to realize we can simply use the built-in <code>reverse</code> method for an <em>array.</em> First, we use the <code>split</code> method on a <em>string</em> to generate an <code>array of characters</code>, then we can apply the <code>reverse</code> method before using the <code>join</code> method to combine the characters back into a <em>string</em> again. This solution can be written in just one line of code! Though not as elegant, the problem can also be solved using the latest syntax and helper method. With the new <code>for of</code> loop that iterates through every character of any string, we can show off our familiarity with the latest syntax. Alternatively, we can also use the arrayâ€™s <code>reduce</code> method which eliminates the need to keep a temporary variable.</p>
<p>Given a string of characters, every character needs to be visited once. Though this happens multiple times, the <em>time complexity</em> normalizes out to <em>linear</em>. And since no separate internal data structure is kept, the <em>space complexity</em> is <em>constant</em>.</p>
<p><strong>Code</strong>:</p>
<h2 id="palindrome">2. Palindrome</h2>
<p>A <em>palindrome</em> is a <code>word</code> or <code>phrase</code> that reads the same <em>backward as forward</em>. Write a <code>function</code> that checks for this.</p>
<p>describe(â€œPalindrome", () =&gt; {<br />
it(â€œ<strong>Should return true</strong>", () =&gt; {<br />
assert.equal(isPalindrome(â€œCigar? Toss it in a can. It is so tragic"), true);<br />
}); it(â€œ<strong>Should return false</strong>", () =&gt; {<br />
assert.equal(isPalindrome(â€œsit ad est love"), false);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The key insight here is to realize that we can build on what weâ€™d learned from the previous problem. Except, we need to return a <code>boolean</code> value. This is as simple as returning a <em>triple equality</em> check against the <em>original string</em>. We could also use the new <code>every</code> method on an <em>array</em> to check that the <em>first</em> and <em>last</em> characters match up in sequential order <em>towards the center</em>. However, this will check two times more than necessary. Similar to the previous problem, the runtime complexities for both time and space are identical.</p>
<p>What if we wanted to expand our function to test an entire <em>phrase</em>? We can create a <em>helper function</em> that uses <strong>Regular Expressions</strong> and the <code>replace</code> method on a <code>string</code> to keep only the letters. If regular expressions are not allowed, we can create an <code>array</code> of <em>acceptable characters</em> to use as a filter.</p>
<p><strong>Code</strong>:</p>
<h2 id="integer-reversal">3. Integer Reversal</h2>
<p>Given an <code>integer</code>, <em>reverse</em> the order of the digits.</p>
<p>describe(â€œInteger Reversal", () =&gt; {<br />
it(â€œ<strong>Should reverse integer</strong>", () =&gt; {<br />
assert.equal(reverse(1234), 4321);<br />
assert.equal(reverse(-1200), -21);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The clever trick here is to first convert the integer to a <code>string</code> using the built-in <code>toString</code> method. Then, we can simply reuse the logic from the <em>String Reversal</em> algorithm. After the digits are reversed, we can use the global <code>parseInt</code> function to convert the string back to an integer, and <code>Math.sign</code> to carry over the polarity. This approach reduces to just one line of code!</p>
<p>Since we reuse the logic from <em>String Reversal</em>, this algorithm also shares the same runtime complexities for both space and time.</p>
<p><strong>Code</strong>:</p>
<h2 id="fizz-buzz">4. Fizz Buzz</h2>
<p>Given a <code>number</code> as an input, print out every integer from 1 to that number. However, when the integer is divisible by 2, print out â€œFizz"; when itâ€™s divisible by 3, print out â€œBuzz"; when itâ€™s divisible by both 2 and 3, print out â€œFizz Buzz".</p>
<p>describe(â€œFizz Buzz", () =&gt; {<br />
beforeEach(() =&gt; (output = fizzBuzz(30))); it(â€œ<strong>Should output number</strong>", () =&gt; {<br />
assert.equal(output[0], 1);<br />
}); it(â€œ<strong>Should output Fizz</strong>", () =&gt; {<br />
assert.equal(output[1], â€œFizz");<br />
}); it(â€œ<strong>Should output Buzz</strong>", () =&gt; {<br />
assert.equal(output[2], â€œBuzz");<br />
}); it(â€œ<strong>Should output Fizz Buzz</strong>", () =&gt; {<br />
assert.equal(output[5], â€œFizz Buzz");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>When we realize that the <em>modulus operator</em> can be used to check for divisibility, this classic algorithm challenge becomes trivial. The modulus divides two numbers and returns the remainder. Therefore, we can simply loop through every integer and check for remainders of <code>0</code>. To show off our mathematical prowess, we can take into account that when a number is divisible by both <code>a</code> and <code>b</code>, itâ€™s also divisible by their <em>lowest common multiple</em>.</p>
<p>As usual, the runtime complexities are the same because every integer is visited and checked without needing to keep an internal state.</p>
<p><strong>Code</strong>:</p>
<h2 id="max-character">5. Max Character</h2>
<p>Given a <code>string</code> of characters, return the <code>character</code> that <em>appears the most often</em>.</p>
<p>describe(â€œMax Character", () =&gt; {<br />
it(â€œ<strong>Should return max character</strong>", () =&gt; {<br />
assert.equal(max(â€œHello World!"), â€œl");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The trick is to create a table that tallies the appearance of each character as we loop through the string. This table can be created using an <code>object literal</code> where the <code>characters</code> are <em>keys</em> and the <code>counters</code> are <em>values</em>. Then, we can iterate through the table to find the character that has the largest counter by keeping <em>temporary</em> <code>variables</code> for its key and value.</p>
<p>Though we use two separate loops that iterate through two different inputs (<em>character string</em> and <em>character map</em>), the time complexity is still <em>linear</em>. It may be derived from the character string, but eventually, the size of the character map will reach a limit because thereâ€™s only a <em>finite</em> number of characters in any language. For the same reason, the space complexity is <em>constant</em> despite how the input string grows even though an internal state is kept. Temporary primitives are also negligible at large scales.</p>
<p><strong>Code</strong>:</p>
<h2 id="anagrams">6. Anagrams</h2>
<p>Anagrams are <code>words</code> or <code>phrases</code> that contain the <em>same number of characters</em>. Create a <code>function</code> that checks for this.</p>
<p>describe(â€œAnagrams", () =&gt; {<br />
it(â€œ<strong>Should implement anagrams</strong>", () =&gt; {<br />
assert.equal(anagrams(â€œhello world", â€œworld hello"), true);<br />
assert.equal(anagrams(â€œhellow world", â€œhello there"), false);<br />
assert.equal(anagrams(â€œhellow world", â€œhello there!"), false);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>An obvious approach is to create a <em>character map</em> that tallies the number of characters for each input string. Then, we can compare the maps to see if they are identical. The logic that creates the character maps can be extracted as a <em>helper function</em> for easier reuse. To be thorough, we should first remove all non-alphabetic characters from the input strings and then make the remainder all lowercase.</p>
<p>As weâ€™ve seen, character maps have a <em>linear</em> time complexity and a <em>constant</em> space complexity. To be more precise, this approach has <code>O(n + m)</code> for time because two different strings are checked.</p>
<p>A more elegant approach is to realize that we can simply <code>sort</code> the input strings and then check for equality! However, the downside is that sorting usually requires <em>linearithmic</em> time.</p>
<p><strong>Code</strong>:</p>
<h2 id="vowels">7. Vowels</h2>
<p>Given a <code>string</code> of words or phrases, <em>count</em> the number of <code>vowels</code>.</p>
<p>describe(â€œVowels", () =&gt; {<br />
it(â€œ<strong>Should count vowels</strong>", () =&gt; {<br />
assert.equal(vowels(â€œhello world"), 3);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The easiest solution is to take advantage of <em>regular expressions</em> to extract all the vowels and then count them. If regular expressions are not allowed, we can simply loop through every character and check it against a collection of vowels. The string should be <em>lowercased</em> first.</p>
<p>Both approaches have <em>linear</em> time complexity and <em>constant</em> space complexity because every character needs to be checked and temporary primitives are negligible.</p>
<p><strong>Code</strong>:</p>
<h2 id="array-chunking">8. Array Chunking</h2>
<p>Given an <code>array</code> and a <code>size</code>, split the array <em>items</em> into a <code>list</code> of <em>arrays</em> of the given size.</p>
<p>describe(â€œArray Chunking", () =&gt; {<br />
it(â€œ<strong>Should implement array chunking</strong>", () =&gt; {<br />
assert.deepEqual(chunk([1, 2, 3, 4], 2), [[1, 2], [3, 4]]);<br />
assert.deepEqual(chunk([1, 2, 3, 4], 3), [[1, 2, 3], [4]]);<br />
assert.deepEqual(chunk([1, 2, 3, 4], 5), [[1, 2, 3, 4]]);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>An obvious solution is to keep a reference to the last â€œchunk" and check its size as we loop through the array items. A more elegant solution is to use the built-in <code>slice</code> method. This way, no reference is needed, producing a cleaner code. This can be achieved with a <code>while</code> loop or a <code>for</code> loop that increments by steps of the given size.</p>
<p>These algorithms all have <em>linear</em> time complexity because every array item needs to be visited once. They also have a <em>linear</em> space complexity because an internal array of â€œchunks" is kept which grows proportionally to the input array.</p>
<p><strong>Code</strong>:</p>
<h2 id="reverse-array">9. Reverse Array</h2>
<p>Given an <code>array</code> of items, <em>reverse</em> the order.</p>
<p>describe(â€œReverse Arrays", () =&gt; {<br />
it(â€œ<strong>Should reverse arrays</strong>", () =&gt; {<br />
assert.deepEqual(reverseArray([1, 2, 3, 4]), [4, 3, 2, 1]);<br />
assert.deepEqual(reverseArray([1, 2, 3, 4, 5]), [5, 4, 3, 2, 1]);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>Of course, an obvious solution is to use the built-in <code>reverse</code> method. But this would be too easy! If not allowed, we can simply loop through one half of the array and <em>swap</em> the beginning with the end. This means we will need to temporarily store <em>one</em> of the items in memory. To circumvent this need, we can use <em>destructuring assignment</em> with array matching.</p>
<p>Though only one half of the input array is visited, the time complexity is still <em>linear</em> because Big O asymptotically ignores coefficients.</p>
<p><strong>Code</strong>:</p>
<h2 id="reverse-words">10. Reverse Words</h2>
<p>Given a <code>phrase</code>, <em>reverse</em> the order of the characters of each word.</p>
<p>describe(â€œReverse Words", () =&gt; {<br />
it(â€œ<strong>Should reverse words</strong>", () =&gt; {<br />
assert.equal(reverseWords(â€œI love JavaScript!"), â€œI evol !tpircSavaJ");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>We can use the split method to create an array of individual words. Then for each word, we can reuse the logic from <em>Reverse String</em> to reverse its characters. An alternative approach is to loop through each word in <em>reverse order</em> and store the result in a temporary variable. Either way, we will need to temporarily save all the reversed words before joining them at the end.</p>
<p>Because every character is visited and the required temporary variable grows proportionately to the input string, the time and space complexities are <em>linear</em>.</p>
<p><strong>Code</strong>:</p>
<h2 id="capitalization">11. Capitalization</h2>
<p>Given a <code>phrase</code>, <em>capitalize</em> every word.</p>
<p>describe(â€œCapitalization", () =&gt; {<br />
it(â€œ<strong>Should capitalize phrase</strong>", () =&gt; {<br />
assert.equal(capitalize(â€œhello world"), â€œHello World");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>One approach is to loop through every character, and when the previous character is a <em>space</em>, apply <code>toUpperCase</code> to capitalize the current character. Because <strong>string literals</strong> are <em>immutable</em> in JavaScript, we will need to rebuild the input string with the appropriate capitalizations. This approach requires us to always capitalize the first character. Perhaps a cleaner approach is to <code>split</code> the input string into an <em>array of words.</em> Then, we can loop through this array and capitalize the first characters, before joining the words back together again. For the same reason of immutability, we will need to hold in memory a <em>temporary array</em> that contains the appropriate capitalizations.</p>
<p>Both approaches have a <em>linear</em> time complexity because every character is visited at least once. They also have a <em>linear</em> space complexity because a temporary variable is kept which grows proportionally to the input string.</p>
<p><strong>Code</strong>:</p>
<h2 id="caesar-cipher">12. Caesar Cipher</h2>
<p>Given a <code>phrase</code>, <em>substitute</em> each character by shifting it up or down the alphabet by a given <code>integer</code>. If necessary, the shifting should wrap around back to the beginning or end of the alphabet.</p>
<p>describe(â€œCaesar Cipher", () =&gt; {<br />
it(â€œ<strong>Should shift to the right</strong>", () =&gt; {<br />
assert.equal(caesarCipher(â€œI love JavaScript!", 100), â€œE hkra FwrwOynelp!");<br />
});it(â€œ<strong>Should shift to the left</strong>", () =&gt; {<br />
assert.equal(caesarCipher(â€œI love JavaScript!", -100), â€œM pszi NezeWgvmtx!");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>Firstly, we will need to create an <code>array</code> of <em>alphabet characters</em> in order to calculate the result of shifting a character. This means we need to lowercase the <code>input string</code> before iterating through its characters. We should use a regular <code>for</code> loop to easily keep track of the current index. We will need to build up a <code>new string</code> that contains the shifted characters per iteration. When we meet a non-alphabetic character, we should immediately append it to the end of our solution string and use the <code>continue</code> statement to skip ahead to the next iteration. The key insight is to realize that we can use the <code>modulus operator</code> to mimic the behavior of wrapping around to the beginning or end of the alphabet array when the shifting is more than 26. Lastly, we need to check for capitalization in the original string before appending the result to our solution.</p>
<p>Since every character in the input string needs to be visited and a new string needs to be created from it, this algorithm has a <em>linear</em> time and space complexity.</p>
<p><strong>Code</strong>:</p>
<h2 id="ransom-note">13. Ransom Note</h2>
<p>Given a <code>magazine of words</code> and a <code>ransom note</code>, determine if itâ€™s possible to â€œcut out" and create the <em>ransom note</em> from the <em>magazine words</em>.</p>
<p>const <strong>magazine</strong> =<br />
â€œ<em>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</em>";describe(â€œRansom Note", () =&gt; {<br />
it(â€œ<strong>Should return true</strong>", () =&gt; {<br />
assert.equal(ransomNote(â€œsit ad est sint", magazine), true);<br />
});it(â€œ<strong>Should return false</strong>", () =&gt; {<br />
assert.equal(ransomNote(â€œsit ad est love", magazine), false);<br />
});it(â€œ<strong>Should return true</strong>", () =&gt; {<br />
assert.equal(ransomNote(â€œsit ad est sint in in", magazine), true);<br />
});it(â€œ<strong>Should return false</strong>", () =&gt; {<br />
assert.equal(ransomNote(â€œsit ad est sint in in in in", magazine), false);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>An obvious solution is to split the magazine words and ransom words into <em>arrays</em> of individual words, and then check every ransom word against every magazine word. However, this approach scales in <em>quadratic</em> time, or <code>O(n * m)</code> which is not performant. If we create a table of magazine words first, and then check each ransom word against this table, we can achieve <em>linear</em> time. This is because table lookup in <em>map objects</em> occurs in <em>constant</em> time. However, we will need to sacrifice space complexity in order to hold the map object in memory.</p>
<p>In code, this means we create a count of every magazine word, and then check if this â€œhash table" contains the right number of ransom words.</p>
<p><strong>Code</strong>:</p>
<h2 id="mean-median-and-mode">14. Mean, Median, and Mode</h2>
<p>Given an <code>array</code> of numbers, calculate the <em>mean</em>, <em>median</em>, and <em>mode</em>.</p>
<p>const <strong>stat1</strong> = new Stats([1, 2, 3, 4, 4, 5, 5]);<br />
const <strong>stat2</strong> = new Stats([1, 1, 2, 2, 3, 3, 4, 4]);describe(â€œMean", () =&gt; {<br />
it(â€œ<strong>Should implement mean</strong>", () =&gt; {<br />
assert.equal(Stats.round(stat1.mean()), 3.43);<br />
assert.equal(Stats.round(stat2.mean()), 2.5);<br />
});<br />
});describe(â€œMedian", () =&gt; {<br />
it(â€œ<strong>Should implement median</strong>", () =&gt; {<br />
assert.equal(stat1.median(), 4);<br />
assert.equal(stat2.median(), 2.5);<br />
});<br />
});describe(â€œMode", () =&gt; {<br />
it(â€œ<strong>Should implement mode</strong>", () =&gt; {<br />
assert.deepEqual(stat1.mode(), [4, 5]);<br />
assert.deepEqual(stat2.mode(), []);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>In terms of difficulty, the algorithm to find the <em>mean</em> of a collection of numbers is the easiest. Statistically, the <code>mean</code> is defined as the <em>sum</em> of the collection divided by its <em>size</em>. Therefore, we can simply use the arrayâ€™s <code>reduce</code> method to calculate its sum and then divide that by its <code>length</code>. This algorithm has runtime complexities of <em>linear</em> time and <em>constant</em> space because every number needs to be added while no internal memory is necessary.</p>
<p>The algorithm to find the <em>median</em> of a collection is of medium difficulty. First, we need to sort the array, but if its size is even, we will need extra logic to deal with two middle numbers. In these cases, we will need to return the <em>average</em> of those two numbers. This algorithm has a <em>linearithmic</em> time complexity due to sorting and a <em>linear</em> space complexity because internal memory is needed to hold the sorted array.</p>
<p>The algorithm to find the <em>mode</em> is the most challenging. Since the <code>mode</code> is defined as the number or numbers that appear the most often, we will need to maintain a <em>frequency table</em>. To complicate things further, if every value appears the same number of times, there is no mode. In code, this means we will need to create a <em>hash map</em> that tallies the frequency of each unique number, and then loop through it to collect the maximum number or numbers, or none. Because every number needs to be counted to create the hash table which is held in memory, this algorithm has a <em>linear</em> time and space complexity.</p>
<p><strong>Code</strong>:</p>
<h2 id="two-sum">15. Two Sum</h2>
<p>Given an <code>array</code> of numbers, return <em>all pairs</em> that add up to a given <code>sum</code>. The numbers can be used more than once.</p>
<p>describe(â€œTwo Sum", () =&gt; {<br />
it(â€œ<strong>Should implement two sum</strong>", () =&gt; {<br />
assert.deepEqual(twoSum([1, 2, 2, 3, 4], 4), [[2, 2], [3, 1]]);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>An obvious solution is to create <em>nested loops</em> that check each number against every other number in the same array. Those that add up to the given sum can be pushed to a <em>solution array</em> as pairs. However, this nesting causes a <em>quadratic</em> time complexity which is not performant for large inputs.</p>
<p>A clever trick is to maintain an array that contains the â€œcounterpart" of each number as we iterate through the input array, while simultaneously checking for the existence of each numberâ€™s counterpart. By maintaining such an array, we sacrifice space efficiency to gain a <em>linear</em> time complexity.</p>
<p><strong>Code</strong>:</p>
<h2 id="max-profit">16. Max Profit</h2>
<p>Given an <code>array</code> of stock prices, find the <em>minimum</em> <code>buy price</code> and the <em>maximum</em> <code>sell price</code> that produce the <em>greatest profit</em>.</p>
<p>describe(â€œMax Profit", () =&gt; {<br />
it(â€œ<strong>Should return minimum buy price and maximum sell price</strong>", () =&gt; {<br />
assert.deepEqual(maxProfit([1, 2, 3, 4, 5]), [1, 5]);<br />
assert.deepEqual(maxProfit([2, 1, 5, 3, 4]), [1, 5]);<br />
assert.deepEqual(maxProfit([2, 10, 1, 3]), [2, 10]);<br />
assert.deepEqual(maxProfit([2, 1, 2, 11]), [1, 11]);<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>Again, we can create <em>nested loops</em> that check every possible combination of buy price and sell price to see which pair produces the greatest profit. Because technically we cannot sell before we buy, not every combination needs to be checked. Specifically, for a given buy price, we can ignore all preceding prices for the sell price. As such, the time complexity for this algorithm is better than <em>quadratic</em>.</p>
<p>With a little more thought, we can solve the problem using only one loop through the prices array. The key insight is to realize that the sell price should never be less than the buy price; if so, we should have bought the stock at that lower price. In code, this means we can simply hold a <em>temporary boolean</em> to indicate that we should change the buy price on the next iteration. Requiring only one loop, this elegant approach has a <em>linear</em> time and <em>constant</em> space complexity.</p>
<p><strong>Code</strong>:</p>
<h2 id="sieve-of-eratosthenes">17. Sieve of Eratosthenes</h2>
<p>For a given <code>number</code>, find all the <em>prime numbers</em> from zero to that number.</p>
<p>describe(â€œSieve of Eratosthenes", () =&gt; {<br />
it(â€œ<strong>Should return all prime numbers</strong>", () =&gt; {<br />
assert.deepEqual(primes(10), [2, 3, 5, 7]);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>At first blush, we may be tempted to loop through every possible number and simply use the modulus operator to check for all the possible divisibilities. However, itâ€™s easy to surmise that this approach is terribly inefficient, with a time complexity worse than quadratic. Thankfully, <em>Eratosthenes of Cyrene</em>, the inventor of geography, also invented an efficient method for identifying prime numbers.</p>
<p>In code, the first step is to create an array as large as the given number, with all its values initialized as <code>true</code>. In other words, the array <em>indexes</em> represent all the possible prime numbers, with all being <em>true</em> at the beginning. Then, we create a <code>for</code> loop that iterates from 2 to the <em>square root</em> of the given number, using array <em>key interpolation</em> to designate the <code>product</code> with every number as <em>false</em>. By definition, products of any integer cannot be prime, while 0 and 1 are ignored because divisibility by them does not affect primality. Lastly, we can simply filter out all the <em>falsey</em> values to arrive at all the prime numbers.</p>
<p>By sacrificing space efficiency to maintain an internal â€œhash table", this <em>sieve</em> of Eratosthenes has a time complexity better than quadratic, or <code>O(n * log (log n))</code>.</p>
<p><strong>Code</strong>:</p>
<h2 id="fibonacci">18. Fibonacci</h2>
<p>Implement a <code>function</code> that returns the <em>fibonacci number</em> at a given <code>index</code>.</p>
<p>describe(â€œFibonacci", () =&gt; {<br />
it(â€œ<strong>Should implement fibonacci</strong>", () =&gt; {<br />
assert.equal(fibonacci(1), 1);<br />
assert.equal(fibonacci(2), 1);<br />
assert.equal(fibonacci(3), 2);<br />
assert.equal(fibonacci(6), 8);<br />
assert.equal(fibonacci(10), 55);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>Since a fibonacci number is the sum of the previous two, the simplest approach is to use <em>recursion</em>. The fibonacci series is premised on the first two being 0 and 1; therefore, we can use this fact to create our <em>base case</em>. For index that is greater than 2, we can recall our fibonacci function to add the previous two. Though quite elegant, this recursive approach is terribly inefficient, with an <em>exponential</em> time and <em>linear</em> space complexity. Because every function call requires exponential memory on the call stack, it will quickly break.</p>
<p>Though not as elegant, an iterative approach is more time efficient. By using a loop to build the entire fibonacci series up to the given index, it achieves <em>linear</em> time and space.</p>
<p><strong>Code</strong>:</p>
<h2 id="memoized-fibonacci">19. Memoized Fibonacci</h2>
<p>Implement a <em>performant</em> recursive function for the fibonacci series.</p>
<p>describe(â€œMemoized Fibonacci", () =&gt; {<br />
it(â€œ<strong>Should implement memoized fibonacci</strong>", () =&gt; {<br />
assert.equal(fibonacci(6), 8);<br />
assert.equal(fibonacci(10), 55);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>Since the fibonacci series makes redundant exponential calls to itself, it can benefit dramatically from a strategy called <em>memoization</em>. In other words, if we keep a <em>cache</em> of all the inputs and outputs as we call our function, the number of calls will reduce to <em>linear</em> time. Of course, this means we have sacrificed additional memory.</p>
<p>In code, we can implement the memoization technique inside the function itself, or we can abstract it as a higher-order utility function that decorates any function with memoization.</p>
<p><strong>Code</strong>:</p>
<h2 id="staircase">20. Staircase</h2>
<p>For a given number of <code>steps</code>, print out a â€œstaircase" using <em>hashes</em> and <em>spaces</em>.</p>
<p>describe(â€œSteps", () =&gt; {<br />
it(â€œ<strong>Should print steps</strong>", () =&gt; {<br />
assert.equal(steps(3), â€œ# \n## \n###\n");<br />
assert.equal(_steps(3), â€œ# \n## \n###\n");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The key insight is to realize that as we move down the steps, the number of <code>hashes</code> <em>increments</em> while the number of <code>spaces</code> <em>decrements</em>. If we have <code>n</code> steps, the overall dimension is <code>n</code> by <code>n</code>. This means the runtime complexity is <em>quadratic</em> for both time and space.</p>
<p>A recursive approach is also possible using this insight. Except, we need to pass along <em>additional parameters</em> in place of the necessary temporary variables.</p>
<p><strong>Code</strong>:</p>
<h2 id="pyramid">21. Pyramid</h2>
<p>For a given number of <code>levels</code>, print out a â€œpyramid" using <em>hashes</em> and <em>spaces</em>.</p>
<p>describe(â€œPyramid", () =&gt; {<br />
it(â€œ<strong>Should print pyramid</strong>", () =&gt; {<br />
assert.equal(pyramid(3), " # \n ### \n#####\nâ€œ);<br />
assert.equal(_pyramid(3)," # \n ### \n#####\n");<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The key insight is to realize that a pyramid with <code>n</code> steps (height) has a width of <code>2 * n â€” 1</code>. Then, itâ€™s just a matter of <em>incrementing</em> the number of <em>hashes</em> and <em>decrementing</em> the number of <em>spaces</em> starting from the center outwards as we go down the levels. Since this algorithm iteratively builds up a pyramid of size <code>n</code> by <code>2 * n â€” 1</code>, it has a <code>quadratic</code> runtime complexity for both time and space.</p>
<p>Again, a recursive approach is also possible using this insight. Except, we need to pass along <em>additional parameters</em> in place of the necessary temporary variables.</p>
<p><strong>Code</strong>:</p>
<h2 id="matrix-spiral">22. Matrix Spiral</h2>
<p>Create a <em>square matrix</em> of a given <code>size</code> in which elements are in <em>spiral order</em>.</p>
<p>describe(â€œMatrix Spiral", () =&gt; {<br />
it(â€œ<strong>Should implement matrix spiral</strong>", () =&gt; {<br />
assert.deepEqual(spiral(3), [[1, 2, 3], [8, 9, 4], [7, 6, 5]]);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>Though a very challenging problem, the trick is to create <code>temporary variables</code> that point at the <em>current row</em> and <em>current column</em>, both at the <em>start</em> and the <em>end</em>. That way, we can iteratively <em>increment</em> the <code>starting row</code> and <code>starting column</code> and <em>decrement</em> the <code>ending row</code> and <code>ending column</code> in a manner that spirals toward the center of the matrix.</p>
<p>Because this algorithm iteratively builds up a <em>square</em> matrix of a given size, its runtime complexity is <em>quadratic</em> for both time and space.</p>
<p><strong>Code</strong>:</p>
<p>Since data structures are the â€œbuilding blocks" of algorithms, itâ€™s worthwhile to explore the most popular ones.</p>
<p><em>Again, for a quick high-level analysis, check out:</em></p>
<h2 id="queues">Queues</h2>
<p>Given two <code>queues</code> as inputs, create a <em>new</em> queue by â€œweaving" them together.</p>
<p>describe(â€œWeaving with Queues", () =&gt; {<br />
it(â€œ<strong>Should weave two queues together</strong>", () =&gt; {<br />
const one = new Queue();<br />
one.enqueue(1);<br />
one.enqueue(2);<br />
one.enqueue(3); const two = new Queue();<br />
two.enqueue(â€œone");<br />
two.enqueue(â€œtwo");<br />
two.enqueue(â€œthree"); const result = weave(one, two);<br />
assert.equal(result.dequeue(), 1);<br />
assert.equal(result.dequeue(), â€œone");<br />
assert.equal(result.dequeue(), 2);<br />
assert.equal(result.dequeue(), â€œtwo");<br />
assert.equal(result.dequeue(), 3);<br />
assert.equal(result.dequeue(), â€œthree");<br />
assert.equal(result.dequeue(), undefined);<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>At the minimum, the <code>Queue</code> class needs to have an <code>enqueue</code>, <code>dequeue</code>, and <code>peek</code> methods. Then, we can use the <code>while</code> loop to <em>peek</em> for existence, and if truthy, we can <em>dequeue</em> it out and then <em>enqueue</em> it to our new <code>queue</code>.</p>
<p>This algorithm has <code>O(n + m)</code> for both time and space because we need to iterate through two different collections and store them.</p>
<p><strong>Code</strong>:</p>
<h2 id="stacks">Stacks</h2>
<p>Implement a <code>Queue</code> class using two <em>stacks</em>.</p>
<p>describe(â€œQueue from Stacks", () =&gt; {<br />
it(â€œ<strong>Should implement queue using two stacks</strong>", () =&gt; {<br />
const queue = new Queue();<br />
queue.enqueue(1);<br />
queue.enqueue(2);<br />
queue.enqueue(3);<br />
assert.equal(queue.peek(), 1);<br />
assert.equal(queue.dequeue(), 1);<br />
assert.equal(queue.dequeue(), 2);<br />
assert.equal(queue.dequeue(), 3);<br />
assert.equal(queue.dequeue(), undefined);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>We can begin with a <em>class constructor</em> that initializes two stacks. Because the <em>last</em> record inserted is the <em>first</em> record removed in a <em>stack</em>, we will need to loop to the last record to â€œdequeue" or â€œpeek" to mimic the behavior of a <em>queue,</em> whereby the the <em>first</em> record inserted is the <em>first</em> record removed. We can do this by using the second stack to <em>temporarily</em> hold all the items from the first stack until we reach the end. After the â€œpeeking" or â€œdequeuing", we simply move everything back to the first stack. To â€œenqueue" a record, we can simply push it to the first stack.</p>
<p>Though we use two stacks and need to loop twice, this algorithm is still asymptotically <em>linear</em> in time and space.</p>
<p><strong>Code</strong>:</p>
<h2 id="linked-lists">Linked Lists</h2>
<p>Single linked lists usually have the following functionalities:</p>
<p>describe(â€œLinked List", () =&gt; {<br />
it(â€œ<strong>Should implement insertHead</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
assert.equal(chain.head.data, 1);<br />
}); it(â€œ<strong>Should implement size</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
assert.equal(chain.size(), 1);<br />
}); it(â€œ<strong>Should implement getHead</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
assert.equal(chain.getHead().data, 1);<br />
}); it(â€œ<strong>Should implement getTail</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
assert.equal(chain.getTail().data, 1);<br />
}); it(â€œ<strong>Should implement clear</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.clear();<br />
assert.equal(chain.size(), 0);<br />
}); it(â€œ<strong>Should implement removeHead</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.removeHead();<br />
assert.equal(chain.size(), 0);<br />
}); it(â€œ<strong>Should implement removeTail</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.removeTail();<br />
assert.equal(chain.size(), 0);<br />
}); it(â€œ<strong>Should implement insertTail</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertTail(1);<br />
assert.equal(chain.getTail().data, 1);<br />
}); it(â€œ<strong>Should implement getAt</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
assert.equal(chain.getAt(0).data, 1);<br />
}); it(â€œ<strong>Should implement removeAt</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.removeAt(0);<br />
assert.equal(chain.size(), 0);<br />
}); it(â€œ<strong>Should implement insertAt</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertAt(0, 1);<br />
assert.equal(chain.getAt(0).data, 1);<br />
}); it(â€œ<strong>Should implement forEach</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.insertHead(2);<br />
chain.forEach((node, index) =&gt; (node.data = node.data + index));<br />
assert.equal(chain.getTail().data, 2);<br />
}); it(â€œ<strong>Should implement iterator</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.insertHead(2);<br />
for (let node of chain) node.data = node.data + 1;<br />
assert.equal(chain.getTail().data, 2);<br />
});<br />
});</p>
<p><strong>Code</strong>:</p>
<p><strong>Challenge #1: Midpoint</strong></p>
<p>Without keeping a counter, return the <em>middle value</em> of a linked list.</p>
<p>describe(â€œMidpoint of Linked List", () =&gt; {<br />
it(â€œ<strong>Should return midpoint of linked list</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.insertHead(2);<br />
chain.insertHead(3);<br />
chain.insertHead(4);<br />
chain.insertHead(5);<br />
assert.equal(midpoint(chain).data, 3);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The trick is to traverse down the list <em>two times</em>, one of which is <em>two times faster</em>. When the faster one reaches the end, the slower one stops at the middle!</p>
<p>This algorithm has <em>linear</em> time and <em>constant</em> space.</p>
<p><strong>Code</strong>:</p>
<p><strong>Challenge #2: Circular</strong></p>
<p>Without keeping node references, check if a linked list is <em>circular</em>.</p>
<p>describe(â€œCircular Linked List", () =&gt; {<br />
it(â€œ<strong>Should check for circular linked list</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.insertHead(2);<br />
chain.insertHead(3);<br />
chain.head.next.next.next = chain.head;<br />
assert.equal(circular(chain), true);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>Many linked list functionalities are predicated on having a <em>definite</em> ending node. Therefore, ensuring that itâ€™s not circular is critical. Again, the trick is to traverse the list two times, one of which is two times faster. If the list is circular, eventually, the faster one will loop around and coincide with the slower one. We can exit the loop here and return <code>true</code>. Otherwise, the end will be reached, and we can return <code>false</code>.</p>
<p>This algorithm also has <em>linear</em> time and <em>constant</em> space.</p>
<p><strong>Code</strong>:</p>
<p><strong>Challenge #3: From Tail</strong></p>
<p>Without keeping a counter, return the <em>value</em> in a linked list that is at a given <code>step</code> away from the end.</p>
<p>describe(â€œFrom Tail of Linked List", () =&gt; {<br />
it(â€œ<strong>Should step from tail of linked list</strong>", () =&gt; {<br />
const chain = new LinkedList();<br />
chain.insertHead(1);<br />
chain.insertHead(2);<br />
chain.insertHead(3);<br />
chain.insertHead(4);<br />
chain.insertHead(5);<br />
assert.equal(fromTail(chain, 2).data, 3);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>The trick is similar to the previous in that we traverse the list two times. In this case, however, the â€œfaster" one begins <em>ahead</em> of the â€œslower" one, at the given <code>step</code> away. Then, we walk them both down the list at the same pace until the faster one reaches the end. At that point, the slower one is precisely at the right step away from the end.</p>
<p>This algorithm also has <em>linear</em> time and <em>constant</em> space.</p>
<p><strong>Code</strong>:</p>
<h2 id="trees">Trees</h2>
<p>Trees usually have the following functionalities:</p>
<p>describe(â€œTrees", () =&gt; {<br />
it(â€œ<strong>Should add and remove nodes</strong>", () =&gt; {<br />
const root = new Node(1);<br />
root.add(2);<br />
assert.equal(root.data, 1);<br />
assert.equal(root.children[0].data, 2);<br />
root.remove(2);<br />
assert.equal(root.children.length, 0);<br />
}); it(â€œ<strong>Should traverse by breadth</strong>", () =&gt; {<br />
const tree = new Tree();<br />
tree.root = new Node(1);<br />
tree.root.add(2);<br />
tree.root.add(3);<br />
tree.root.children[0].add(4); const numbers = [];<br />
tree.traverseBF(node =&gt; numbers.push(node.data));<br />
assert.deepEqual(numbers, [1, 2, 3, 4]);<br />
}); it(â€œ<strong>Should traverse by depth</strong>", () =&gt; {<br />
const tree = new Tree();<br />
tree.root = new Node(1);<br />
tree.root.add(2);<br />
tree.root.add(3);<br />
tree.root.children[0].add(4); const numbers = [];<br />
tree.traverseDF(node =&gt; numbers.push(node.data));<br />
assert.deepEqual(numbers, [1, 2, 4, 3]);<br />
});<br />
});</p>
<p><strong>Code</strong>:</p>
<p><strong>Challenge #1: Tree Widths</strong></p>
<p>For a given <code>tree</code>, return the <em>width</em> of each level.</p>
<p>describe(â€œWidth of Tree Levels", () =&gt; {<br />
it(â€œ<strong>Should return width of each tree level</strong>", () =&gt; {<br />
const root = new Node(1);<br />
root.add(2);<br />
root.add(3);<br />
root.children[1].add(4); assert.deepEqual(treeWidths(root), [1, 2, 1]);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>A tree can be traversed by <em>depth first</em> or <em>breadth first</em> using a <code>stack</code> or <code>queue</code> to help iterate through all its <em>slices</em> and <em>levels</em>, respectively. Since we want to count all the nodes on each level, we need to traverse the tree by <em>breadth first</em> with the help of a <code>queue</code>. The trick here is to enqueue a special <code>marker</code> to let us know that the end of the current level has been reached so that we can <em>reset</em> the <code>counter</code> for the next level.</p>
<p>This approach has a <em>linear</em> time and space complexity. Though our <code>counter</code> is an array, its size can never be greater than linear.</p>
<p><strong>Code</strong>:</p>
<p><strong>Challenge #2: Tree Height</strong></p>
<p>For a given <code>tree</code>, return the <em>height</em> (maximum number of levels).</p>
<p>describe(â€œHeight of Tree", () =&gt; {<br />
it(â€œ<strong>Should return max number of levels</strong>", () =&gt; {<br />
const root = new Node(1);<br />
root.add(2);<br />
root.add(3);<br />
root.children[1].add(4); assert.deepEqual(treeHeight(root), 2);<br />
});<br />
});</p>
<p><strong>Analysis</strong>:</p>
<p>We can simply reuse our logic from the first challenge. In this case, however, we increment our <code>counter</code> whenever we encounter <code>â€œreset"</code> instead. The logic is nearly identical, so this algorithm also has a <em>linear</em> time and space complexity. Here, our <code>counter</code> is just an integer, which makes its size even more negligible.</p>
<p><strong>Code</strong>:</p>
<h2 id="graphs">Graphs</h2>
<p>Please check back! (TK)</p>
<p>There are many algorithms that we can use to sort a collection of data. Thankfully, interviewers only expect us to understand the basics and first principles. For instance, the best algorithms can achieve <em>linearithmic</em> time in <em>constant</em> space. In this spirit, we will review the most popular ones in order of increasing difficulty and efficiency.</p>
<h2 id="bubble-sort">Bubble Sort</h2>
<p>This algorithm is the easiest to understand but is also the most inefficient. It <em>compares</em> every item against every other item, <em>swapping</em> the order until the bigger ones â€œbubble" to the top. This algorithm requires <em>quadratic</em> time and <em>constant</em> space.</p>
<h2 id="insertion-sort">Insertion Sort</h2>
<p>Like bubble sort, every item is compared with every other item. Instead of swapping, it â€œsplices" in the correct order. In effect, it maintains the original order of repeated items. This â€œgreedy" algorithm also requires <em>quadratic</em> time and <em>constant</em> space.</p>
<h2 id="selection-sort">Selection Sort</h2>
<p>As the loop iterates through a collection, this algorithm finds and â€œselects" the index with the <em>lowest value</em> and swaps it with the beginning index wherever appropriate. This algorithm also requires <em>quadratic</em> time and <em>constant</em> space.</p>
<h2 id="quick-sort">Quick Sort</h2>
<p>This algorithm recursively selects an element as the <em>pivot</em> and iteratively pushes all the smaller elements to the left and all the larger elements to the right until all is sorted. This algorithm requires <em>quadratic</em> time and <em>logarithmic</em> space such that in practice is often the <em>fastest</em>. As such, most programming languages natively implement this algorithm for sorting.</p>
<h2 id="merge-sort">Merge Sort</h2>
<p>Though one of the most efficient, this algorithm can be challenging to understand. It requires a <em>recursive</em> part that splits up a collection into single units, and then an <em>iterative</em> part that combines them back together in the right order. This algorithm takes <em>linearithmic</em> time and <em>linear</em> space.</p>
<h2 id="counting-sort">Counting Sort</h2>
<p>If we somehow know the <em>maximum value</em>, we can use this algorithm to sort a collection in <em>linear</em> time and space! The maximum value lets us create an array of that size to <em>count</em> the occurrence of each <em>index value</em>. Then, itâ€™s just a matter of extracting all the indexes that have <em>non-zero</em> counts into our result array. By exploiting the <em>constant-time</em> lookup of arrays, this hash-like algorithm is the most performant possible.</p>
<h2 id="other-sorting-algorithms">Other Sorting Algorithms</h2>
<figure>
<img src="https://miro.medium.com/max/2424/1*7ErHjLrOGhdkmMm_nQfo-g.png" alt="Image for post" /><figcaption>Image for post</figcaption>
</figure>
<p>Chart: <a href="http://bigocheatsheet.com/">http://bigocheatsheet.com</a></p>
<p>The worst algorithm needs to search every item in a collection, taking <code>O(n)</code> time. If somehow the collection is already sorted, only half needs to be checked at each iteration, taking just <code>O(log n)</code> time, a huge performance boost especially for very large datasets.</p>
<h2 id="binary-search">Binary Search</h2>
<p>When a collection is sorted, we can <em>iteratively</em> or <em>recursively</em> check our desired value against the middle item, discarding the half where we know our value cannot exist. In effect, our target can be found in <em>logarithmic</em> time and <em>constant</em> space.</p>
<h2 id="binary-search-tree">Binary Search Tree</h2>
<p>An alternative to sorting a collection is to generate a <em>Binary Search Tree</em> (BST) from it. As a BST, searching through it is as efficient as binary search. In a similar way, we can discard the half that we know cannot contain our desired value at every iteration. In fact, another way to sort a collection is to do a depth-first traversal across this tree <em>in-order</em>!</p>
<p>BST creation happens in <em>linear</em> time and space, but searching through it happens in <em>logarithmic</em> time and <em>constant</em> space.</p>
<p>To validate that a binary tree is a BST, we can recursively check that every left child must be less than the root (maximum possible) and every right child must be greater than the root (minimum possible) <em>at every root</em>. This solution requires <em>linear</em> time and <em>constant</em> space.</p>
<p>In modern web development, <strong>functions</strong> lie at the heart of the web experience. <strong>Data structures</strong> enter and exit functions while <strong>algorithms</strong> dictate the internal mechanics. The way a data structure scales is described by its <em>space complexity</em>, while the way an algorithm scales is described by its <em>time complexity</em>. In practice, runtime complexities are expressed as <strong>Big-O</strong> notations which help engineers to compare and contrast all the solution possibilities. The most efficient runtime is <em>constant</em> and does not depend on input sizes; the most inefficient requires <em>exponential</em> operations and memories. To truly master algorithms and data structures is to be able to reason <em>linearly</em> and <em>systemically</em> in parallel_._</p>
<p>Theoretically, every problem has both an <strong>iterative</strong> solution and a <strong>recursive</strong> one. An iterative approach starts from the bottom and <em>dynamically</em> arrives at a solution. A recursive approach starts from the top by recognizing <em>overlapping subproblems</em>. Usually, a recursive solution is more expressive and simpler to implement, but an iterative solution is easier to grok and requires less memory. With <em>first-class</em> functions and <em>control-flow</em> constructs, JavaScript natively supports both approaches. Generally, space efficiency needs to be sacrificed for performance gains, or time efficiency needs to be sacrificed for less memory usage. The right balance depends on the context and the environment. Thankfully, most interviewers are more concerned with the <em>calculus</em> than the outcome.</p>
<p>To really impress your interviewer, expand her purview by looking ahead and above for opportunities to utilize <strong>architectures</strong> and <strong>design patterns</strong> that increase <em>reusability</em> and <em>maintainability</em>. If youâ€™re seeking a senior position, knowledge of fundamentals and first principles, and experience with system-level design are equally important. Nevertheless, the best companies also assess for <em>cultural fit</em>. Because no one is perfect, the right team is essential. More importantly, some things in this world are impossible to achieve alone. More often than not, the things we create together and for each other are the most satisfying and meaningful.</p>
<p><em>Interested in</em> <strong><em>blockchain</em></strong>_?_ <a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/heartbankacademy/a-complete-mental-model-for-ethereum-dapp-development-5ce08598ed0a"><em>Learn Ethereum</em></a> <em>and come work for us!</em></p>
<p>References:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>
<li><a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis</a></li>
<li><a href="http://bigocheatsheet.com/">http://bigocheatsheet.com/</a></li>
<li><a href="https://www.udemy.com/coding-interview-bootcamp-algorithms-and-data-structure/">https://www.udemy.com/coding-interview-bootcamp-algorithms-and-data-structure/</a></li>
<li><a href="https://www.toptal.com/developers/sorting-algorithms">https://www.toptal.com/developers/sorting-algorithms</a></li>
</ul>
<p><a href="https://medium.com/siliconwat/algorithms-in-javascript-b0bed68f4038">Source</a></p>
</body></html>
