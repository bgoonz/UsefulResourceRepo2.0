<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<h1 id="intro-to-python-ii">
Intro to Python II
</h1>
<p>
Up to this point, you’ve gotten your feet wet by working on a bunch of small Python programs. In this module, we’re going to continue to solidify your Python chops by implementing a full-featured project according to a provided specification.
</p>
<h2 id="what-were-building">
What We’re Building
</h2>
<p>
<a href="https://youtu.be/WaZccFqJUT8">What’s an Adventure Game? <img src="https://tk-assets.lambdaschool.com/7928cdb4-b8a3-45a6-b231-5b9d1fc1e002_ScreenShot2019-03-22at5.47.28PM.png" alt="vid" /></a>
</p>
<h2 id="goals">
Goals
</h2>
<ul>
<li>
<p>
Put your Python basics into practice by implementing a text adventure game
</p>
</li>
<li>
<p>
Practice writing code that conforms to a specification
</p>
</li>
</ul>
<h2 id="mvp">
MVP
</h2>
<h3 id="day-1-mvp">
Day 1 MVP
</h3>
<ul>
<li>
[X] Create the REPL command parser in <code>adv.py</code> which allows the player to move to rooms in the four cardinal directions.
</li>
<li>
[X] Fill out Player and Room classes in <code>player.py</code> and <code>room.py</code>
</li>
</ul>
<h3 id="day-2-mvp">
Day 2 MVP
</h3>
<ul>
<li>
[X] Make rooms able to hold multiple items
</li>
<li>
[X] Make the player able to carry multiple items
</li>
<li>
[X] Add items to the game that the user can carry around
</li>
<li>
[X] Add <code>get [ITEM_NAME]</code> and <code>drop [ITEM_NAME]</code> commands to the parser
</li>
</ul>
<h2 id="specification">
Specification
</h2>
<p>
The <code>/src</code> directory contains the files <code>adv.py</code>, which is where the main logic for the game should live, <code>room.py</code>, which will contain the definition of the Room class, and <code>player.py</code>, which will contain the definition of the Player class.
</p>
<ul>
<li>
[X] Add a REPL parser to <code>adv.py</code> that accepts directional commands to move the player
<ul>
<li>
[X] After each move, the REPL should print the name and description of the player’s current room
</li>
<li>
[X] Valid commands are <code>n</code>, <code>s</code>, <code>e</code> and <code>w</code> which move the player North, South, East or West
</li>
<li>
[X] The parser should print an error if the player tries to move where there is no room.
</li>
</ul>
</li>
<li>
<p>
[X] Put the Room class in <code>room.py</code> based on what you see in <code>adv.py</code>.
</p>
<ul>
<li>
<p>
[X] The room should have <code>name</code> and <code>description</code> attributes.
</p>
</li>
<li>
<p>
[X] The room should also have <code>n_to</code>, <code>s_to</code>, <code>e_to</code>, and <code>w_to</code> attributes which point to the room in that respective direction.
</p>
</li>
</ul>
</li>
<li>
[X] Put the Player class in <code>player.py</code>.
<ul>
<li>
[X] Players should have a <code>name</code> and <code>current_room</code> attributes
</li>
</ul>
</li>
<li>
<p>
[X] Create a file called <code>item.py</code> and add an <code>Item</code> class in there.
</p>
<ul>
<li>
<p>
[X] The item should have <code>name</code> and <code>description</code> attributes.
</p>
<ul>
<li>
[X] Hint: the name should be one word for ease in parsing later.
</li>
</ul>
</li>
<li>
<p>
[ ] This will be the <em>base class</em> for specialized item types to be declared later.
</p>
</li>
</ul>
</li>
<li>
<p>
[X] Add the ability to add items to rooms.
</p>
<ul>
<li>
<p>
[X] The <code>Room</code> class should be extended with a <code>list</code> that holds the <code>Item</code>s that are currently in that room.
</p>
</li>
<li>
<p>
[X] Add functionality to the main loop that prints out all the items that are visible to the player when they are in that room.
</p>
</li>
</ul>
</li>
<li>
<p>
[X] Add capability to add <code>Item</code>s to the player’s inventory. The inventory can also be a <code>list</code> of items “in” the player, similar to how <code>Item</code>s can be in a <code>Room</code>.
</p>
</li>
<li>
<p>
[X] Add a new type of sentence the parser can understand: two words.
</p>
<ul>
<li>
<p>
[X] Until now, the parser could just understand one sentence form:
</p>
<p>
<code>verb</code>
</p>
<p>
such as “n” or “q”.
</p>
</li>
<li>
<p>
[X] But now we want to add the form:
</p>
<p>
<code>verb</code> <code>object</code>
</p>
<p>
such as “take coins” or “drop sword”.
</p>
</li>
<li>
<p>
[X] Split the entered command and see if it has 1 or 2 words in it to determine if it’s the first or second form.
</p>
</li>
</ul>
</li>
<li>
<p>
[X] Implement support for the verb <code>get</code> followed by an <code>Item</code> name. This will be used to pick up <code>Item</code>s.
</p>
<ul>
<li>
<p>
[X] If the user enters <code>get</code> or <code>take</code> followed by an <code>Item</code> name, look at the contents of the current <code>Room</code> to see if the item is there.
</p>
<ul>
<li>
<p>
[X] If it is there, remove it from the <code>Room</code> contents, and add it to the <code>Player</code> contents.
</p>
</li>
<li>
<p>
[X] If it’s not there, print an error message telling the user so.
</p>
</li>
<li>
<p>
[X] Add an <code>on_take</code> method to <code>Item</code>.
</p>
<ul>
<li>
<p>
[X] Call this method when the <code>Item</code> is picked up by the player.
</p>
</li>
<li>
<p>
[X] <code>on_take</code> should print out “You have picked up [NAME]” when you pick up an item.
</p>
</li>
<li>
<p>
[X] The <code>Item</code> can use this to run additional code when it is picked up.
</p>
</li>
</ul>
</li>
<li>
<p>
[X] Add an <code>on_drop</code> method to <code>Item</code>. Implement it similar to <code>on_take</code>.
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
[X] Implement support for the verb <code>drop</code> followed by an <code>Item</code> name. This is the opposite of <code>get</code>/<code>take</code>.
</p>
</li>
<li>
<p>
[X] Add the <code>i</code> and <code>inventory</code> commands that both show a list of items currently carried by the player.
</p>
</li>
</ul>
<h2 id="stretch-goals">
Stretch Goals
</h2>
<p>
In arbitrary order:
</p>
<ul>
<li>
<p>
[X] Add more rooms
</p>
</li>
<li>
<p>
[ ] Add scoring
</p>
</li>
<li>
<p>
[ ] Subclass items into treasures
</p>
</li>
<li>
<p>
[ ] Add a subclass to <code>Item</code> called <code>LightSource</code>.
</p>
<ul>
<li>
<p>
[ ] During world creation, add a <code>lamp</code> <code>LightSource</code> to a convenient <code>Room</code>.
</p>
</li>
<li>
<p>
[ ] Override <code>on_drop</code> in <code>LightSource</code> that tells the player “It’s not wise to drop your source of light!” if the player drops it. (But still lets them drop it.)
</p>
</li>
<li>
<p>
[ ] Add an attribute to <code>Room</code> called <code>is_light</code> that is <code>True</code> if the <code>Room</code> is naturally illuminated, or <code>False</code> if a <code>LightSource</code> is required to see what is in the room.
</p>
</li>
<li>
<p>
[ ] Modify the main loop to test if there is light in the <code>Room</code> (i.e. if <code>is_light</code> is <code>True</code> <strong>or</strong> there is a <code>LightSource</code> item in the <code>Room</code>’s contents <strong>or</strong> if there is a <code>LightSource</code> item in the <code>Player</code>’s contents).
</p>
</li>
<li>
<p>
[ ] If there is light in the room, display name, description, and contents as normal.
</p>
</li>
<li>
<p>
[ ] If there isn’t, print out “It’s pitch black!” instead.
</p>
</li>
<li>
<p>
Hint: <code>isinstance</code> might help you figure out if there’s a <code>LightSource</code> among all the nearby <code>Item</code>s.
</p>
</li>
<li>
<p>
[ ] Modify the <code>get</code>/<code>take</code> code to print “Good luck finding that in the dark!” if the user tries to pick up an <code>Item</code> in the dark.
</p>
</li>
</ul>
</li>
<li>
<p>
[X] Add methods to notify items when they are picked up or dropped
</p>
</li>
<li>
<p>
[ ] Add light and darkness to the game
</p>
</li>
<li>
<p>
[X] Add more items to the game.
</p>
</li>
<li>
<p>
[ ] Add a way to win.
</p>
</li>
<li>
<p>
[X] Add more to the parser.
</p>
<ul>
<li>
<p>
[ ] Remember the last <code>Item</code> mentioned and substitute that if the user types “it” later, e.g.
</p>
<pre><code>take sword
drop it</code></pre>
</li>
<li>
<p>
Add <code>Item</code>s with adjectives, like “rusty sword” and “silver sword”.
</p>
<ul>
<li>
<p>
Modify the parser to handle commands like “take rusty sword” as well as “take sword”.
</p>
<ul>
<li>
If the user is in a room that contains both the rusty sword <em>and</em> silver sword, and they type “take sword”, the parser should say, “I don’t know which you mean: rusty sword or silver sword.”
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
[ ] Modify the code that calls <code>on_take</code> to check the return value. If <code>on_take</code> returns <code>False</code>, then don’t continue picking up the object. (I.e. prevent the user from picking it up.)
</p>
<ul>
<li>
[ ] This enables you to add logic to <code>on_take</code> to code things like "don’t allow the user to pick up the dirt unless they’re holding the shovel.
</li>
</ul>
</li>
<li>
<p>
[ ] Add monsters.
</p>
</li>
<li>
<p>
[ ] Add the <code>attack</code> verb that allows you to specify a monster to attack.
</p>
</li>
<li>
<p>
[ ] Add an <code>on_attack</code> method to the monster class.
</p>
</li>
<li>
<p>
[ ] Similar to the <code>on_take</code> return value modification, above, have <code>on_attack</code> prevent the attack from succeeding unless the user possesses a <code>sword</code> item.
</p>
</li>
<li>
<p>
Come up with more stretch goals! The sky’s the limit!
</p>
</li>
</ul>
</body></html>
