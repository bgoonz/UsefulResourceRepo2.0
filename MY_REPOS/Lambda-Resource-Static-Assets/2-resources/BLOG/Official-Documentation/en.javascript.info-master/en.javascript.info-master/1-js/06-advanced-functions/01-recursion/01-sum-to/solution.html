<p>The solution using a loop:</p>
<p>```js run function sumTo(n) { let sum = 0; for (let i = 1; i &lt;= n; i++) { sum += i; } return sum; }</p>
<p>alert( sumTo(100) ); ```</p>
<p>The solution using recursion:</p>
<p>```js run function sumTo(n) { if (n == 1) return 1; return n + sumTo(n - 1); }</p>
<p>alert( sumTo(100) ); ```</p>
<p>The solution using the formula: <code>sumTo(n) = n*(n+1)/2</code>:</p>
<p>```js run function sumTo(n) { return n * (n + 1) / 2; }</p>
<p>alert( sumTo(100) ); ```</p>
<p>P.S. Naturally, the formula is the fastest solution. It uses only 3 operations for any number <code>n</code>. The math helps!</p>
<p>The loop variant is the second in terms of speed. In both the recursive and the loop variant we sum the same numbers. But the recursion involves nested calls and execution stack management. That also takes resources, so it’s slower.</p>
<p>P.P.S. Some engines support the “tail call” optimization: if a recursive call is the very last one in the function (like in <code>sumTo</code> above), then the outer function will not need to resume the execution, so the engine doesn’t need to remember its execution context. That removes the burden on memory, so counting <code>sumTo(100000)</code> becomes possible. But if the JavaScript engine does not support tail call optimization (most of them don’t), there will be an error: maximum stack size exceeded, because there’s usually a limitation on the total stack size.</p>
