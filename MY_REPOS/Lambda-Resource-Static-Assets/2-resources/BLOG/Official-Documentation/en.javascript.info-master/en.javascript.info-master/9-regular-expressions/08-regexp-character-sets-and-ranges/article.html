<h1 id="sets-and-ranges">Sets and ranges [â€¦]</h1>
<p>Several characters or character classes inside square brackets <code>[â€¦]</code> mean to â€œsearch for any character among givenâ€.</p>
<h2 id="sets">Sets</h2>
<p>For instance, <code>pattern:[eao]</code> means any of the 3 characters: <code>'a'</code>, <code>'e'</code>, or <code>'o'</code>.</p>
<p>Thatâ€™s called a <em>set</em>. Sets can be used in a regexp along with regular characters:</p>
<p><code>js run // find [t or m], and then "op" alert( "Mop top".match(/[tm]op/gi) ); // "Mop", "top"</code></p>
<p>Please note that although there are multiple characters in the set, they correspond to exactly one character in the match.</p>
<p>So the example below gives no matches:</p>
<p><code>js run // find "V", then [o or i], then "la" alert( "Voila".match(/V[oi]la/) ); // null, no matches</code></p>
<p>The pattern searches for:</p>
<ul>
<li><code>pattern:V</code>,</li>
<li>then <em>one</em> of the letters <code>pattern:[oi]</code>,</li>
<li>then <code>pattern:la</code>.</li>
</ul>
<p>So there would be a match for <code>match:Vola</code> or <code>match:Vila</code>.</p>
<h2 id="ranges">Ranges</h2>
<p>Square brackets may also contain <em>character ranges</em>.</p>
<p>For instance, <code>pattern:[a-z]</code> is a character in range from <code>a</code> to <code>z</code>, and <code>pattern:[0-5]</code> is a digit from <code>0</code> to <code>5</code>.</p>
<p>In the example below weâ€™re searching for <code>"x"</code> followed by two digits or letters from <code>A</code> to <code>F</code>:</p>
<p><code>js run alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF</code></p>
<p>Here <code>pattern:[0-9A-F]</code> has two ranges: it searches for a character that is either a digit from <code>0</code> to <code>9</code> or a letter from <code>A</code> to <code>F</code>.</p>
<p>If weâ€™d like to look for lowercase letters as well, we can add the range <code>a-f</code>: <code>pattern:[0-9A-Fa-f]</code>. Or add the flag <code>pattern:i</code>.</p>
<p>We can also use character classes inside <code>[â€¦]</code>.</p>
<p>For instance, if weâ€™d like to look for a wordly character <code>pattern:\w</code> or a hyphen <code>pattern:-</code>, then the set is <code>pattern:[\w-]</code>.</p>
<p>Combining multiple classes is also possible, e.g.Â <code>pattern:[\s\d]</code> means â€œa space character or a digitâ€.</p>
<p>```smart header=â€œCharacter classes are shorthands for certain character setsâ€ For instance:</p>
<ul>
<li>** â€“ is the same as <code>pattern:[0-9]</code>,</li>
<li>*** â€“ is the same as <code>pattern:[a-zA-Z0-9_]</code>,</li>
<li>*** â€“ is the same as <code>pattern:[\t\n\v\f\r ]</code>, plus few other rare Unicode space characters. ```</li>
</ul>
<h3 id="example-multi-language">Example: multi-language </h3>
<p>As the character class <code>pattern:\w</code> is a shorthand for <code>pattern:[a-zA-Z0-9_]</code>, it canâ€™t find Chinese hieroglyphs, Cyrillic letters, etc.</p>
<p>We can write a more universal pattern, that looks for wordly characters in any language. Thatâ€™s easy with Unicode properties: <code>pattern:[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]</code>.</p>
<p>Letâ€™s decipher it. Similar to <code>pattern:\w</code>, weâ€™re making a set of our own that includes characters with following Unicode properties:</p>
<ul>
<li><code>Alphabetic</code> (<code>Alpha</code>) - for letters,</li>
<li><code>Mark</code> (<code>M</code>) - for accents,</li>
<li><code>Decimal_Number</code> (<code>Nd</code>) - for digits,</li>
<li><code>Connector_Punctuation</code> (<code>Pc</code>) - for the underscore <code>'_'</code> and similar characters,</li>
<li><code>Join_Control</code> (<code>Join_C</code>) - two special codes <code>200c</code> and <code>200d</code>, used in ligatures, e.g.Â in Arabic.</li>
</ul>
<p>An example of use:</p>
<p>```js run let regexp = /[]/gu;</p>
<p>let str = <code>Hi ä½ å¥½ 12</code>;</p>
<p>// finds all letters and digits: alert( str.match(regexp) ); // H,i,ä½ ,å¥½,1,2 ```</p>
<p>Of course, we can edit this pattern: add Unicode properties or remove them. Unicode properties are covered in more details in the article <a href="info:regexp-unicode" class="uri">info:regexp-unicode</a>.</p>
<p>``<code>warn header="Unicode properties aren't supported in IE" Unicode properties</code>pattern:p{â€¦}` are not implemented in IE. If we really need them, we can use library <a href="http://xregexp.com/">XRegExp</a>.</p>
<p>Or just use ranges of characters in a language that interests us, e.g.Â <code>pattern:[Ğ°-Ñ]</code> for Cyrillic letters. ```</p>
<h2 id="excluding-ranges">Excluding ranges</h2>
<p>Besides normal ranges, there are â€œexcludingâ€ ranges that look like <code>pattern:[^â€¦]</code>.</p>
<p>They are denoted by a caret character <code>^</code> at the start and match any character <em>except the given ones</em>.</p>
<p>For instance:</p>
<ul>
<li><code>pattern:[^aeyo]</code> â€“ any character except <code>'a'</code>, <code>'e'</code>, <code>'y'</code> or <code>'o'</code>.</li>
<li><code>pattern:[^0-9]</code> â€“ any character except a digit, the same as <code>pattern:\D</code>.</li>
<li><code>pattern:[^\s]</code> â€“ any non-space character, same as <code>\S</code>.</li>
</ul>
<p>The example below looks for any characters except letters, digits and spaces:</p>
<p><code>js run alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ and .</code></p>
<h2 id="escaping-in">Escaping in [â€¦]</h2>
<p>Usually when we want to find exactly a special character, we need to escape it like <code>pattern:\.</code>. And if we need a backslash, then we use <code>pattern:\\</code>, and so on.</p>
<p>In square brackets we can use the vast majority of special characters without escaping:</p>
<ul>
<li>Symbols <code>pattern:. + ( )</code> never need escaping.</li>
<li>A hyphen <code>pattern:-</code> is not escaped in the beginning or the end (where it does not define a range).</li>
<li>A caret <code>pattern:^</code> is only escaped in the beginning (where it means exclusion).</li>
<li>The closing square bracket <code>pattern:]</code> is always escaped (if we need to look for that symbol).</li>
</ul>
<p>In other words, all special characters are allowed without escaping, except when they mean something for square brackets.</p>
<p>A dot <code>.</code> inside square brackets means just a dot. The pattern <code>pattern:[.,]</code> would look for one of characters: either a dot or a comma.</p>
<p>In the example below the regexp <code>pattern:[-().^+]</code> looks for one of the characters <code>-().^+</code>:</p>
<p>```js run // No need to escape let regexp = /[-().^+]/g;</p>
<p>alert( â€œ1 + 2 - 3â€.match(regexp) ); // Matches +, - ```</p>
<p>â€¦But if you decide to escape them â€œjust in caseâ€, then there would be no harm:</p>
<p>```js run // Escaped everything let regexp = /[-().^+]/g;</p>
<p>alert( â€œ1 + 2 - 3â€.match(regexp) ); // also works: +, - ```</p>
<h2 id="ranges-and-flag-u">Ranges and flag â€œuâ€</h2>
<p>If there are surrogate pairs in the set, flag <code>pattern:u</code> is required for them to work correctly.</p>
<p>For instance, letâ€™s look for <code>pattern:[ğ’³ğ’´]</code> in the string <code>subject:ğ’³</code>:</p>
<p><code>js run alert( 'ğ’³'.match(/[ğ’³ğ’´]/) ); // shows a strange character, like [?] // (the search was performed incorrectly, half-character returned)</code></p>
<p>The result is incorrect, because by default regular expressions â€œdonâ€™t knowâ€ about surrogate pairs.</p>
<p>The regular expression engine thinks that <code>[ğ’³ğ’´]</code> â€“ are not two, but four characters: 1. left half of <code>ğ’³</code> <code>(1)</code>, 2. right half of <code>ğ’³</code> <code>(2)</code>, 3. left half of <code>ğ’´</code> <code>(3)</code>, 4. right half of <code>ğ’´</code> <code>(4)</code>.</p>
<p>We can see their codes like this:</p>
<p><code>js run for(let i=0; i&lt;'ğ’³ğ’´'.length; i++) {   alert('ğ’³ğ’´'.charCodeAt(i)); // 55349, 56499, 55349, 56500 };</code></p>
<p>So, the example above finds and shows the left half of <code>ğ’³</code>.</p>
<p>If we add flag <code>pattern:u</code>, then the behavior will be correct:</p>
<p><code>js run alert( 'ğ’³'.match(/[ğ’³ğ’´]/u) ); // ğ’³</code></p>
<p>The similar situation occurs when looking for a range, such as <code>[ğ’³-ğ’´]</code>.</p>
<p>If we forget to add flag <code>pattern:u</code>, there will be an error:</p>
<p><code>js run 'ğ’³'.match(/[ğ’³-ğ’´]/); // Error: Invalid regular expression</code></p>
<p>The reason is that without flag <code>pattern:u</code> surrogate pairs are perceived as two characters, so <code>[ğ’³-ğ’´]</code> is interpreted as <code>[&lt;55349&gt;&lt;56499&gt;-&lt;55349&gt;&lt;56500&gt;]</code> (every surrogate pair is replaced with its codes). Now itâ€™s easy to see that the range <code>56499-55349</code> is invalid: its starting code <code>56499</code> is greater than the end <code>55349</code>. Thatâ€™s the formal reason for the error.</p>
<p>With the flag <code>pattern:u</code> the pattern works correctly:</p>
<p><code>js run // look for characters from ğ’³ to ğ’µ alert( 'ğ’´'.match(/[ğ’³-ğ’µ]/u) ); // ğ’´</code></p>
