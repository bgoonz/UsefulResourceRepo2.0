<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article (58)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<p>libs:</p>
<ul>
<li>lodash</li>
</ul>
<hr />
<h1 id="function-binding">Function binding</h1>
<p>When passing object methods as callbacks, for instance to <code>setTimeout</code>, there’s a known problem: “losing <code>this</code>”.</p>
<p>In this chapter we’ll see the ways to fix it.</p>
<h2 id="losing-this">Losing “this”</h2>
<p>We’ve already seen examples of losing <code>this</code>. Once a method is passed somewhere separately from the object – <code>this</code> is lost.</p>
<p>Here’s how it may happen with <code>setTimeout</code>:</p>
<p>``<code>js run let user = {   firstName: "John",   sayHi() {     alert(</code>Hello, ${this.firstName}!`); } };</p>
<p><em>!</em> setTimeout(user.sayHi, 1000); // Hello, undefined! <em>/!</em> ```</p>
<p>As we can see, the output shows not “John” as <code>this.firstName</code>, but <code>undefined</code>!</p>
<p>That’s because <code>setTimeout</code> got the function <code>user.sayHi</code>, separately from the object. The last line can be rewritten as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> f <span class="op">=</span> <span class="va">user</span>.<span class="at">sayHi</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="at">setTimeout</span>(f<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span> <span class="co">// lost user context</span></a></code></pre></div>
<p>The method <code>setTimeout</code> in-browser is a little special: it sets <code>this=window</code> for the function call (for Node.js, <code>this</code> becomes the timer object, but doesn’t really matter here). So for <code>this.firstName</code> it tries to get <code>window.firstName</code>, which does not exist. In other similar cases, usually <code>this</code> just becomes <code>undefined</code>.</p>
<p>The task is quite typical – we want to pass an object method somewhere else (here – to the scheduler) where it will be called. How to make sure that it will be called in the right context?</p>
<h2 id="solution-1-a-wrapper">Solution 1: a wrapper</h2>
<p>The simplest solution is to use a wrapping function:</p>
<p>``<code>js run let user = {   firstName: "John",   sayHi() {     alert(</code>Hello, ${this.firstName}!`); } };</p>
<p><em>!</em> setTimeout(function() { user.sayHi(); // Hello, John! }, 1000); <em>/!</em> ```</p>
<p>Now it works, because it receives <code>user</code> from the outer lexical environment, and then calls the method normally.</p>
<p>The same, but shorter:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="va">user</span>.<span class="at">sayHi</span>()<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span> <span class="co">// Hello, John!</span></a></code></pre></div>
<p>Looks fine, but a slight vulnerability appears in our code structure.</p>
<p>What if before <code>setTimeout</code> triggers (there’s one second delay!) <code>user</code> changes value? Then, suddenly, it will call the wrong object!</p>
<p>``<code>js run let user = {   firstName: "John",   sayHi() {     alert(</code>Hello, ${this.firstName}!`); }, };</p>
<p>setTimeout(() =&gt; user.sayHi(), 1000);</p>
<p>// …the value of user changes within 1 second user = { sayHi() { alert(“Another user in setTimeout!”); }, };</p>
<p>// Another user in setTimeout! ```</p>
<p>The next solution guarantees that such thing won’t happen.</p>
<h2 id="solution-2-bind">Solution 2: bind</h2>
<p>Functions provide a built-in method <a href="mdn:js/Function/bind">bind</a> that allows to fix <code>this</code>.</p>
<p>The basic syntax is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// more complex syntax will come a little later</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">let</span> boundFunc <span class="op">=</span> <span class="va">func</span>.<span class="at">bind</span>(context)<span class="op">;</span></a></code></pre></div>
<p>The result of <code>func.bind(context)</code> is a special function-like “exotic object”, that is callable as function and transparently passes the call to <code>func</code> setting <code>this=context</code>.</p>
<p>In other words, calling <code>boundFunc</code> is like <code>func</code> with fixed <code>this</code>.</p>
<p>For instance, here <code>funcUser</code> passes a call to <code>func</code> with <code>this=user</code>:</p>
<p>```js run let user = { firstName: “John” };</p>
<p>function func() { alert(this.firstName); }</p>
<p><em>!</em> let funcUser = func.bind(user); funcUser(); // John <em>/!</em> ```</p>
<p>Here <code>func.bind(user)</code> as a “bound variant” of <code>func</code>, with fixed <code>this=user</code>.</p>
<p>All arguments are passed to the original <code>func</code> “as is”, for instance:</p>
<p>```js run let user = { firstName: “John” };</p>
<p>function func(phrase) { alert(phrase + ‘,’ + this.firstName); }</p>
<p>// bind this to user let funcUser = func.bind(user);</p>
<p><em>!</em> funcUser(“Hello”); // Hello, John (argument “Hello” is passed, and this=user) <em>/!</em> ```</p>
<p>Now let’s try with an object method:</p>
<p>``<code>js run let user = {   firstName: "John",   sayHi() {     alert(</code>Hello, ${this.firstName}!`); } };</p>
<p><em>!</em> let sayHi = user.sayHi.bind(user); // (<em>) </em>/!*</p>
<p>// can run it without an object sayHi(); // Hello, John!</p>
<p>setTimeout(sayHi, 1000); // Hello, John!</p>
<p>// even if the value of user changes within 1 second // sayHi uses the pre-bound value which is reference to the old user object user = { sayHi() { alert(“Another user in setTimeout!”); } }; ```</p>
<p>In the line <code>(*)</code> we take the method <code>user.sayHi</code> and bind it to <code>user</code>. The <code>sayHi</code> is a “bound” function, that can be called alone or passed to <code>setTimeout</code> – doesn’t matter, the context will be right.</p>
<p>Here we can see that arguments are passed “as is”, only <code>this</code> is fixed by <code>bind</code>:</p>
<p>``<code>js run let user = {   firstName: "John",   say(phrase) {     alert(</code>${phrase}, ${this.firstName}!`); }, };</p>
<p>let say = user.say.bind(user);</p>
<p>say(“Hello”); // Hello, John (“Hello” argument is passed to say) say(“Bye”); // Bye, John (“Bye” is passed to say) ```</p>
<p>```<code>smart header="Convenience method:</code>bindAll`" If an object has many methods and we plan to actively pass it around, then we could bind them all in a loop:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="cf">for</span> (<span class="kw">let</span> key <span class="kw">in</span> user) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="cf">if</span> (<span class="kw">typeof</span> user[key] <span class="op">==</span> <span class="st">&quot;function&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">    user[key] <span class="op">=</span> user[key].<span class="at">bind</span>(user)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>JavaScript libraries also provide functions for convenient mass binding , e.g. <a href="http://lodash.com/docs#bindAll">_.bindAll(object, methodNames)</a> in lodash.</p>
<pre><code>
## Partial functions

Until now we have only been talking about binding `this`. Let&#39;s take it a step further.

We can bind not only `this`, but also arguments. That&#39;s rarely done, but sometimes can be handy.

The full syntax of `bind`:

```js
let bound = func.bind(context, [arg1], [arg2], ...);
```

It allows to bind context as `this` and starting arguments of the function.

For instance, we have a multiplication function `mul(a, b)`:

```js
function mul(a, b) {
  return a * b;
}
```

Let&#39;s use `bind` to create a function `double` on its base:

```js run
function mul(a, b) {
  return a * b;
}

*!*
let double = mul.bind(null, 2);
*/!*

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
```

The call to `mul.bind(null, 2)` creates a new function `double` that passes calls to `mul`, fixing `null` as the context and `2` as the first argument. Further arguments are passed &quot;as is&quot;.

That&#39;s called [partial function application](https://en.wikipedia.org/wiki/Partial_application) -- we create a new function by fixing some parameters of the existing one.

Please note that we actually don&#39;t use `this` here. But `bind` requires it, so we must put in something like `null`.

The function `triple` in the code below triples the value:

```js run
function mul(a, b) {
  return a * b;
}

*!*
let triple = mul.bind(null, 3);
*/!*

alert( triple(3) ); // = mul(3, 3) = 9
alert( triple(4) ); // = mul(3, 4) = 12
alert( triple(5) ); // = mul(3, 5) = 15
```

Why do we usually make a partial function?

The benefit is that we can create an independent function with a readable name (`double`, `triple`). We can use it and not provide the first argument every time as it&#39;s fixed with `bind`.

In other cases, partial application is useful when we have a very generic function and want a less universal variant of it for convenience.

For instance, we have a function `send(from, to, text)`. Then, inside a `user` object we may want to use a partial variant of it: `sendTo(to, text)` that sends from the current user.

## Going partial without context

What if we&#39;d like to fix some arguments, but not the context `this`? For example, for an object method.

The native `bind` does not allow that. We can&#39;t just omit the context and jump to arguments.

Fortunately, a function `partial` for binding only arguments can be easily implemented.

Like this:

```js run
*!*
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}
*/!*

// Usage:
let user = {
  firstName: &quot;John&quot;,
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};

// add a partial method with fixed time
user.sayNow = partial(user.say, new Date().getHours() + &#39;:&#39; + new Date().getMinutes());

user.sayNow(&quot;Hello&quot;);
// Something like:
// [10:00] John: Hello!
```

The result of `partial(func[, arg1, arg2...])` call is a wrapper `(*)` that calls `func` with:
- Same `this` as it gets (for `user.sayNow` call it&#39;s `user`)
- Then gives it `...argsBound` -- arguments from the `partial` call (`&quot;10:00&quot;`)
- Then gives it `...args` -- arguments given to the wrapper (`&quot;Hello&quot;`)

So easy to do it with the spread syntax, right?

Also there&#39;s a ready [_.partial](https://lodash.com/docs#partial) implementation from lodash library.

## Summary

Method `func.bind(context, ...args)` returns a &quot;bound variant&quot; of function `func` that fixes the context `this` and first arguments if given.

Usually we apply `bind` to fix `this` for an object method, so that we can pass it somewhere. For example, to `setTimeout`.

When we fix some arguments of an existing function, the resulting (less universal) function is called *partially applied* or *partial*.

Partials are convenient when we don&#39;t want to repeat the same argument over and over again. Like if we have a `send(from, to)` function, and `from` should always be the same for our task, we can get a partial and go on with it.</code></pre>
</body>
</html>
