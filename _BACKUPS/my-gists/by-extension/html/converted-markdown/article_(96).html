<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article (96)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="searching-getelement-queryselector">Searching: getElement<em>, querySelector</em></h1>
<p>DOM navigation properties are great when elements are close to each other. What if they are not? How to get an arbitrary element of the page?</p>
<p>There are additional searching methods for that.</p>
<h2 id="document.getelementbyid-or-just-id">document.getElementById or just id</h2>
<p>If an element has the <code>id</code> attribute, we can get the element using the method <code>document.getElementById(id)</code>, no matter where it is.</p>
<p>For instance:</p>
```html run
<div id="elem">
<div id="elem-content">
Element
</div>
</div>
<script>
    // get the element
  *!*
    let elem = document.getElementById('elem');
  */!*

    // make its background red
    elem.style.background = 'red';
</script>
<p>```</p>
<p>Also, there’s a global variable named by <code>id</code> that references the element:</p>
```html run
<div id="*!*elem*/!*">
<div id="*!*elem-content*/!*">
Element
</div>
</div>
<script>
  // elem is a reference to DOM-element with id="elem"
  elem.style.background = "red";

  // id="elem-content" has a hyphen inside, so it can't be a variable name
  // ...but we can access it using square brackets: window['elem-content']
</script>
<p>```</p>
<p>…That’s unless we declare a JavaScript variable with the same name, then it takes precedence:</p>
```html run untrusted height=0
<div id="elem">

</div>
<script>
  let elem = 5; // now elem is 5, not a reference to <div id="elem">

  alert(elem); // 5
</script>
<p>```</p>
<p>```warn header=“Please don’t use id-named global variables to access elements” This behavior is described <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem">in the specification</a>, so it’s kind of standard. But it is supported mainly for compatibility.</p>
<p>The browser tries to help us by mixing namespaces of JS and DOM. That’s fine for simple scripts, inlined into HTML, but generally isn’t a good thing. There may be naming conflicts. Also, when one reads JS code and doesn’t have HTML in view, it’s not obvious where the variable comes from.</p>
<p>Here in the tutorial we use <code>id</code> to directly reference an element for brevity, when it’s obvious where the element comes from.</p>
<p>In real life <code>document.getElementById</code> is the preferred method. ```</p>
<p>``<code>smart header="The</code>id<code>must be unique" The</code>id<code>must be unique. There can be only one element in the document with the given</code>id`.</p>
<p>If there are multiple elements with the same <code>id</code>, then the behavior of methods that use it is unpredictable, e.g. <code>document.getElementById</code> may return any of such elements at random. So please stick to the rule and keep <code>id</code> unique.</p>
<pre><code>
```warn header=&quot;Only `document.getElementById`, not `anyElem.getElementById`&quot;
The method `getElementById` can be called only on `document` object. It looks for the given `id` in the whole document.</code></pre>
<h2 id="queryselectorall-queryselectorall">querySelectorAll [#querySelectorAll]</h2>
<p>By far, the most versatile method, <code>elem.querySelectorAll(css)</code> returns all elements inside <code>elem</code> matching the given CSS selector.</p>
<p>Here we look for all <code>&lt;li&gt;</code> elements that are last children:</p>
```html run
<ul>
<li>
The
</li>
<li>
test
</li>
</ul>
<ul>
<li>
has
</li>
<li>
passed
</li>
</ul>
<script>
  *!*
    let elements = document.querySelectorAll('ul > li:last-child');
  */!*

    for (let elem of elements) {
      alert(elem.innerHTML); // "test", "passed"
    }
</script>
<p>```</p>
<p>This method is indeed powerful, because any CSS selector can be used.</p>
<p><code>smart header="Can use pseudo-classes as well" Pseudo-classes in the CSS selector like `:hover` and `:active` are also supported. For instance, `document.querySelectorAll(':hover')` will return the collection with elements that the pointer is over now (in nesting order: from the outermost `&lt;html&gt;` to the most nested one).</code></p>
<h2 id="queryselector-queryselector">querySelector [#querySelector]</h2>
<p>The call to <code>elem.querySelector(css)</code> returns the first element for the given CSS selector.</p>
<p>In other words, the result is the same as <code>elem.querySelectorAll(css)[0]</code>, but the latter is looking for <em>all</em> elements and picking one, while <code>elem.querySelector</code> just looks for one. So it’s faster and also shorter to write.</p>
<h2 id="matches">matches</h2>
<p>Previous methods were searching the DOM.</p>
<p>The <a href="http://dom.spec.whatwg.org/#dom-element-matches">elem.matches(css)</a> does not look for anything, it merely checks if <code>elem</code> matches the given CSS-selector. It returns <code>true</code> or <code>false</code>.</p>
<p>The method comes in handy when we are iterating over elements (like in an array or something) and trying to filter out those that interest us.</p>
<p>For instance:</p>
<p>```html run <a href="http://example.com/file.zip">…</a> <a href="http://ya.ru">…</a></p>
<script>
    // can be any collection instead of document.body.children
    for (let elem of document.body.children) {
  *!*
      if (elem.matches('a[href$="zip"]')) {
  */!*
        alert("The archive reference: " + elem.href );
      }
    }
</script>
<p>```</p>
<h2 id="closest">closest</h2>
<p><em>Ancestors</em> of an element are: parent, the parent of parent, its parent and so on. The ancestors together form the chain of parents from the element to the top.</p>
<p>The method <code>elem.closest(css)</code> looks for the nearest ancestor that matches the CSS-selector. The <code>elem</code> itself is also included in the search.</p>
<p>In other words, the method <code>closest</code> goes up from the element and checks each of parents. If it matches the selector, then the search stops, and the ancestor is returned.</p>
<p>For instance:</p>
```html run
<h1>
Contents
</h1>
<div class="contents">
<ul class="book">
<li class="chapter">
Chapter 1
</li>
<li class="chapter">
Chapter 1
</li>
</ul>
</div>
<script>
  let chapter = document.querySelector(".chapter"); // LI

  alert(chapter.closest(".book")); // UL
  alert(chapter.closest(".contents")); // DIV

  alert(chapter.closest("h1")); // null (because h1 is not an ancestor)
</script>
<p>```</p>
<h2 id="getelementsby">getElementsBy*</h2>
<p>There are also other methods to look for nodes by a tag, class, etc.</p>
<p>Today, they are mostly history, as <code>querySelector</code> is more powerful and shorter to write.</p>
<p>So here we cover them mainly for completeness, while you can still find them in the old scripts.</p>
<ul>
<li><code>elem.getElementsByTagName(tag)</code> looks for elements with the given tag and returns the collection of them. The <code>tag</code> parameter can also be a star <code>"*"</code> for “any tags”.</li>
<li><code>elem.getElementsByClassName(className)</code> returns elements that have the given CSS class.</li>
<li><code>document.getElementsByName(name)</code> returns elements with the given <code>name</code> attribute, document-wide. Very rarely used.</li>
</ul>
<p>For instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// get all divs in the document</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">let</span> divs <span class="op">=</span> <span class="va">document</span>.<span class="at">getElementsByTagName</span>(<span class="st">&quot;div&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p>Let’s find all <code>input</code> tags inside the table:</p>
```html run height=50
<table id="table">
<tr>
<td>
Your age:
</td>
<td>
<label> <input type="radio" name="age" value="young" checked /> less than 18 </label> <label> <input type="radio" name="age" value="mature" /> from 18 to 50 </label> <label> <input type="radio" name="age" value="senior" /> more than 60 </label>
</td>
</tr>
</table>
<script>
  *!*
    let inputs = table.getElementsByTagName('input');
  */!*

    for (let input of inputs) {
      alert( input.value + ': ' + input.checked );
    }
</script>
<p>```</p>
<p>``<code>warn header="Don't forget the</code>"s"<code>letter!" Novice developers sometimes forget the letter</code>“s”<code>. That is, they try to call</code>getElementByTagName` instead of <code>getElement<b>s</b>ByTagName</code>.</p>
<p>The <code>"s"</code> letter is absent in <code>getElementById</code>, because it returns a single element. But <code>getElementsByTagName</code> returns a collection of elements, so there’s <code>"s"</code> inside.</p>
<pre><code>
````warn header=&quot;It returns a collection, not an element!&quot;
Another widespread novice mistake is to write:

```js
// doesn&#39;t work
document.getElementsByTagName(&#39;input&#39;).value = 5;</code></pre>
<p>That won’t work, because it takes a <em>collection</em> of inputs and assigns the value to it rather than to elements inside it.</p>
<p>We should either iterate over the collection or get an element by its index, and then assign, like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// should work (if there&#39;s an input)</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="va">document</span>.<span class="at">getElementsByTagName</span>(<span class="st">&quot;input&quot;</span>)[<span class="dv">0</span>].<span class="at">value</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a></code></pre></div>
<pre><code>
Looking for `.article` elements:

```html run height=50
&lt;form name=&quot;my-form&quot;&gt;
  &lt;div class=&quot;article&quot;&gt;Article&lt;/div&gt;
  &lt;div class=&quot;long article&quot;&gt;Long article&lt;/div&gt;
&lt;/form&gt;

&lt;script&gt;
  // find by name attribute
  let form = document.getElementsByName(&#39;my-form&#39;)[0];

  // find by class inside the form
  let articles = form.getElementsByClassName(&#39;article&#39;);
  alert(articles.length); // 2, found two elements with class &quot;article&quot;
&lt;/script&gt;
```

## Live collections

All methods `&quot;getElementsBy*&quot;` return a *live* collection. Such collections always reflect the current state of the document and &quot;auto-update&quot; when it changes.

In the example below, there are two scripts.

1. The first one creates a reference to the collection of `&lt;div&gt;`. As of now, its length is `1`.
2. The second scripts runs after the browser meets one more `&lt;div&gt;`, so its length is `2`.

```html run
&lt;div&gt;First div&lt;/div&gt;

&lt;script&gt;
  let divs = document.getElementsByTagName(&#39;div&#39;);
  alert(divs.length); // 1
&lt;/script&gt;

&lt;div&gt;Second div&lt;/div&gt;

&lt;script&gt;
*!*
  alert(divs.length); // 2
*/!*
&lt;/script&gt;
```

In contrast, `querySelectorAll` returns a *static* collection. It&#39;s like a fixed array of elements.

If we use it instead, then both scripts output `1`:


```html run
&lt;div&gt;First div&lt;/div&gt;

&lt;script&gt;
  let divs = document.querySelectorAll(&#39;div&#39;);
  alert(divs.length); // 1
&lt;/script&gt;

&lt;div&gt;Second div&lt;/div&gt;

&lt;script&gt;
*!*
  alert(divs.length); // 1
*/!*
&lt;/script&gt;
```

Now we can easily see the difference. The static collection did not increase after the appearance of a new `div` in the document.

## Summary

There are 6 main methods to search for nodes in DOM:

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td&gt;Method&lt;/td&gt;
&lt;td&gt;Searches by...&lt;/td&gt;
&lt;td&gt;Can call on an element?&lt;/td&gt;
&lt;td&gt;Live?&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;querySelector&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;CSS-selector&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;querySelectorAll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;CSS-selector&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementById&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementsByName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementsByTagName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;tag or &lt;code&gt;&#39;*&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementsByClassName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

By far the most used are `querySelector` and `querySelectorAll`, but `getElement(s)By*` can be sporadically helpful or found in the old scripts.

Besides that:

- There is `elem.matches(css)` to check if `elem` matches the given CSS selector.
- There is `elem.closest(css)` to look for the nearest ancestor that matches the given CSS-selector. The `elem` itself is also checked.

And let&#39;s mention one more method here to check for the child-parent relationship, as it&#39;s sometimes useful:
-  `elemA.contains(elemB)` returns true if `elemB` is inside `elemA` (a descendant of `elemA`) or when `elemA==elemB`.</code></pre>
</body>
</html>
