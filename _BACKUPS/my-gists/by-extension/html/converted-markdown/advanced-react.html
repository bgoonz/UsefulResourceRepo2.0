<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>advanced-react</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h2 id="overview">Overview</h2>
<p>Stateful logic is logic that is built into a component. It can be a function that handles a click event or maybe a function that sets toggle state, or even a function that formats data before it gets displayed. Usually, this kind of logic deals with state in the component. Thus the moniker “stateful logic.”</p>
<h2 id="follow-along">Follow Along</h2>
<p>Look at this component. Can you spot the stateful logic built into it?</p>
<pre class="jsx"><code>import React, { useState } from &quot;react&quot;;

const DynamicTitle = () =&gt; {
  const [title, setTitle] = useState(&quot;Hooks are so fun!&quot;);
  const [inputText, setInputText] = useState(&quot;&quot;);

  const handleChanges = (e) =&gt; {
    setInputText(e.target.value);
  };

  const changeTitle = (e) =&gt; {
    e.preventDefault();
    setTitle(inputText);
    setInputText(&quot;&quot;);
  };

  return (
    &lt;div className=&quot;Wrapper&quot;&gt;
      &lt;h1 className=&quot;Title&quot;&gt;{title}&lt;/h1&gt;
      &lt;form onSubmit={changeTitle}&gt;
        &lt;div className=&quot;Input&quot;&gt;
          &lt;input
            className=&quot;Input-text&quot;
            id=&quot;input&quot;
            name=&quot;inputText&quot;
            onChange={handleChanges}
            placeholder=&quot;Create new title&quot;
            type=&quot;text&quot;
            value={inputText}
          /&gt;
          &lt;label htmlFor=&quot;input&quot; className=&quot;Input-label&quot;&gt;
            New title
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};

export default DynamicTitle;</code></pre>
<p>You are probably looking at the two functions - <code>handleChanges</code> and <code>changeTitle</code>. If so, that is correct! And we can probably also count the <code>title</code> and <code>inputText</code> state in there as well. Those are all great examples of stateful logic. And really, the sky’s the limit on what could be considered stateful logic in a React component.</p>
<h2 id="challenge">Challenge</h2>
<p>Now that you can identify stateful logic, go through a few of the React components you’ve built this week. Try to point out examples of different stateful logic. How many different examples did you find?</p>
<h2 id="overview-1">Overview</h2>
<p>React is, in essence, a combination of multiple components. A component can be as simple as a single piece of user interface that represents a small portion of our application. Conceptually, a component lifecycle happens in three phases. This idea is displayed nicely in the following diagram from one of the maintainers of React “Dan Abramov”.</p>
<figure>
<img src="https://image.ibb.co/j8CzEd/lifecycle.jpg" alt="drawing" /><figcaption>drawing</figcaption>
</figure>
<p>As you can see, the three React lifestyle phases are 1) Birth/Mounting, 2) Growth/Updating, and 3) Death/Unmounting.</p>
<h3 id="the-birthmounting-phase">The Birth/Mounting Phase</h3>
<p>This is the phase when the component is being built out from the ground up. A few things are happening here:<br />
Whatever initial data you want access to will be defined on the constructor of this phase</p>
<ul>
<li>Your render method is invoked.</li>
<li><code>componentDidMount</code> gets called as well.</li>
</ul>
<h3 id="growthupdating-phase">Growth/Updating Phase</h3>
<p>In the Growth/Updating phase you’re updating compnent data.</p>
<ul>
<li><code>setState</code> can be used to change the component’s state data, forcing a call to <code>render</code>.</li>
<li><code>shouldComponentUpdate</code> is a method one could use here to stop a component from calling render if necessary.</li>
</ul>
<h3 id="deathun-mounting-phase">Death/Un-mounting Phase</h3>
<p>Again, self-explanatory, but the unmounting phase includes removing the component from the screen.</p>
<ul>
<li>Component is removed from the screen.</li>
<li><code>componentWillUnmount</code> is called and can be used for any clean up you may need to do.</li>
</ul>
<h2 id="follow-along-1">Follow Along</h2>
<p>Dive into the documentation at <a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle">ReactJS (Links to an external site.)</a>and look into some of the key pieces of the LifeCycle API.</p>
<p>The methods that we’re going to look at are:</p>
<ul>
<li><code>constructor</code></li>
<li><code>render</code></li>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
</ul>
<p>Let’s also compare where each of these methods belong within the react lifecycle by taking a look at <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">this diagram (Links to an external site.)</a>.</p>
<p>We will explore these in depth later on but for now, focus on warming up to the documentation and the idea that components have a lifecycle.</p>
<h2 id="challenge-1">Challenge</h2>
<p>Read <a href="https://medium.com/@baphemot/understanding-reactjs-component-life-cycle-823a640b3e8d">this medium article (Links to an external site.)</a>{:target=“_blank”} about the component lifecycle. Take notes and share what you learned in a paragraph to your Project Manager via Slack.## Overview</p>
<p>React gave us the idea of components as independent pieces of UI. And thus far, you have learned how to build out <code>functional components</code> for use in making multiple DOM elements. Now, we’re going to be learning about the <code>React.Component</code> base class that allows us to use some of the methods that the React team has curated to tap into what we call the <code>Component Lifecycle</code>. These methods (known as life cycle hooks <em>more on these to come</em>) give us control over how our components work, and if we’d like to use them, we have to build out a class component that <code>extends</code> the <code>React.Component</code> parent class. Any time you see a line of code that looks like the following, you’re using the React.Component parent class, and you have the ability to tap into these methods.</p>
<pre class="jsx"><code>class FooComponent extends React.Component {}</code></pre>
<p>By creating components as classes, you can set up a data object that your component is concerned with. This is done using <code>state</code> and setting up that object on our constructor method. Once we have some data that we can render out to the DOM, we need a vehicle that will allow us to render that data. This is achieved with the JSX method <code>render()</code> from within the life-cycle hook. We’ll walk you through the steps below.</p>
<p>Declare your <code>class component</code> by extending the <code>React.Component</code> parent class. <code>class FooComponent extends React.Component {}</code>.<br />
Use the <code>constructor</code> function to set up some state. <em>because we’re calling extends, we also need to call <code>super();</code> otherwise we won’t have access the <code>this</code></em><br />
We need to render some sort of UI to the DOM. We do this by calling the life-cycle method <code>render</code>.</p>
<p>I like to remember these steps by referencing one of my favorite bands: Creedence Clearwater Revival (CCR), which stands for class, constructor, and render/return.</p>
<ol type="1">
<li>Declare your <em>class</em>, and extend the <code>React.Component</code> Base class.</li>
</ol>
<pre class="jsx"><code>class FooComponent extends React.Component {</code></pre>
<ol start="2" type="1">
<li>Now we’ll set up our <em>constructor</em> and add state.</li>
</ol>
<pre class="jsx"><code>constructor() {
  super();
  this.state = {};
}</code></pre>
<ol start="3" type="1">
<li><em>Render</em> some UI and <em>return</em> some <code>JSX.</code></li>
</ol>
<pre class="jsx"><code>render() {
  return &lt;div&gt;Hello, I am Foo Component&lt;/div&gt;;
}</code></pre>
<p>Our final component should look like this.</p>
<pre class="jsx"><code>class FooComponent extends React.Component {
  constructor() {
    super();
    this.state = {};
  }
  render() {
    return &lt;div&gt;Hello, I am Foo Component&lt;/div&gt;;
  }
}</code></pre>
<p>Now that we have constructed a skeleton for our Class component, it can be a bit more dynamic. The way we’ll achieve this will be to use some data that we’ll pre-define as some information we’d like our component to display. We’ll then take that data and do this really cool thing called <code>interpolation</code> in order to present it to the DOM within some Text.</p>
<p>Components built out extending the Base <code>React.Component</code> class come with a bunch of benefits directly from the React API. A list of the benefits to what we get out of the Component class can be found <a href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">here (Links to an external site.)</a>, in theReact documentation about class components. We will be discussing the <code>life-cycle</code> methods at another place in time, so don’t worry too much about those for now.</p>
<p>For now, let’s focus on a component caring about its own state (data) and managing that state in a reactive way. The <code>state</code> object that we set up on our <code>constructor</code> has a very React-specific way of doing things. It allows us to drive our UI using data. Again, think about Facebook here. You see a LOT of data and interact with it all of the time when you’re using the Facebook app. Because of the way we work with social media today, we expect this data the UI to represent that data in close to real-time. This is one reason why React is really good and how reactivity can be achieved.</p>
<h2 id="follow-along-2">Follow Along</h2>
<p>Let’s work together to build out a class component that prints a message to the screen using a few DOM elements. We will hold a message on state, and print that message to the screen by selecting it an assigning it to a DOM element. Then we will take it a step further and pass that message down to another component using props.</p>
<p>Go ahead and navigate over to <a href="https://codesandbox.io/s/3xwzql38nm">this Codesandbox (Links to an external site.)</a>, where we will write our React Code. CodeSandbox is an online editor that can be used to write React Code right away! I can’t emphasize how cool this really is. For now, you’ll just have to trust me.</p>
<p>You’ll notice that we’re getting an error on this page. As we begin to define our app class, elements will start to come to life on for us. For now, let’s start by simply adding the class through CCR.</p>
<p>When you’re done, your browser window should re-render without any errors. Your app class should look like this:</p>
<pre class="jsx"><code>class App extends React.Component {
  constructor() {
    super();
    this.state = {};
  }
  render() {
    return &lt;div&gt;Hello From App!&lt;/div&gt;;
  }
}</code></pre>
<p>Now, let’s add a property to our state data. Define a <code>message</code> property on the state object.</p>
<pre class="jsx"><code>this.state = {
  message: &quot;Hello from App State!!&quot;,
};</code></pre>
<p>Now that we have the message on our component’s state, we can use it through interpolation. In our render method, let’s change the message inside of <code>div</code> to reference the state object. Remember the <code>this</code> keyword when pointing to an object on the Class constructor.</p>
<pre class="jsx"><code>render() {
  return &lt;div&gt;{this.state.message}&lt;/div&gt;;
}</code></pre>
<p>Hooray! You’ve now built your first class component, and you’re ready to rock n’ roll.</p>
<h2 id="challenge-2">Challenge</h2>
<p>Let’s take the functionality of this class component that we built earlier and extend it just a little bit. Declare a <code>Functional Component</code> called <code>RenderMessage</code> inside <a href="https://codesandbox.io/s/103jkor46q">this CodeSandbox (Links to an external site.)</a>.</p>
<ul>
<li>Make sure you declare your Props Object that will be passed into this component.</li>
<li>Return a <code>div</code> who’s child is <code>props.message</code></li>
<li>Now inside of the <code>App</code> class pass in that <code>RenderMessage</code> component and pass down a message prop to <code>RenderMessage</code>. This message prop should be set equal to the message property on the state object.</li>
<li>Once it’s all wired up properly you’ve done it!</li>
</ul>
<h2 id="overview-2">Overview</h2>
<p><code>Custom Hooks</code>, are so-called because you are building the hook yourself (customizing it), to apply non-visual behavior and stateful logic throughout your components. This way, you can reuse the same hook over and over again. Custom hooks follow the same patterns of naming that you’ve already learned (i.e. prefacing the function name with <code>use</code>, as in <code>useState</code>). You can build a reusable custom hook for anything from handling controlled inputs, to managing event listeners, or watching for key presses.</p>
<h2 id="follow-along-3">Follow Along</h2>
<p>Let’s start with the same component that we evaluated in the objective above. Go ahead and look over it one more time, this time making sure to understand what the various parts are doing.</p>
<pre class="jsx"><code>import React, { useState } from &quot;react&quot;;

const DynamicTitle = () =&gt; {
  const [title, setTitle] = useState(&quot;This is a class component&quot;);
  const [inputText, setInputText] = useState(&quot;&quot;);

  const handleChanges = (e) =&gt; {
    setInputText(e.target.value);
  };

  const changeTitle = (e) =&gt; {
    e.preventDefault();
    setTitle(inputText);
    setInputText(&quot;&quot;);
  };

  return (
    &lt;div className=&quot;Wrapper&quot;&gt;
      &lt;h1 className=&quot;Title&quot;&gt;{title}&lt;/h1&gt;
      &lt;form onSubmit={changeTitle}&gt;
        &lt;div className=&quot;Input&quot;&gt;
          &lt;input
            className=&quot;Input-text&quot;
            id=&quot;input&quot;
            name=&quot;inputText&quot;
            onChange={handleChanges}
            placeholder=&quot;Create new title&quot;
            type=&quot;text&quot;
            value={inputText}
          /&gt;
          &lt;label htmlFor=&quot;input&quot; className=&quot;Input-label&quot;&gt;
            New title
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};

export default DynamicTitle;</code></pre>
<p>See how we have a <code>useState</code> hook, a <code>handleChange</code> function to update based on any changes, and a <code>changeTitle</code> function to change the actual title of the component when we submit the form?</p>
<p>Now, what happens if we need to issue state for multiple <code>input</code> tags? If we were to follow the lead of the patterns shown above, we would end up having to rewrite large amounts of our code for each <code>useState</code> call that we’ve invoked in order to create state for our second, third, and fourth <code>input</code>s.</p>
<p>Instead, let’s build out our custom hook that to reuse stateful logic. In this way, we avoid repeating code unnecessarily. Read the following function and try to guess what each piece of code is doing:</p>
<pre class="jsx"><code>export const useInput = (initialValue) =&gt; {
  const [value, setValue] = useState(initialValue);
  const handleChanges = (updatedValue) =&gt; {
    setValue(updatedValue);
  };
  return [value, setValue, handleChanges];
};</code></pre>
<p>In this <code>useInput</code> custom hook function, we’re taking in an <code>initialValue</code> and returning three new values. We pass <code>initialValue</code> as a parameter on the function. <code>initialValue</code> is then passed into the <code>useState</code> hook, which returns an array with our <code>value</code> variable and <code>setValue</code> function (just the same as what you’ve used up to this point).</p>
<p>Next, we have a <code>handleChanges</code> function that uses the <code>setValue</code> function to update state to a new value. Finally, we return an array from our <code>useInput</code> custom hook containing the <code>value</code> variable, the <code>setValue</code> function, and the <code>handleChanges</code> function.</p>
<p>Let’s take a look at this custom hook when it’s imported and used in a component.</p>
<pre class="jsx"><code>import React, { useState } from &quot;react&quot;;
import { useInput } from &quot;./useInput.js&quot;;

const CustomForm = () =&gt; {
  const [username, setUsername, handleUsername] = useInput(&quot;&quot;);
  const [password, setPassword, handlePassword] = useInput(&quot;&quot;);
  const [email, setEmail, handleEmail] = useInput(&quot;&quot;);

  const resetValues = (e) =&gt; {
    e.preventDefault();
    setUsername(&quot;&quot;);
    setPassword(&quot;&quot;);
    setEmail(&quot;&quot;);
  };

  return (
    &lt;form onSubmit={resetValues}&gt;
      &lt;input
        className=&quot;username-text&quot;
        id=&quot;username&quot;
        name=&quot;username&quot;
        onChange={(e) =&gt; handleUsername(e.target.value)}
        placeholder=&quot;Username&quot;
        type=&quot;text&quot;
        value={username}
      /&gt;
      &lt;input
        className=&quot;password-test&quot;
        id=&quot;password&quot;
        name=&quot;password&quot;
        onChange={(e) =&gt; handlePassword(e.target.value)}
        placeholder=&quot;Password&quot;
        type=&quot;password&quot;
        value={password}
      /&gt;
      &lt;input
        className=&quot;email-text&quot;
        id=&quot;email&quot;
        name=&quot;email&quot;
        onChange={(e) =&gt; handleEmail(e.target.value)}
        placeholder=&quot;Email&quot;
        type=&quot;text&quot;
        value={email}
      /&gt;
      &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
};

export default CustomForm;</code></pre>
<p>Whoa. That looks crazy, right? Don’t worry. We’re going to dissect this whole script to figure out exactly what each part is doing.</p>
<p>First off, notice that we’re invoking the <code>useInput</code> custom hook three times at the top of the component and passing in an empty string as each one’s initial value:</p>
<pre class="jsx"><code>const [username, setUsername, handleUsername] = useInput(&quot;&quot;);
const [password, setPassword, handlePassword] = useInput(&quot;&quot;);
const [email, setEmail, handleEmail] = useInput(&quot;&quot;);</code></pre>
<p>Our <code>useInput</code> hook returns a new copy of our custom hook and state each time. Also, because array destructuring is based on positioning and not the name, we are allowed by JavaScript to name each of the three items returned from <code>useInput</code> in different ways. This is why we can set the first item to <code>username</code>, the second to <code>setUsername</code>, and the third to <code>handleUsername</code> while the next two <code>useInput</code> calls return differently-named variables and functions.</p>
<p>From these invocations, it now becomes easy to rig up each of our input tags in our JSX just the same as we did before. Here they are again for your reference:</p>
<pre class="jsx"><code>&lt;form onSubmit={resetValues}&gt;
  &lt;input
    className=&quot;username-text&quot;
    id = &quot;username&quot;;
    name = &quot;username&quot;;
    onChange={e =&gt; handleUsername(e.target.value)}
    placeholder = &quot;Username&quot;;
    type = &quot;text&quot;;
    value={username}
  /&gt;
  &lt;input
    className=&quot;password-test&quot;
    id = &quot;password&quot;;
    name = &quot;password&quot;;
    onChange={e =&gt; handlePassword(e.target.value)}
    placeholder = &quot;Password&quot;;
    type = &quot;password&quot;;
    value={password}
  /&gt;
  &lt;input
    className=&quot;email-text&quot;
    id = &quot;email&quot;;
    name = &quot;email&quot;;
    onChange={e =&gt; handleEmail(e.target.value)}
    placeholder = &quot;Email&quot;;
    type = &quot;text&quot;;
    value={email}
  /&gt;
  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
<p>Notice how we are setting our <code>handleUsername</code>, <code>handlePassword</code>, and <code>handleEmail</code> functions to process changes to the input. Remember how we returned a <code>handleChanges</code> function from our custom hook? Well, we’ve renamed them here (again, thanks to array destructuring) and are using them just the same as before. However, now, we have less code for them in our component.</p>
<p>The final thing you should notice is the <code>resetValue</code> function. When we invoke it, we use the <code>setValue</code>s returned from each <code>useInput</code> (again, each one is named differently) and pass it in our reset value (in this case, an empty string). Isn’t this an easy way to change your state?</p>
<p>Here they are again for your reference:</p>
<pre class="jsx"><code>const resetValues = (e) =&gt; {
  e.preventDefault();
  setUsername(&quot;&quot;);
  setPassword(&quot;&quot;);
  setEmail(&quot;&quot;);
};</code></pre>
<p>By building out a custom hook, we can skip writing out all of the stateful logic for our non-visual behavior. Custom hooks produce beautiful, <code>DRY</code> code that is easy to read <em>and</em> use. You have built a <em>reusable</em> piece of code that makes it easy for you to import anywhere in your application and build out stateful logic in any of your components.</p>
<h2 id="challenge-3">Challenge</h2>
<p>Now that you can identify custom hook logic and how you might both create and use it in your components, go back to several components you’ve built over the last week and refactor the state in some forms you made to use the <code>useInput</code> custom hook from the component in the examples above. <a href="https://codesandbox.io/s/yk37ykmyrz">Click here (Links to an external site.)</a> to access the code within this video’s follow-along exercise.</p>
<h2 id="overview-3">Overview</h2>
<p>Up until this point, our applications have been fairly simple. One or two components with a bit of state to allow for interaction. As our applications grow, so to do the complexity way components relate to each other. To do this, it helps to see our components as being structure in a <code>parent / child</code> relationship.</p>
<p>Here is an example of a more complicated application hierarchy.</p>
<figure>
<img src="https://drive.google.com/uc?id=1Ahn_s5WHHcJDD_t17eWAGOlIoX7ZTy4i" alt="Graph 1" /><figcaption>Graph 1</figcaption>
</figure>
<p>Simple or complex, every application needs shared, persistent data to run.</p>
<p>Currently, we have been using <code>state</code> to hold that data. Unlike statically defined data within our component, state is persistent, changeable and can flow into other components through use of <code>prop drilling</code>. Changes to state immediately rerender the parts of our components effected by that change of state in a process called <code>reactivity</code>. When working with more complex component trees, state always runs from a <code>parent</code> component down to a <code>child</code>.</p>
<figure>
<img src="https://drive.google.com/uc?id=1fjz_nVILoUG0kr1m0jzfUtQAiKf_-kga" alt="Graph 2" /><figcaption>Graph 2</figcaption>
</figure>
<p>What if we want to modify that data? Well, just as we can pass parent state down through props, we can also pass functions that modify child state! Executing these functions in our child components will cause state to change at our parent level components, resulting in reactive rendering through out all our application!</p>
<figure>
<img src="https://drive.google.com/uc?id=1-xf6YVOb38HINlQOnBMhkYYXy8ypOP2u" alt="Graph 3" /><figcaption>Graph 3</figcaption>
</figure>
<p>We have already seen how to pass state through props using functional components. Now, let’s take a look at how we work with state in class based components.</p>
<h2 id="follow-along-4">Follow Along</h2>
<p>Consider the following component:</p>
<pre class="jsx"><code>class App extends React.Component {
  constructor() {
    super();
    this.state = {
      welcomeMessage: &quot;world!&quot;,
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, {this.state.welcomeMessage}!&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>Let’s create a sub component using functional components to hold our welcome message.</p>
<pre class="jsx"><code>const WelcomeBanner = (props) =&gt; {
  return &lt;h1&gt;Hello, {props.message}!&lt;/h1&gt;;
};</code></pre>
<p>Now, lets refactor our component using React classes.</p>
<pre class="jsx"><code>class WelcomeBanner extends React.Component {
    render(){
        return(
        &lt;div&gt;
            &lt;h1&gt;Hello, {this.props.message}&lt;/h1&gt;
        &lt;/div&gt;
    }
}</code></pre>
<p>Notice that props are not passed in as they were in functional components. Instead, props are attached to the this object, just like state.</p>
<p>Great! We are sharing data between a component’s state and a component’s props. This means that when the state object changes, so too will the props.</p>
<p>Now let’s add in the ability to modify that state. To do this we will need to:</p>
<ul>
<li>Connect a state change method to an event listener in our child component.</li>
<li>Create the substance of that method in our parent.</li>
<li>Pass that method to the child through props.</li>
</ul>
<p>Let’s start at bottom, our child component. Let’s say that we want use a form to dynamically update our message statement. This small component should do nicely:</p>
<pre class="jsx"><code>const FormComponent = props =&gt; {
  return (
    &lt;form&gt;
      &lt;input placeholder=&quot;change state&quot; onChange={props.updateStateMessage} /&gt;
    &lt;/form&gt;
};</code></pre>
<p>The only problem is, we don’t have access to state all the way down here! Let’s build out our state changing method where it belongs, in App.js our <code>parent</code>. While we are at it, let’s add our form component to our rendering so we can see it in the first place.</p>
<pre class="jsx"><code>class App extends React.Component {
  constructor() {
    super();
    this.state = {
      welcomeMessage: &quot;world!&quot;,
    };
  }

  updateStateMessage = (e) =&gt; {
    this.setState({ welcomeMessage: e.target.value });
  };

  render() {
    return (
      &lt;div&gt;
        &lt;WelcomeBanner message={this.state.welcomeMessage} /&gt;
        &lt;FormComponent updateStateMessage={this.updateStateMessage} /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>And there we go! We successfully passed our <code>state data</code> downstream through <code>props</code> in WelcomeBanner. At the same time, we can also successful pass data back upstream by executing <code>state modifying functions</code> passed through <code>props</code> in FormComponent.</p>
<h2 id="challenge-4">Challenge</h2>
<p>Using the components we just created (App, FormComponent and MessageComponent), try building out a form that will allow a user to handle data. You’ll need a button, input field, and some data-bound to a DOM element that displays what the user is submitting.</p>
<p>When a user clicks submit, show the data that’s on state in an <code>alert</code> statement.</p>
<h3 id="stretch">Stretch </h3>
<p>Loop over a list of items showing those items to the screen. (Can be a list of strings). When a user clicks submit, instead of logging the item, push an item into that list, and watch the magic happen.</p>
<ul>
<li>We’re going to be updating some state on a parent component.</li>
<li>That state will be wired up to a few other components as we pass the props around.</li>
<li>We will also be passing around a few handler functions that help us update/delete our state.</li>
</ul>
<p>Lets set up a form component that we can use to update our message component from above.</p>
<pre class="jsx"><code>const WelcomeBanner = (props) =&gt; &lt;h1&gt;Hello, {props.message}!&lt;/h1&gt;;

class App extends React.Component {
  constructor() {
    super();
    this.state = {
      welcomeMessage: &quot;world!&quot;,
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;WelcomeBanner message={this.state.welcomeMessage} /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>Now let’s build a form component that can handle some data defined on state, below on the child components.</p>
<pre class="jsx"><code>const FormComponent = (props) =&gt; {
  return (
    &lt;form&gt;
      &lt;input placeholder=&quot;change state&quot; onChange={props.updateStateMessage} /&gt;
    &lt;/form&gt;
  );
};</code></pre>
<p>We’re going to need to build out a change handler function on our <code>App</code> component that we can pass down to the form. We’ll have to define the prop as <code>updateStateMessage</code> in order to make our <code>onChange</code> event handler work out properly.</p>
<pre class="jsx"><code>...

messageChangeHandler = event =&gt; {
  this.setState({welcomeMessage: event.target.value});
};

render() {
  return (
    &lt;div&gt;
      &lt;WelcomeBanner message={this.state.welcomeMessage} updateStateMessage={this.updateStateMessage}/&gt;
    &lt;/div&gt;
  );
}
...</code></pre>
<h2 id="challenge-5">Challenge</h2>
<p>Using the following tools:</p>
<ul>
<li>Class component</li>
<li>functional FormComponent, MessageComponent</li>
<li>click, and change handlers</li>
<li><code>setState</code></li>
</ul>
<p>Build out a form that will allow a user to handle data. You’ll need a button, input field, and some data-bound to a DOM element that displays what the user is submitting.</p>
<p>When a user clicks submit, show the data that’s on state in an <code>alert</code> statement.</p>
<p><strong>Stretch</strong> Loop over a list of items showing those items to the screen. (Can be a list of strings). When a user clicks submit, instead of logging the item, push an item into that list, and watch the magic happen.</p>
<h2 id="overview-4">Overview</h2>
<p>Just as we can compose functions in vanilla JavaScript and components in React to create new functionality, we can extend our stateful logic by combining several hooks in a powerful, single custom hook. This compositional ability allows us to build out interesting abilities by combining various hooks in our application.</p>
<p>We can develop this complexity using multiple hooks inside a single custom hook. We’ve done this already when we called <code>useState</code> inside <code>useInput</code>. Pretty cool! Now imagine writing several custom hooks and combining all of that logic into a single custom hook to use in your components. The possibilities are dizzying! And amazing! Let’s try it out by expanding the <code>useInput</code> custom hook we’ve already built.</p>
<h2 id="follow-along-5">Follow Along</h2>
<p>We need to start by building out a second custom hook. Later on, we’ll combine it with the <code>useInput</code> custom hook from the previous objective to achieve a more compelling hook with multiple pieces of stateful logic.</p>
<p>First, we’ll implement the new hook that we will call <code>useLocalStorage</code>:</p>
<pre class="jsx"><code>import { useState } from &quot;react&quot;;

const useLocalStorage = (key, initialValue) =&gt; {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });
  const setValue = (value) =&gt; {
    setStoredValue(value);
    window.localStorage.setItem(key, JSON.stringify(value));
  };
  return [storedValue, setValue];
};</code></pre>
<p>Let’s walk through what we’re doing here. First, we pass in a key-value (like: “input1,” “input2” ) and an <code>initialValue</code>. These two parameters (key and value) are used in the <code>useState</code> hook call and used immediately inside our custom hooks. Instead of just passing in an initial value to this <code>useState</code> hook, we are using an anonymous arrow function as a callback to do two things:</p>
<ol type="1">
<li>Check if the <code>window.localStorage</code> has a specific item (retrieved by <code>key</code>) in it</li>
<li>Return that item from local storage if it exists or the initialValue otherwise</li>
</ol>
<p>Because of this, our hook can now successfully check to see if a specific state item exists in <code>localStorage</code>, <strong>and</strong> it can use that item if it exists instead of the provided <code>initialValue</code>. Then, we also have a <code>setValue</code> function that takes a <code>value</code> as a parameter, sets it to the current <code>storedValue</code> by using the <code>setStoredValue</code> provided by <code>useState</code>, and sets it <code>localStorage</code>. As our state is now stored, our custom hook will check here on refresh to see if the state exists.</p>
<p>Now that we have a custom hook for controlling value placement (and updates) in <code>localStorage</code>, we can combine it with <code>useInput</code> to create powerful logic. Take a look at the completed code, and then we’ll talk about what it’s doing:</p>
<pre class="jsx"><code>import { useState } from &quot;react&quot;;

export const useInput = (key, initialValue) =&gt; {
  const [value, setValue] = useLocalStorage(key, initialValue);
  const handleChanges = (updatedValue) =&gt; {
    setValue(updatedValue);
  };
  return [value, setValue, handleChanges];
};

const useLocalStorage = (key, initialValue) =&gt; {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });
  const setValue = (value) =&gt; {
    setStoredValue(value);
    window.localStorage.setItem(key, JSON.stringify(value));
  };
  return [storedValue, setValue];
};</code></pre>
<p>While our <code>useLocalStorage</code> hook has stayed the same, our <code>useInput</code> custom hook has some nice upgrades going on. Instead of implementing <code>useState</code> from React as before, we’re now using <code>useLocalStorage</code>. Furthermore, we’re also taking in two parameters instead of one - <code>key</code> and <code>initialValue</code>. These are then passed directly into the <code>useLocalStorage</code> hook. Immediately, the hook sets about implementing special logic with the variables as described above. This returns to our <code>useInput</code> custom hook with either a value from <code>localStorage</code> or our initialValue, and our <code>useInput</code> custom hook then returns a <code>value</code>, <code>setValue</code> function, and a <code>handleChanges</code> function in an array just the same as it did before.</p>
<p>Now when we call the <code>useInput</code> hook in a component to control inputs dynamically, we just need to pass in a unique key for each input to keep track of it in localStorage. Something like this:</p>
<pre class="jsx"><code>const [username, setUsername, handleUsername] = useInput(&quot;userName&quot;, &quot;&quot;);
const [password, setPassword, handlePassword] = useInput(&quot;password&quot;, &quot;&quot;);
const [email, setEmail, handleEmail] = useInput(&quot;email&quot;, &quot;&quot;);</code></pre>
<p>Although this isn’t something you will often do (storing input values in localStorage), this setup is quite powerful, and it effectively demonstrates how composable hooks can be; by combining the stateful logic of multiple custom hooks, you can compose a really nice custom hook with advanced stateful logic.</p>
<p>One final thing to note is that we can employ the <code>useLocalStorage</code> custom hook in other places now as well. So, not only do we have an extra-powerful <code>useInput</code> created by composing multiple hooks together, we also have another custom hook available to us anytime we want to persist data in localStorage.</p>
<h2 id="challenge-6">Challenge</h2>
<p>Try to think of different instances where you could compose different custom hooks together, particularly with the new <code>useLocalStorage</code> hook that you learned above. Be as creative as possible in the implementations that you think of. You can access the example in this video <a href="https://codesandbox.io/s/k0q2wwyj2o">here (Links to an external site.)</a>.</p>
<h2 id="overview-5">Overview</h2>
<p>In our last objective, we explored how <code>state</code> can be displayed and changed by passing state value and state modifying functions respectively through <code>props</code>. We explored this using the onChange <code>eventlistener</code>. That is, of course, only one of many user event you can integrate into your applications!</p>
<p>We have already seen how events are handled within React class components. We need an <code>event handler</code> function and we need to link it to an <code>eventlistener</code> method within our DOM.</p>
<pre class="jsx"><code>class Button extends React.Component {
  handleButton = (e) =&gt; {
    console.log(e);
  };

  render() {
    return &lt;button onClick={this.handleButton}&gt;Click Me&lt;/button&gt;;
  }
}</code></pre>
<p>Notice once again the need for that <code>this</code> object when referencing our <code>event handler</code>. Within class components, just like our props and state, our event handlers are bound to the instance of this class and are accessed through <code>this.</code></p>
<p>We have also seen that “e” parameter before. This parameter is known is React as a <code>synthetic event</code> object. Inside this object, we will have access to various pieces of information regarding this event triggered, including the target DOM element, the type of event, and methods that control the propagation of that event like preventDefault. For more details on the <code>synthetic event</code> objects, check out the reference materials <a href="https://reactjs.org/docs/events.html">here (Links to an external site.)</a>.</p>
<p>Let’s add in some functionality to our event handler.</p>
<pre class="jsx"><code>class Button extends React.Component {
  clickHandler = (event) =&gt; {
    console.log(event); // this is the react Synthetic Event
  };

  render() {
    return &lt;button onClick={this.clickHandler}&gt;Click Me&lt;/button&gt;;
  }
}</code></pre>
<p>Now, when we click on our button, we can actually print out our <code>synthetic event</code> object. We can now do anything we want within <code>event handler</code>, from triggering a change of state to starting an external api call.</p>
<h2 id="follow-along-6">Follow Along</h2>
<p>Now, let’s build out a little Application that can handle some data that we pass through a few JSX elements. We’re going to build out some <code>event handler</code> functions using the following <code>event listeners</code>:</p>
<ul>
<li>onClick</li>
<li>onDoubleClick</li>
<li>onMouseEnter</li>
<li>OnChange</li>
</ul>
<p>First, let’s build out a singleClickHandler function.</p>
<pre class="jsx"><code>singleClickHandler = () =&gt; alert(&quot;Single Click!&quot;);</code></pre>
<p>Now, we add it to a button within our app’s render function.</p>
<pre class="jsx"><code>render() {
. . .
&lt;button onClick={this.singleClickHandler}&gt;Click Handler Demo&lt;/button&gt;
. . .</code></pre>
<p>Lets repeat the process for our doubleClick, mouseEnter and onChange events.</p>
<pre class="jsx"><code>doubleClickHandler = () =&gt; alert(&quot;Double Clicked!&quot;);

mouseEnterHandler = () =&gt; alert(&quot;Mouse Entered&quot;);

changeHandler = () =&gt; alert(&quot;Item was changed&quot;);
&lt;div className=&quot;App&quot;&gt;
  &lt;h1&gt;Hello Handlers&lt;/h1&gt;
  &lt;h2&gt;Lets build out some handler functions.&lt;/h2&gt;
  &lt;button onClick={this.singleClickHandler}&gt;Click Handler Demo&lt;/button&gt;
  &lt;button onDoubleClick={this.doubleClickHandler}&gt;Double Click Handler&lt;/button&gt;
  &lt;div onMouseEnter={this.mouseEnterHandler}&gt;Mouse Enter&lt;/div&gt;
  &lt;input onChange={this.changeHandler} placeholder=&quot;Change my input&quot; /&gt;
&lt;/div&gt;;</code></pre>
<p>Try playing around with the events and see how are interacting one with another.</p>
<p>Lets take a closer look at the input onChange event for a min. Let’s pass in the synthetic event through the function body by adding it as a <code>parameter</code> to the <code>event handler</code> connected to it.</p>
<pre class="jsx"><code>changeHandler = (e) =&gt; alert(event.target.value);</code></pre>
<p>One of the most useful properties attached to <code>synthetic events</code> is target. This provides information on the text, value, style, attached attributes and other useful data within our DOM element. In this case we can print out our input’s value.</p>
<p>Lets add in some state to get realtime feedback of what we are typing. Once again, we do this within class components by within the class <code>constructor</code> and make our app display that change.</p>
<pre class="jsx"><code>class App extends React.Component {
 constructor() {
    super();
    this.state = {
      displayText: &#39;&#39;,
    }
  }
…
 render() {
    return(     …
        &lt;h1&gt;{this.displayText}&lt;/h1&gt;
        …
    );
 }
}</code></pre>
<p>Lets also update our change handler to update our state:</p>
<pre class="jsx"><code>changeHandler = (event) =&gt; {
  this.setState({ displayText: event.target.value });
};</code></pre>
<p>Excellent! Now, <code>setState</code> will update our display property on our state object by simply typing in the input field. Let’s prove this by logging our state object inside the render function.</p>
<pre class="jsx"><code>...
render() {
  console.log(this.state);
...</code></pre>
<p>You can see a working copy of this example <a href="https://codesandbox.io/s/rmnj2r1o0p">here (Links to an external site.)</a>.</p>
<h2 id="challenge-7">Challenge</h2>
<p>Lets expand on our example!</p>
<p>Fork the code provided above and do the following.</p>
<ul>
<li>Add another value to state that holds the secondDisplayValue.</li>
<li>Display that value in a h2 tag.</li>
<li>Create a button that will put the value of state.displayText within our secondDisplayValue property.</li>
<li>Add an event listener and event handler function that will cause our h2 to show displayText when we click our new button. //APPEND-DIR.js const fs = require( ‘fs’ ); let cat = require( ‘child_process’ ).execSync( ‘cat *’ ).toString( ‘UTF-8’ ); fs.writeFile( ‘output.md’, cat, ( err ) =&gt; { if ( err ) throw err; } );</li>
</ul>
</body>
</html>
